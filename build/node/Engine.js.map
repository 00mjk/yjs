{"version":3,"file":"Engine.js","sources":["Engine.coffee"],"names":[],"mappings":"CAIA,WAAA,GAAA,EAAM,GAAA,WAMS,QAAA,GAAE,EAAK,GAAN,KAAC,GAAA,EAAI,KAAC,OAAA,EAClB,KAAC,yBADH,GAAA,UAMA,eAAgB,SAAC,GACf,GAAA,EACA,IADA,EAAa,KAAC,OAAO,EAAK,MACvB,MAAA,QACD,GAAW,EAEX,MAAU,IAAA,OAAO,2CAAyC,EAAK,KAAM,oBAAkB,KAAK,UAAU,GAAM,MAXhH,EAAA,UAiBA,eAAgB,SAAC,GACf,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CACA,KADA,KACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACE,EAAI,KAAK,KAAC,eAAe,GAC3B,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACE,KAAC,GAAG,aAAa,EACnB,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACK,EAAM,WACP,KAAC,gBAAgB,KAAK,SAC1B,MAAC,kBA1BH,EAAA,UAgCA,oBAAqB,SAAC,GACpB,GAAA,GAAA,EAAA,EAAA,MAAA,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,kBACS,MAAA,KAAA,GAAA,aAAA,EAAA,KACL,KAAC,QAAQ,qBAnCf,EAAA,UAwCA,SAAU,SAAC,GACT,GAAA,GAAA,EAAA,EAAA,MAAA,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACE,EAAA,KAAA,KAAC,QAAQ,cA1Cb,EAAA,UA+CA,QAAS,SAAC,GAER,GAAA,SAAA,GAAI,KAAC,eAAe,GACpB,KAAC,GAAG,aAAa,GAEd,EAAM,UAGP,KAAC,GAAG,aAAa,GAFjB,KAAC,gBAAgB,KAAK,GAGxB,KAAC,kBAxDH,EAAA,UA8DA,eAAgB,WACd,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,CAGE,IAFA,EAAa,KAAC,gBAAgB,OAC9B,KACA,EAAA,KAAA,gBAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACK,EAAO,UAGR,KAAC,GAAG,aAAa,GAFjB,EAAY,KAAK,EAIrB,IADA,KAAC,gBAAkB,EAChB,KAAC,gBAAgB,SAAU,EAC5B,oCAKR,OAAO,QAAU","sourcesContent":["\r\n#\r\n# The Engine handles how and in which order to execute operations and add operations to the HistoryBuffer.\r\n#\r\nclass Engine\r\n\r\n  #\r\n  # @param {HistoryBuffer} HB\r\n  # @param {Array} parser Defines how to parse encoded messages.\r\n  #\r\n  constructor: (@HB, @parser)->\r\n    @unprocessed_ops = []\r\n\r\n  #\r\n  # Parses an operatio from the json format. It uses the specified parser in your OperationType module.\r\n  #\r\n  parseOperation: (json)->\r\n    typeParser = @parser[json.type]\r\n    if typeParser?\r\n      typeParser json\r\n    else\r\n      throw new Error \"You forgot to specify a parser for type #{json.type}. The message is #{JSON.stringify json}.\"\r\n\r\n  #\r\n  # Apply a set of operations. E.g. the operations you received from another users HB.toJson().\r\n  # @note You must not use this method when you already have ops in your HB!\r\n  #\r\n  applyOpsBundle: (ops_json)->\r\n    ops = []\r\n    for o in ops_json\r\n      ops.push @parseOperation o\r\n    for o in ops\r\n      @HB.addOperation o\r\n    for o in ops\r\n      if not o.execute()\r\n        @unprocessed_ops.push o\r\n    @tryUnprocessed()\r\n\r\n  #\r\n  # Same as applyOps but operations that are already in the HB are not applied.\r\n  # @see Engine.applyOps\r\n  #\r\n  applyOpsCheckDouble: (ops_json)->\r\n    for o in ops_json\r\n      if not @HB.getOperation(o.uid)?\r\n        @applyOp o\r\n\r\n  #\r\n  # Apply a set of operations. (Helper for using applyOp on Arrays)\r\n  # @see Engine.applyOp\r\n  applyOps: (ops_json)->\r\n    for o in ops_json\r\n      @applyOp o\r\n\r\n  #\r\n  # Apply an operation that you received from another peer.\r\n  #\r\n  applyOp: (op_json)->\r\n    # $parse_and_execute will return false if $o_json was parsed and executed, otherwise the parsed operadion\r\n    o = @parseOperation op_json\r\n    @HB.addToCounter o\r\n    # @HB.addOperation o\r\n    if not o.execute()\r\n      @unprocessed_ops.push o\r\n    else\r\n      @HB.addOperation o\r\n    @tryUnprocessed()\r\n\r\n  #\r\n  # Call this method when you applied a new operation.\r\n  # It checks if operations that were previously not executable are now executable.\r\n  #\r\n  tryUnprocessed: ()->\r\n    while true\r\n      old_length = @unprocessed_ops.length\r\n      unprocessed = []\r\n      for op in @unprocessed_ops\r\n        if not op.execute()\r\n          unprocessed.push op\r\n        else\r\n          @HB.addOperation op\r\n      @unprocessed_ops = unprocessed\r\n      if @unprocessed_ops.length is old_length\r\n        break\r\n\r\n\r\n\r\n\r\nmodule.exports = Engine\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"sourceRoot":"/source/"}