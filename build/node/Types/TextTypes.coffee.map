{"version":3,"file":"Types/TextTypes.coffee","names":[],"mappings":"","sources":["Types/TextTypes.coffee"],"sourcesContent":["structured_types_uninitialized = require \"./StructuredTypes\"\n\nmodule.exports = (HB)->\n  structured_types = structured_types_uninitialized HB\n  types = structured_types.types\n  parser = structured_types.parser\n\n  #\n  # At the moment TextDelete type equals the Delete type in BasicTypes.\n  # @see BasicTypes.Delete\n  #\n  class TextDelete extends types.Delete\n  parser[\"TextDelete\"] = parser[\"Delete\"]\n\n  #\n  #  Extends the basic Insert type to an operation that holds a text value\n  #\n  class TextInsert extends types.Insert\n    #\n    # @param {String} content The content of this Insert-type Operation. Usually you restrict the length of content to size 1\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (@content, uid, prev, next, origin)->\n      if not (prev? and next?)\n        throw new Error \"You must define prev, and next for TextInsert-types!\"\n      super uid, prev, next, origin\n    #\n    # Retrieve the effective length of the $content of this operation.\n    #\n    getLength: ()->\n      if @isDeleted()\n        0\n      else\n        @content.length\n\n    #\n    # The result will be concatenated with the results from the other insert operations\n    # in order to retrieve the content of the engine.\n    # @see HistoryBuffer.toExecutedArray\n    #\n    val: (current_position)->\n      if @isDeleted()\n        \"\"\n      else\n        @content\n\n    #\n    # Convert all relevant information of this operation to the json-format.\n    # This result can be send to other clients.\n    #\n    _encode: ()->\n      json =\n        {\n          'type': \"TextInsert\"\n          'content': @content\n          'uid' : @getUid()\n          'prev': @prev_cl.getUid()\n          'next': @next_cl.getUid()\n        }\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser[\"TextInsert\"] = (json)->\n    {\n      'content' : content\n      'uid' : uid\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new TextInsert content, uid, prev, next, origin\n\n  #\n  # Handles a Text-like data structures with support for insertText/deleteText at a word-position.\n  #\n  class Word extends types.ListManager\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (uid, beginning, end, prev, next, origin)->\n      super uid, beginning, end, prev, next, origin\n\n    #\n    # Inserts a string into the word\n    #\n    insertText: (position, content)->\n      o = @getOperationByPosition position\n      for c in content\n        op = new TextInsert c, undefined, o.prev_cl, o\n        HB.addOperation(op).execute()\n\n    #\n    # Deletes a part of the word.\n    #\n    deleteText: (position, length)->\n      o = @getOperationByPosition position\n\n      for i in [0...length]\n        d = HB.addOperation(new TextDelete undefined, o).execute()\n        o = o.next_cl\n        while o.isDeleted()\n          if o instanceof types.Delimiter\n            throw new Error \"You can't delete more than there is..\"\n          o = o.next_cl\n        d._encode()\n\n    #\n    # Replace the content of this word with another one. Concurrent replacements are not merged!\n    # Only one of the replacements will be used.\n    #\n    # Can only be used if the ReplaceManager was set!\n    # @see Word.setReplaceManager\n    #\n    replaceText: (text)->\n      if @replace_manager?\n        word = HB.addOperation(new Word undefined).execute()\n        word.insertText 0, text\n        @replace_manager.replace(word)\n      else\n        throw new Error \"This type is currently not maintained by a ReplaceManager!\"\n\n    #\n    # @returns [Json] A Json object.\n    #\n    val: ()->\n      c = for o in @toArray()\n        if o.val?\n          o.val()\n        else\n          \"\"\n      c.join('')\n\n    #\n    # In most cases you would embed a Word in a Replaceable, wich is handled by the ReplaceManager in order\n    # to provide replace functionality.\n    #\n    setReplaceManager: (op)->\n      @saveOperation 'replace_manager', op\n      @validateSavedOperations\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json = {\n        'type': \"Word\"\n        'uid' : @getUid()\n        'beginning' : @beginning.getUid()\n        'end' : @end.getUid()\n      }\n      if @prev_cl?\n        json['prev'] = @prev_cl.getUid()\n      if @next_cl?\n        json['next'] = @next_cl.getUid()\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser['Word'] = (json)->\n    {\n      'uid' : uid\n      'beginning' : beginning\n      'end' : end\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new Word uid, beginning, end, prev, next, origin\n\n  types['TextInsert'] = TextInsert\n  types['TextDelete'] = TextDelete\n  types['Word'] = Word\n  structured_types\n\n\n"],"sourceRoot":"/source/"}