{"version":3,"file":"Types/TextTypes.js","sources":["Types/TextTypes.coffee"],"names":[],"mappings":"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","sourcesContent":["structured_types_uninitialized = require \"./StructuredTypes\"\n\nmodule.exports = (HB)->\n  structured_types = structured_types_uninitialized HB\n  types = structured_types.types\n  parser = structured_types.parser\n\n  #\n  # At the moment TextDelete type equals the Delete type in BasicTypes.\n  # @see BasicTypes.Delete\n  #\n  class TextDelete extends types.Delete\n  parser[\"TextDelete\"] = parser[\"Delete\"]\n\n  #\n  #  Extends the basic Insert type to an operation that holds a text value\n  #\n  class TextInsert extends types.Insert\n    #\n    # @param {String} content The content of this Insert-type Operation. Usually you restrict the length of content to size 1\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (@content, uid, prev, next, origin)->\n      if not (prev? and next?)\n        throw new Error \"You must define prev, and next for TextInsert-types!\"\n      super uid, prev, next, origin\n    #\n    # Retrieve the effective length of the $content of this operation.\n    #\n    getLength: ()->\n      if @isDeleted()\n        0\n      else\n        @content.length\n\n    #\n    # The result will be concatenated with the results from the other insert operations\n    # in order to retrieve the content of the engine.\n    # @see HistoryBuffer.toExecutedArray\n    #\n    val: (current_position)->\n      if @isDeleted()\n        \"\"\n      else\n        @content\n\n    #\n    # Convert all relevant information of this operation to the json-format.\n    # This result can be send to other clients.\n    #\n    _encode: ()->\n      json =\n        {\n          'type': \"TextInsert\"\n          'content': @content\n          'uid' : @getUid()\n          'prev': @prev_cl.getUid()\n          'next': @next_cl.getUid()\n        }\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser[\"TextInsert\"] = (json)->\n    {\n      'content' : content\n      'uid' : uid\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new TextInsert content, uid, prev, next, origin\n\n  #\n  # Handles a Text-like data structures with support for insertText/deleteText at a word-position.\n  #\n  class Word extends types.ListManager\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (uid, beginning, end, prev, next, origin)->\n      super uid, beginning, end, prev, next, origin\n\n    #\n    # Inserts a string into the word\n    #\n    insertText: (position, content)->\n      o = @getOperationByPosition position\n      for c in content\n        op = new TextInsert c, undefined, o.prev_cl, o\n        HB.addOperation(op).execute()\n\n    #\n    # Deletes a part of the word.\n    #\n    deleteText: (position, length)->\n      o = @getOperationByPosition position\n\n      delete_ops = []\n      for i in [0...length]\n        d = HB.addOperation(new TextDelete undefined, o).execute()\n        o = o.next_cl\n        while o.isDeleted() and not (o instanceof types.Delimiter)\n          if o instanceof types.Delimiter\n            throw new Error \"You can't delete more than there is..\"\n          o = o.next_cl\n        delete_ops.push d._encode()\n        if o instanceof types.Delimiter\n          break\n\n\n    #\n    # Replace the content of this word with another one. Concurrent replacements are not merged!\n    # Only one of the replacements will be used.\n    #\n    # Can only be used if the ReplaceManager was set!\n    # @see Word.setReplaceManager\n    #\n    replaceText: (text)->\n      if @replace_manager?\n        word = HB.addOperation(new Word undefined).execute()\n        word.insertText 0, text\n        @replace_manager.replace(word)\n      else\n        throw new Error \"This type is currently not maintained by a ReplaceManager!\"\n\n    #\n    # @returns [Json] A Json object.\n    #\n    val: ()->\n      c = for o in @toArray()\n        if o.val?\n          o.val()\n        else\n          \"\"\n      c.join('')\n\n    #\n    # In most cases you would embed a Word in a Replaceable, wich is handled by the ReplaceManager in order\n    # to provide replace functionality.\n    #\n    setReplaceManager: (op)->\n      @saveOperation 'replace_manager', op\n      @validateSavedOperations\n\n    #\n    # Bind this Word to a textfield.\n    #\n    bind: (textfield)->\n      word = @\n      textfield.value = @val()\n\n      @on \"insert\", (event, op)->\n        o_pos = op.getPosition()\n        fix = (cursor)->\n          if cursor <= o_pos\n            cursor\n          else\n            cursor += 1\n            cursor\n        left = fix textfield.selectionStart\n        right = fix textfield.selectionEnd\n\n        textfield.value = word.val()\n        textfield.setSelectionRange left, right\n\n\n      @on \"delete\", (event, op)->\n        o_pos = op.getPosition()\n        fix = (cursor)->\n          if cursor < o_pos\n            cursor\n          else\n            cursor -= 1\n            cursor\n        left = fix textfield.selectionStart\n        right = fix textfield.selectionEnd\n\n        textfield.value = word.val()\n        textfield.setSelectionRange left, right\n\n      # consume all text-insert changes.\n      textfield.onkeypress = (event)->\n        char = String.fromCharCode event.keyCode\n        if char.length > 0\n          console.log char\n          pos = Math.min textfield.selectionStart, textfield.selectionEnd\n          diff = Math.abs(textfield.selectionEnd - textfield.selectionStart)\n          word.deleteText (pos), diff\n          word.insertText pos, char\n          new_pos = pos + char.length\n          textfield.setSelectionRange new_pos, new_pos\n          event.preventDefault()\n        else\n          event.preventDefault()\n\n      #\n      # consume deletes. Note that\n      #   chrome: won't consume deletions on keypress event.\n      #   keyCode is deprecated. BUT: I don't see another way.\n      #     since event.key is not implemented in the current version of chrome.\n      #     Every browser supports keyCode. Let's stick with it for now..\n      #\n      textfield.onkeydown = (event)->\n        pos = Math.min textfield.selectionStart, textfield.selectionEnd\n        diff = Math.abs(textfield.selectionEnd - textfield.selectionStart)\n        if event.keyCode? and event.keyCode is 8\n          if diff > 0\n            word.deleteText pos, diff\n          else\n            if event.ctrlKey? and event.ctrlKey\n              val = textfield.value\n              new_pos = pos\n              del_length = 0\n              if pos > 0\n                new_pos--\n                del_length++\n              while new_pos > 0 and val[new_pos] isnt \" \" and val[new_pos] isnt '\\n'\n                new_pos--\n                del_length++\n              word.deleteText new_pos, (pos-new_pos)\n              textfield.setSelectionRange new_pos, new_pos\n            else\n              word.deleteText (pos-1), 1\n          event.preventDefault()\n        else if event.keyCode? and event.keyCode is 46\n          if diff > 0\n            word.deleteText pos, diff\n          else\n            word.deleteText pos, 1\n          event.preventDefault()\n\n\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json = {\n        'type': \"Word\"\n        'uid' : @getUid()\n        'beginning' : @beginning.getUid()\n        'end' : @end.getUid()\n      }\n      if @prev_cl?\n        json['prev'] = @prev_cl.getUid()\n      if @next_cl?\n        json['next'] = @next_cl.getUid()\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser['Word'] = (json)->\n    {\n      'uid' : uid\n      'beginning' : beginning\n      'end' : end\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new Word uid, beginning, end, prev, next, origin\n\n  types['TextInsert'] = TextInsert\n  types['TextDelete'] = TextDelete\n  types['Word'] = Word\n  structured_types\n\n\n"],"sourceRoot":"/source/"}