{"version":3,"file":"Types/TextTypes.js","sources":["Types/TextTypes.coffee"],"names":[],"mappings":"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","sourcesContent":["structured_types_uninitialized = require \"./StructuredTypes\"\n\nmodule.exports = (HB)->\n  structured_types = structured_types_uninitialized HB\n  types = structured_types.types\n  parser = structured_types.parser\n\n  #\n  # At the moment TextDelete type equals the Delete type in BasicTypes.\n  # @see BasicTypes.Delete\n  #\n  class TextDelete extends types.Delete\n  parser[\"TextDelete\"] = parser[\"Delete\"]\n\n  #\n  #  Extends the basic Insert type to an operation that holds a text value\n  #\n  class TextInsert extends types.Insert\n    #\n    # @param {String} content The content of this Insert-type Operation. Usually you restrict the length of content to size 1\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (@content, uid, prev, next, origin)->\n      if not (prev? and next?)\n        throw new Error \"You must define prev, and next for TextInsert-types!\"\n      super uid, prev, next, origin\n    #\n    # Retrieve the effective length of the $content of this operation.\n    #\n    getLength: ()->\n      if @isDeleted()\n        0\n      else\n        @content.length\n\n    #\n    # The result will be concatenated with the results from the other insert operations\n    # in order to retrieve the content of the engine.\n    # @see HistoryBuffer.toExecutedArray\n    #\n    val: (current_position)->\n      if @isDeleted()\n        \"\"\n      else\n        @content\n\n    #\n    # Convert all relevant information of this operation to the json-format.\n    # This result can be send to other clients.\n    #\n    _encode: ()->\n      json =\n        {\n          'type': \"TextInsert\"\n          'content': @content\n          'uid' : @getUid()\n          'prev': @prev_cl.getUid()\n          'next': @next_cl.getUid()\n        }\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser[\"TextInsert\"] = (json)->\n    {\n      'content' : content\n      'uid' : uid\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new TextInsert content, uid, prev, next, origin\n\n  #\n  # Handles a Text-like data structures with support for insertText/deleteText at a word-position.\n  #\n  class Word extends types.ListManager\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (uid, beginning, end, prev, next, origin)->\n      super uid, beginning, end, prev, next, origin\n\n    #\n    # Inserts a string into the word\n    #\n    insertText: (position, content)->\n      o = @getOperationByPosition position\n      for c in content\n        op = new TextInsert c, undefined, o.prev_cl, o\n        HB.addOperation(op).execute()\n\n    #\n    # Deletes a part of the word.\n    #\n    deleteText: (position, length)->\n      o = @getOperationByPosition position\n\n      for i in [0...length]\n        d = HB.addOperation(new TextDelete undefined, o).execute()\n        o = o.next_cl\n        while o.isDeleted()\n          if o instanceof types.Delimiter\n            throw new Error \"You can't delete more than there is..\"\n          o = o.next_cl\n        d._encode()\n\n    #\n    # Replace the content of this word with another one. Concurrent replacements are not merged!\n    # Only one of the replacements will be used.\n    #\n    # Can only be used if the ReplaceManager was set!\n    # @see Word.setReplaceManager\n    #\n    replaceText: (text)->\n      if @replace_manager?\n        word = HB.addOperation(new Word undefined).execute()\n        word.insertText 0, text\n        @replace_manager.replace(word)\n      else\n        throw new Error \"This type is currently not maintained by a ReplaceManager!\"\n\n    #\n    # @returns [Json] A Json object.\n    #\n    val: ()->\n      c = for o in @toArray()\n        if o.val?\n          o.val()\n        else\n          \"\"\n      c.join('')\n\n    #\n    # In most cases you would embed a Word in a Replaceable, wich is handled by the ReplaceManager in order\n    # to provide replace functionality.\n    #\n    setReplaceManager: (op)->\n      @saveOperation 'replace_manager', op\n      @validateSavedOperations\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json = {\n        'type': \"Word\"\n        'uid' : @getUid()\n        'beginning' : @beginning.getUid()\n        'end' : @end.getUid()\n      }\n      if @prev_cl?\n        json['prev'] = @prev_cl.getUid()\n      if @next_cl?\n        json['next'] = @next_cl.getUid()\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser['Word'] = (json)->\n    {\n      'uid' : uid\n      'beginning' : beginning\n      'end' : end\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new Word uid, beginning, end, prev, next, origin\n\n  types['TextInsert'] = TextInsert\n  types['TextDelete'] = TextDelete\n  types['Word'] = Word\n  structured_types\n\n\n"],"sourceRoot":"/source/"}