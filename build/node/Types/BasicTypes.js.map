{"version":3,"file":"Types/BasicTypes.js","sources":["Types/BasicTypes.coffee"],"names":[],"mappings":"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","sourcesContent":["module.exports = (HB)->\n  # @see Engine.parse\n  parser = {}\n  execution_listener = []\n\n  #\n  # A generic interface to operations.\n  #\n  # An operation has the following methods:\n  # _encode: encodes an operation (needed only if instance of this operation is sent).\n  # execute: execute the effects of this operations. Good examples are Insert-type and AddName-type\n  # val: in the case that the operation holds a value\n  #\n  # Furthermore an encodable operation has a parser.\n  #\n  class Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @see HistoryBuffer.getNextOperationIdentifier\n    #\n    constructor: (uid)->\n      if not uid?\n        uid = HB.getNextOperationIdentifier()\n      {\n        'creator': @creator\n        'op_number' : @op_number\n      } = uid\n\n    #\n    # Add an event listener. It depends on the operation which events are supported.\n    # @param {String} event Name of the event.\n    # @param {Function} f f is executed in case the event fires.\n    #\n    on: (event, f)->\n      @event_listeners ?= {}\n      @event_listeners[event] ?= []\n      @event_listeners[event].push f\n\n    #\n    # Fire an event.\n    # TODO: Do something with timeouts. You don't want this to fire for every operation (e.g. insert).\n    #\n    callEvent: (event, args)->\n      if @event_listeners[event]?\n        for f in @event_listeners[event]\n          f.call @, event, args\n\n    #\n    # Set the parent of this operation.\n    #\n    setParent: (o)->\n      @parent = o\n\n    #\n    # Computes a unique identifier (uid) that identifies this operation.\n    #\n    getUid: ()->\n      { 'creator': @creator, 'op_number': @op_number }\n\n    #\n    # @private\n    # Notify the all the listeners.\n    #\n    execute: ()->\n      @is_executed = true\n      for l in execution_listener\n        l @_encode()\n      @\n\n    #\n    # @private\n    # Operations may depend on other operations (linked lists, etc.).\n    # The saveOperation and validateSavedOperations methods provide\n    # an easy way to refer to these operations via an uid or object reference.\n    #\n    # For example: We can create a new Delete operation that deletes the operation $o like this\n    #     - var d = new Delete(uid, $o);   or\n    #     - var d = new Delete(uid, $o.getUid());\n    # Either way we want to access $o via d.deletes. In the second case validateSavedOperations must be called first.\n    #\n    # @overload saveOperation(name, op_uid)\n    #   @param {String} name The name of the operation. After validating (with validateSavedOperations) the instantiated operation will be accessible via this[name].\n    #   @param {Object} op_uid A uid that refers to an operation\n    # @overload saveOperation(name, op)\n    #   @param {String} name The name of the operation. After calling this function op is accessible via this[name].\n    #   @param {Operation} op An Operation object\n    #\n    saveOperation: (name, op)->\n\n      #\n      # Every instance of $Operation must have an $execute function.\n      # We use duck-typing to check if op is instantiated since there\n      # could exist multiple classes of $Operation\n      #\n      if op?.execute?\n        # is instantiated\n        @[name] = op\n      else if op?\n        # not initialized. Do it when calling $validateSavedOperations()\n        @unchecked ?= {}\n        @unchecked[name] = op\n\n    #\n    # @private\n    # After calling this function all not instantiated operations will be accessible.\n    # @see Operation.saveOperation\n    #\n    # @return [Boolean] Whether it was possible to instantiate all operations.\n    #\n    validateSavedOperations: ()->\n      uninstantiated = {}\n      success = @\n      for name, op_uid of @unchecked\n        op = HB.getOperation op_uid\n        if op\n          @[name] = op\n        else\n          uninstantiated[name] = op_uid\n          success = false\n      delete @unchecked\n      if not success\n        @unchecked = uninstantiated\n      success\n\n\n\n  #\n  # A simple Delete-type operation that deletes an Insert-type operation.\n  #\n  class Delete extends Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Object} deletes UID or reference of the operation that this to be deleted.\n    #\n    constructor: (uid, deletes)->\n      @saveOperation 'deletes', deletes\n      super uid\n\n    #\n    # @private\n    # Convert all relevant information of this operation to the json-format.\n    # This result can be sent to other clients.\n    #\n    _encode: ()->\n      {\n        'type': \"Delete\"\n        'uid': @getUid()\n        'deletes': @deletes.getUid()\n      }\n\n    #\n    # @private\n    # Apply the deletion.\n    #\n    execute: ()->\n      if @validateSavedOperations()\n        @deletes.applyDelete @\n        super\n        @\n      else\n        false\n\n  #\n  # Define how to parse Delete operations.\n  #\n  parser['Delete'] = (o)->\n    {\n      'uid' : uid\n      'deletes': deletes_uid\n    } = o\n    new Delete uid, deletes_uid\n\n  #\n  # A simple insert-type operation.\n  #\n  # An insert operation is always positioned between two other insert operations.\n  # Internally this is realized as associative lists, whereby each insert operation has a predecessor and a successor.\n  # For the sake of efficiency we maintain two lists:\n  #   - The short-list (abbrev. sl) maintains only the operations that are not deleted\n  #   - The complete-list (abbrev. cl) maintains all operations\n  #\n  class Insert extends Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Operation} prev_cl The predecessor of this operation in the complete-list (cl)\n    # @param {Operation} next_cl The successor of this operation in the complete-list (cl)\n    #\n    # @see HistoryBuffer.getNextOperationIdentifier\n    #\n    constructor: (uid, prev_cl, next_cl, origin)->\n      @saveOperation 'prev_cl', prev_cl\n      @saveOperation 'next_cl', next_cl\n      if origin?\n        @saveOperation 'origin', origin\n      else\n        @saveOperation 'origin', prev_cl\n      super uid\n\n    #\n    # @private\n    #\n    applyDelete: (o)->\n      @deleted_by ?= []\n      @deleted_by.push o\n\n    #\n    # If isDeleted() is true this operation won't be maintained in the sl\n    #\n    isDeleted: ()->\n      @deleted_by?.length > 0\n\n    #\n    # @private\n    # The amount of positions that $this operation was moved to the right.\n    #\n    getDistanceToOrigin: ()->\n      d = 0\n      o = @prev_cl\n      while true\n        if @origin is o\n          break\n        d++\n        #TODO: delete this\n        if @ is @prev_cl\n          throw new Error \"this should not happen ;) \"\n        o = o.prev_cl\n      d\n\n    #\n    # @private\n    # Update the short list\n    # TODO (Unused)\n    update_sl: ()->\n      o = @prev_cl\n      update: (dest_cl,dest_sl)->\n        while true\n          if o.isDeleted()\n            o = o[dest_cl]\n          else\n            @[dest_sl] = o\n\n            break\n      update \"prev_cl\", \"prev_sl\"\n      update \"next_cl\", \"prev_sl\"\n\n\n\n    #\n    # @private\n    # Include this operation in the associative lists.\n    #\n    execute: ()->\n      if @is_executed?\n        return @\n      if not @validateSavedOperations()\n        return false\n      else\n        if @prev_cl?.validateSavedOperations() and @next_cl?.validateSavedOperations() and @prev_cl.next_cl isnt @\n          distance_to_origin = 0\n          o = @prev_cl.next_cl\n          i = 0\n          # $this has to find a unique position between origin and the next known character\n          # case 1: $origin equals $o.origin: the $creator parameter decides if left or right\n          #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4\n          #         o2,o3 and o4 origin is 1 (the position of o2)\n          #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator\n          #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex\n          #         therefore $this would be always to the right of o3\n          # case 2: $origin < $o.origin\n          #         if current $this insert_position > $o origin: $this ins\n          #         else $insert_position will not change (maybe we encounter case 1 later, then this will be to the right of $o)\n          # case 3: $origin > $o.origin\n          #         $this insert_position is to the left of $o (forever!)\n          while true\n            if not o?\n              # TODO: Debugging\n              console.log JSON.stringify @prev_cl.getUid()\n              console.log JSON.stringify @next_cl.getUid()\n            if o isnt @next_cl\n              # $o happened concurrently\n              if o.getDistanceToOrigin() is i\n                # case 1\n                if o.creator < @creator\n                  @prev_cl = o\n                  distance_to_origin = i + 1\n                else\n                  # nop\n              else if o.getDistanceToOrigin() < i\n                # case 2\n                if i - distance_to_origin <= o.getDistanceToOrigin()\n                  @prev_cl = o\n                  distance_to_origin = i + 1\n                else\n                  #nop\n              else\n                # case 3\n                break\n              i++\n              o = o.next_cl\n            else\n              # $this knows that $o exists,\n              break\n          # now reconnect everything\n          @next_cl = @prev_cl.next_cl\n          @prev_cl.next_cl = @\n          @next_cl.prev_cl = @\n        super # notify the execution_listeners\n        \n\n  #\n  # Defines an object that is cannot be changed. You can use this to set an immutable string, or a number.\n  #\n  class ImmutableObject extends Insert\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Object} content\n    #\n    constructor: (uid, @content, prev, next, origin)->\n      super uid, prev, next, origin\n\n    #\n    # @return [String] The content of this operation.\n    #\n    val : ()->\n      @content\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json = {\n        'type': \"ImmutableObject\"\n        'uid' : @getUid()\n        'content' : @content\n      }\n      if @prev_cl?\n        json['prev'] = @prev_cl.getUid()\n      if @next_cl?\n        json['next'] = @next_cl.getUid()\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser['ImmutableObject'] = (json)->\n    {\n      'uid' : uid\n      'content' : content\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new ImmutableObject uid, content, prev, next, origin\n\n  #\n  # A delimiter is placed at the end and at the beginning of the associative lists.\n  # This is necessary in order to have a beginning and an end even if the content\n  # of the Engine is empty.\n  #\n  class Delimiter extends Operation\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Operation} prev_cl The predecessor of this operation in the complete-list (cl)\n    # @param {Operation} next_cl The successor of this operation in the complete-list (cl)\n    #\n    # @see HistoryBuffer.getNextOperationIdentifier\n    #\n    constructor: (uid, prev_cl, next_cl, origin)->\n      @saveOperation 'prev_cl', prev_cl\n      @saveOperation 'next_cl', next_cl\n      @saveOperation 'origin', prev_cl\n      super uid\n\n    #\n    # If isDeleted() is true this operation won't be maintained in the sl\n    #\n    isDeleted: ()->\n      false\n\n    #\n    # @private\n    #\n    execute: ()->\n      if @unchecked?['next_cl']?\n        super\n      else if @unchecked?['prev_cl']\n        if @validateSavedOperations()\n          if @prev_cl.next_cl?\n            throw new Error \"Probably duplicated operations\"\n          @prev_cl.next_cl = @\n          delete @prev_cl.unchecked.next_cl\n          super\n        else\n          false\n      else if @prev_cl? and not @prev_cl.next_cl?\n        delete @prev_cl.unchecked.next_cl\n        @prev_cl.next_cl = @\n      else if @prev_cl? or @next_cl?\n        super\n      else\n        throw new Error \"Delimiter is unsufficient defined!\"\n\n    #\n    # @private\n    #\n    _encode: ()->\n      {\n        'type' : \"Delimiter\"\n        'uid' : @getUid()\n        'prev' : @prev_cl?.getUid()\n        'next' : @next_cl?.getUid()\n      }\n\n  parser['Delimiter'] = (json)->\n    {\n    'uid' : uid\n    'prev' : prev\n    'next' : next\n    } = json\n    new Delimiter uid, prev, next\n\n  # This is what this module exports after initializing it with the HistoryBuffer\n  {\n    'types' :\n      'Delete' : Delete\n      'Insert' : Insert\n      'Delimiter': Delimiter\n      'Operation': Operation\n      'ImmutableObject' : ImmutableObject\n    'parser' : parser\n    'execution_listener' : execution_listener\n  }\n\n\n\n\n"],"sourceRoot":"/source/"}