{"version":3,"file":"Types/StructuredTypes.js","sources":["Types/StructuredTypes.coffee"],"names":[],"mappings":"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","sourcesContent":["basic_types_uninitialized = require \"./BasicTypes\"\n\nmodule.exports = (HB)->\n  basic_types = basic_types_uninitialized HB\n  types = basic_types.types\n  parser = basic_types.parser\n\n  #\n  # Manages map like objects. E.g. Json-Type and XML attributes.\n  #\n  class MapManager extends types.Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (uid)->\n      @map = {}\n      super uid\n\n    #\n    # @see JsonTypes.val\n    #\n    val: (name, content)->\n      if content?\n        if not @map[name]?\n          HB.addOperation(new AddName undefined, @, name).execute()\n        @map[name].replace content\n        @\n      else if name?\n        obj = @map[name]?.val()\n        if obj instanceof types.ImmutableObject\n          obj.val()\n        else\n          obj\n      else\n        result = {}\n        for name,o of @map\n          obj = o.val()\n          if obj instanceof types.ImmutableObject or obj instanceof MapManager\n            obj = obj.val()\n          result[name] = obj\n        result\n\n  #\n  # When a new property in a map manager is created, then the uids of the inserted Operations\n  # must be unique (think about concurrent operations). Therefore only an AddName operation is allowed to\n  # add a property in a MapManager. If two AddName operations on the same MapManager name happen concurrently\n  # only one will AddName operation will be executed.\n  #\n  class AddName extends types.Operation\n\n    #\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Object} map_manager Uid or reference to the MapManager.\n    # @param {String} name Name of the property that will be added.\n    #\n    constructor: (uid, map_manager, @name)->\n      @saveOperation 'map_manager', map_manager\n      super uid\n\n    #\n    # If map_manager doesn't have the property name, then add it.\n    # The ReplaceManager that is being written on the property is unique\n    # in such a way that if AddName is executed (from another peer) it will\n    # always have the same result (ReplaceManager, and its beginning and end are the same)\n    #\n    execute: ()->\n      if not @validateSavedOperations()\n        return false\n      else\n        uid_r = @map_manager.getUid()\n        uid_r.op_number = \"_#{uid_r.op_number}_RM_#{@name}\"\n        if not HB.getOperation(uid_r)?\n          uid_beg = @map_manager.getUid()\n          uid_beg.op_number = \"_#{uid_beg.op_number}_RM_#{@name}_beginning\"\n          uid_end = @map_manager.getUid()\n          uid_end.op_number = \"_#{uid_end.op_number}_RM_#{@name}_end\"\n          beg = HB.addOperation(new types.Delimiter uid_beg, undefined, uid_end).execute()\n          end = HB.addOperation(new types.Delimiter uid_end, beg, undefined).execute()\n          #beg.execute()\n          @map_manager.map[@name] = HB.addOperation(new ReplaceManager undefined, uid_r, beg, end).execute()\n        super\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      {\n        'type' : \"AddName\"\n        'uid' : @getUid()\n        'map_manager' : @map_manager.getUid()\n        'name' : @name\n      }\n\n  parser['AddName'] = (json)->\n    {\n      'map_manager' : map_manager\n      'uid' : uid\n      'name' : name\n    } = json\n    new AddName uid, map_manager, name\n\n  #\n  # Manages a list of Insert-type operations.\n  #\n  class ListManager extends types.Insert\n\n    #\n    # A ListManager maintains a non-empty list that has a beginning and an end (both Delimiters!)\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Delimiter} beginning Reference or Object.\n    # @param {Delimiter} end Reference or Object.\n    constructor: (uid, beginning, end, prev, next, origin)->\n      if beginning? and end?\n        @saveOperation 'beginning', beginning\n        @saveOperation 'end', end\n      else\n        @beginning = HB.addOperation new types.Delimiter undefined, undefined, undefined\n        @end =       HB.addOperation new types.Delimiter undefined, @beginning, undefined\n        @beginning.next_cl = @end\n        @beginning.execute()\n        @end.execute()\n      super uid, prev, next, origin\n\n    execute: ()->\n      if @validateSavedOperations()\n        @beginning.setParent @\n        @end.setParent @\n        super\n      else\n        false\n\n    # Get the element previous to the delemiter at the end\n    getLastOperation: ()->\n      @end.prev_cl\n\n    # similar to the above\n    getFirstOperation: ()->\n      @beginning.next_cl\n\n    # Transforms the the list to an array\n    # Doesn't return left-right delimiter.\n    toArray: ()->\n      o = @beginning.next_cl\n      result = []\n      while o isnt @end\n        result.push o\n        o = o.next_cl\n      result\n\n    #\n    # Retrieves the x-th not deleted element.\n    #\n    getOperationByPosition: (position)->\n      o = @beginning.next_cl\n      if (position > 0 or o.isDeleted()) and not (o instanceof types.Delimiter)\n        while o.isDeleted() and not (o instanceof types.Delimiter)\n          # find first non deleted op\n          o = o.next_cl\n        while true\n          # find the i-th op\n          if o instanceof types.Delimiter\n            break\n          if position <= 0 and not o.isDeleted()\n            break\n          o = o.next_cl\n          if not o.isDeleted()\n            position -= 1\n\n\n      o\n\n  #\n  # Adds support for replace. The ReplaceManager manages Replaceable operations.\n  # Each Replaceable holds a value that is now replaceable.\n  #\n  # The Word-type has implemented support for replace\n  # @see Word\n  #\n  class ReplaceManager extends ListManager\n    #\n    # @param {Operation} initial_content Initialize this with a Replaceable that holds the initial_content.\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    # @param {Delimiter} beginning Reference or Object.\n    # @param {Delimiter} end Reference or Object.\n    constructor: (initial_content, uid, beginning, end, prev, next, origin)->\n      super uid, beginning, end, prev, next, origin\n      if initial_content?\n        @replace initial_content\n\n    #\n    # Replace the existing word with a new word.\n    #\n    replace: (content)->\n      o = @getLastOperation()\n      op = new Replaceable content, @, undefined, o, o.next_cl\n      HB.addOperation(op).execute()\n\n    #\n    # Get the value of this Word\n    # @return {String}\n    #\n    val: ()->\n      o = @getLastOperation()\n      if o instanceof types.Delimiter\n        throw new Error \"dtrn\"\n      o.val()\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json =\n        {\n          'type': \"ReplaceManager\"\n          'uid' : @getUid()\n          'beginning' : @beginning.getUid()\n          'end' : @end.getUid()\n        }\n      if @prev_cl? and @next_cl?\n        json['prev'] = @prev_cl.getUid()\n        json['next'] = @next_cl.getUid()\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser[\"ReplaceManager\"] = (json)->\n    {\n      'content' : content\n      'uid' : uid\n      'prev': prev\n      'next': next\n      'origin' : origin\n      'beginning' : beginning\n      'end' : end\n    } = json\n    new ReplaceManager content, uid, beginning, end, prev, next, origin\n\n\n  #\n  # The ReplaceManager manages Replaceables.\n  # @see ReplaceManager\n  #\n  class Replaceable extends types.Insert\n\n    #\n    # @param {Operation} content The value that this Replaceable holds.\n    # @param {ReplaceManager} parent Used to replace this Replaceable with another one.\n    # @param {Object} uid A unique identifier. If uid is undefined, a new uid will be created.\n    #\n    constructor: (content, parent, uid, prev, next, origin)->\n      @saveOperation 'content', content\n      @saveOperation 'parent', parent\n      if not (prev? and next? and content?)\n        throw new Error \"You must define content, prev, and next for Replaceable-types!\"\n      super uid, prev, next, origin\n\n    #\n    # Return the content that this operation holds.\n    #\n    val: ()->\n      @content\n\n    #\n    # Replace the content of this replaceable with new content.\n    #\n    replace: (content)->\n      @parent.replace content\n\n    #\n    # If possible set the replace manager in the content.\n    # @see Word.setReplaceManager\n    #\n    execute: ()->\n      if not @validateSavedOperations()\n        return false\n      else\n        @content.setReplaceManager?(@parent)\n        super\n\n    #\n    # Encode this operation in such a way that it can be parsed by remote peers.\n    #\n    _encode: ()->\n      json =\n        {\n          'type': \"Replaceable\"\n          'content': @content.getUid()\n          'ReplaceManager' : @parent.getUid()\n          'prev': @prev_cl.getUid()\n          'next': @next_cl.getUid()\n          'uid' : @getUid()\n        }\n      if @origin? and @origin isnt @prev_cl\n        json[\"origin\"] = @origin.getUid()\n      json\n\n  parser[\"Replaceable\"] = (json)->\n    {\n      'content' : content\n      'ReplaceManager' : parent\n      'uid' : uid\n      'prev': prev\n      'next': next\n      'origin' : origin\n    } = json\n    new Replaceable content, parent, uid, prev, next, origin\n\n\n\n  types['ListManager'] = ListManager\n  types['MapManager'] = MapManager\n  types['ReplaceManager'] = ReplaceManager\n  types['Replaceable'] = Replaceable\n\n  basic_types\n\n\n\n\n\n\n"],"sourceRoot":"/source/"}