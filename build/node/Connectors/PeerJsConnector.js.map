{"version":3,"file":"Connectors/PeerJsConnector.js","sources":["Connectors/PeerJsConnector.coffee"],"names":[],"mappings":"CAUA,WAAA,GAAA,EAAA,GAAwB,WACtB,GAAA,GAAA,EAAA,QAAA,GAAO,KACgB,IAApB,UAAU,QACX,EAAW,GAAA,MAAK,UAAU,IAC1B,EAAW,UAAU,KAErB,EAAW,GAAA,MAAK,UAAU,GAAI,UAAU,IACxC,EAAW,UAAU,IAMjB,EAAA,WAQS,QAAA,GAAE,EAAS,EAAK,EAAqB,GAEhD,GAAA,EAFY,MAAC,OAAA,EAAQ,KAAC,GAAA,EAAI,KAAC,mBAAA,EAAoB,KAAC,MAAA,EAEhD,KAAC,KAAO,EACR,KAAC,eAED,KAAC,KAAK,GAAG,aAAc,SAAA,SAAA,UAAC,SACtB,GAAC,cAAc,KADM,OAGvB,EAAQ,SAAA,SAAA,UAAC,SACP,GAAC,KAAK,KADA,MAER,KAAC,mBAAmB,KAAK,SAV3B,GAAA,UAYA,cAAe,SAAC,GACd,MAAO,OAAA,KAAA,YAAA,IAAsB,IAAQ,KAAC,MAAM,YAC1C,KAAC,cAAc,EAAK,QAAQ,IAD9B,QAbF,EAAA,UAgBA,oBAAqB,WACnB,GAAA,GAAA,CAAA,UAAA,IAAA,MAAA,YACE,EAAA,KAAA,aAlBJ,EAAA,UA2BA,cAAe,SAAC,GACd,GAAA,GAAA,EAAA,QAAA,MAAC,YAAY,EAAK,MAAQ,EAC1B,GAAiB,EACjB,GAAkB,EAClB,EAAK,GAAG,OAAQ,SAAA,SAAA,UAAC,GACf,GAAA,GAAA,EAAA,EAAA,EAAA,CAAA,IAAW,kBAAR,OAEE,CAAA,GAAG,MAAA,EAAA,SACN,IAAiB,EACjB,EAAC,OAAO,oBAAoB,EAAK,IACjC,EAAK,MACH,MAAO,EAAC,uBACP,IAAG,MAAA,EAAA,SACN,GAAC,OAAO,QAAQ,EAAK,GAClB,IAAG,MAAA,EAAA,MAAH,KACH,EAAA,EAAA,MAAA,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACE,EAAA,KAAA,EAAC,cAAc,aACd,GAAG,MAAA,EAAA,aAON,KAAU,IAAA,OAAM,6BANhB,KAAG,QAED,GAAK,MACH,GAAI,EAAC,MAAM,mBAAmB,QAAQ,EAAK,gBAC7C,GAAkB,KAlBR,QAsBhB,EAAkB,SAAA,SAAA,YAGhB,MAFA,GAAK,MACH,aAAc,EAAC,GAAG,wBACjB,EAAH,OAGE,WAAW,EAAiB,OANd,UArDpB,EAAA,UAkEA,KAAM,SAAC,GACL,GAAA,GAAA,EAAA,EAAA,CAAA,IAAG,EAAE,IAAI,UAAW,KAAC,GAAG,aAA6C,gBAA5B,GAAS,IAAI,UAAtD,CACE,EAAA,KAAA,YAAA,SAAA,IAAA,UACE,EAAA,KAAA,EAAK,MACH,GAAI,gBAtEZ,EAAA,UA4EA,QAAS,SAAC,GACR,MAAG,GAAE,IAAI,UAAa,KAAC,GAAG,YACxB,KAAC,OAAO,QAAQ,GADlB,aAGJ,EAAK,GAAG,OAAQ,SAAC,SACf,GAAS,EAAiB,MAG9B,OAAO,QAAU,EACd,mBAAA,SAAA,OAAA,SACM,MAAA,OAAA,IACL,OAAO,MACT,OAAO,EAAE,sBAAwB","sourcesContent":["\n#\n# @overload createPeerJsConnector peerjs_options, callback\n#   @param {Object} peerjs_options Is the options object that is passed to PeerJs.\n#   @param {Function} callback The callback is called when the connector is initialized.\n# @overload createPeerJsConnector peerjs_user_id, peerjs_options, callback\n#   @param {String} peerjs_user_id The user_id that is passed to PeerJs as the user_id and should be unique between all (also the unconnected) Peers.\n#   @param {Object} peerjs_options Is the options object that is passed to PeerJs.\n#   @param {Function} callback The callback is called when the connector is initialized.\n#\ncreatePeerJsConnector = ()->\n  peer = null\n  if arguments.length is 2\n    peer = new Peer arguments[0]\n    callback = arguments[1]\n  else\n    peer = new Peer arguments[0], arguments[1]\n    callback = arguments[2]\n\n\n  #\n  # @see http://peerjs.com\n  #\n  class PeerJsConnector\n\n    #\n    # @param {Engine} engine The transformation engine\n    # @param {HistoryBuffer} HB\n    # @param {Array<Function>} execution_listener You must ensure that whenever an operation is executed, every function in this Array is called.\n    # @param {Yatta} yatta The Yatta framework.\n    #\n    constructor: (@engine, @HB, @execution_listener, @yatta)->\n\n      @peer = peer\n      @connections = {}\n\n      @peer.on 'connection', (conn)=>\n        @addConnection conn\n\n      send_ = (o)=>\n        @send o\n      @execution_listener.push send_\n\n    connectToPeer: (id)->\n      if not @connections[id]? and id isnt @yatta.getUserId()\n        @addConnection peer.connect id\n\n    getAllConnectionIds: ()->\n      for conn_id of @connections\n        conn_id\n\n    #\n    # What this method does:\n    # * Send state vector\n    # * Receive HB -> apply them\n    # * Send connections\n    # * Receive Connections -> Connect to unknow connections\n    #\n    addConnection: (conn)->\n      @connections[conn.peer] = conn\n      initialized_me = false\n      initialized_him = false\n      conn.on 'data', (data)=>\n        if data is \"empty_message\"\n          # nop\n        else if data.HB?\n          initialized_me = true\n          @engine.applyOpsCheckDouble data.HB\n          conn.send\n            conns: @getAllConnectionIds()\n        else if data.op?\n          @engine.applyOp data.op\n        else if data.conns?\n          for conn_id in data.conns\n            @connectToPeer conn_id\n        else if data.state_vector?\n          if not initialized_him\n            # make sure, that it is sent only once\n            conn.send\n              HB: @yatta.getHistoryBuffer()._encode(data.state_vector)\n            initialized_him = true\n        else\n          throw new Error \"Can't parse this operation\"\n\n      sendStateVector = ()=>\n        conn.send\n          state_vector: @HB.getOperationCounter()\n        if not initialized_me\n          # Because of a bug in PeerJs,\n          # we never know if state vector was actually sent\n          setTimeout sendStateVector, 100\n      sendStateVector()\n\n    #\n    # This function is called whenever an operation was executed.\n    # @param {Operation} o The operation that was executed.\n    #\n    send: (o)->\n      if o.uid.creator is @HB.getUserId() and (typeof o.uid.op_number isnt \"string\")\n        for conn_id,conn of @connections\n          conn.send\n            op: o\n\n    #\n    # This function is called whenever an operation was received from another peer.\n    # @param {Operation} o The operation that was received.\n    #\n    receive: (o)->\n      if o.uid.creator isnt @HB.getUserId()\n        @engine.applyOp o\n\n  peer.on 'open', (id)->\n    callback PeerJsConnector, id\n\n\nmodule.exports = createPeerJsConnector\nif window?\n  if not window.Y?\n    window.Y = {}\n  window.Y.createPeerJsConnector = createPeerJsConnector\n\n"],"sourceRoot":"/source/"}