{"version":3,"file":"Connectors/PeerJsConnector.js","sources":["Connectors/PeerJsConnector.coffee"],"names":[],"mappings":"CAIA,WAAA,GAAA,EAAA,GAAwB,SAAC,GAEvB,GAAA,GAAA,QAAA,GAAW,GAAA,OAAM,IAAK,oBAKhB,EAAA,WAQS,QAAA,GAAE,EAAS,EAAK,EAAqB,GAEhD,GAAA,EAFY,MAAC,OAAA,EAAQ,KAAC,GAAA,EAAI,KAAC,mBAAA,EAAoB,KAAC,MAAA,EAEhD,KAAC,KAAO,EACR,KAAC,eAED,KAAC,KAAK,GAAG,aAAc,SAAA,SAAA,UAAC,SACtB,GAAK,KAAK,OACV,EAAC,cAAc,KAFM,OAOvB,EAAQ,SAAA,SAAA,UAAC,SACP,GAAC,KAAK,KADA,MAER,KAAC,mBAAmB,KAAK,SAd3B,GAAA,UAgBA,cAAe,SAAC,SACd,MAAC,cAAc,EAAK,QAAQ,KAjB9B,EAAA,UAmBA,cAAe,SAAC,GACd,GAAA,SAAA,MAAC,YAAY,KAAK,GAElB,EAAK,GAAG,OAAQ,SAAA,SAAA,UAAC,GACf,GAAW,QAAR,EACE,CAAA,GAAG,MAAA,EAAA,SACN,GAAC,OAAO,oBAAoB,EAAK,GAC9B,IAAG,MAAA,EAAA,SACN,GAAC,OAAO,QAAQ,EAAK,GAErB,MAAU,IAAA,OAAM,iCAPJ,OAShB,EAAS,SAAA,SAAA,kBACP,GAAK,MACH,GAAI,EAAC,MAAM,mBAAmB,cAFzB,MAGT,WAAW,EAAQ,MAlCrB,EAAA,UAwCA,KAAM,SAAC,GACL,GAAA,GAAA,EAAA,EAAA,EAAA,CAAA,IAAG,EAAE,IAAI,UAAW,KAAC,GAAG,aAA6C,gBAA5B,GAAS,IAAI,UAAtD,KACE,EAAA,KAAA,YAAA,KAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,WACE,EAAA,KAAA,EAAK,MACH,GAAI,gBA5CZ,EAAA,UAkDA,QAAS,SAAC,GACR,MAAG,GAAE,IAAI,UAAa,KAAC,GAAG,YACxB,KAAC,OAAO,QAAQ,GADlB,aAGJ,EAAK,GAAG,OAAQ,SAAC,SACf,GAAS,EAAiB,MAG9B,OAAO,QAAU,8CACjB,OAAQ,sBAAwB","sourcesContent":["\n#\n# @param {Function} callback The callback is called when the connector is initialized.\n#\ncreatePeerJsConnector = (callback)->\n\n  peer = new Peer {key: 'h7nlefbgavh1tt9'}\n\n  #\n  # @see http://peerjs.com\n  #\n  class PeerJsConnector\n\n    #\n    # @param {Engine} engine The transformation engine\n    # @param {HistoryBuffer} HB\n    # @param {Array<Function>} execution_listener You must ensure that whenever an operation is executed, every function in this Array is called.\n    # @param {Yatta} yatta The Yatta framework.\n    #\n    constructor: (@engine, @HB, @execution_listener, @yatta)->\n\n      @peer = peer\n      @connections = []\n\n      @peer.on 'connection', (conn)=>\n        conn.send \"hey\"\n        @addConnection conn\n\n\n\n\n      send_ = (o)=>\n        @send o\n      @execution_listener.push send_\n\n    connectToPeer: (id)->\n      @addConnection peer.connect id\n\n    addConnection: (conn)->\n      @connections.push conn\n\n      conn.on 'data', (data)=>\n        if data is \"hey\"\n        else if data.HB?\n          @engine.applyOpsCheckDouble data.HB\n        else if data.op?\n          @engine.applyOp data.op\n        else\n          throw new Error \"Can't parse this operation\"\n\n      sendHB = ()=>\n        conn.send\n          HB: @yatta.getHistoryBuffer()._encode()\n      setTimeout sendHB, 1000\n\n    #\n    # This function is called whenever an operation was executed.\n    # @param {Operation} o The operation that was executed.\n    #\n    send: (o)->\n      if o.uid.creator is @HB.getUserId() and (typeof o.uid.op_number isnt \"string\")\n        for conn in @connections\n          conn.send\n            op: o\n\n    #\n    # This function is called whenever an operation was received from another peer.\n    # @param {Operation} o The operation that was received.\n    #\n    receive: (o)->\n      if o.uid.creator isnt @HB.getUserId()\n        @engine.applyOp o\n\n  peer.on 'open', (id)->\n    callback PeerJsConnector, id\n\n\nmodule.exports = createPeerJsConnector\nwindow?.createPeerJsConnector = createPeerJsConnector\n\n"],"sourceRoot":"/source/"}