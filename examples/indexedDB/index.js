// Generated by CoffeeScript 1.9.2
(function() {
  var DBTransaction, Transaction;

  DBTransaction = (function() {
    function DBTransaction(t1) {
      this.t = t1;
    }

    DBTransaction.prototype.setOperation = function(op) {
      var that;
      that = this;
      return new Promise(function(resolve, reject) {
        var req;
        req = that.t.objectStore("HistoryBuffer").put(op);
        req.onsuccess = function(event) {
          return resolve(op);
        };
        return req.onerror = function(event) {
          return reject("Could not set Operation!");
        };
      });
    };

    DBTransaction.prototype.getOperation = function(uid) {
      var that;
      that = this;
      return new Promise(function(resolve, reject) {
        var req;
        req = that.t.objectStore("HistoryBuffer").get(uid);
        req.onsuccess = function(event) {
          return resolve(req.result);
        };
        return req.onerror = function(event) {
          return reject("Could not get Operation!");
        };
      });
    };

    DBTransaction.prototype.getOperations = function(state_map) {
      var flow, hb, ops, that;
      flow = Promise.resolve();
      ops = [];
      that = this;
      hb = that.t.objectStore("HistoryBuffer");
      return that.getStateVector().then(function(end_state_vector) {
        var end_state, results;
        results = [];
        for (end_state in end_state_vector) {
          results.push((function(end_state) {
            var ref, start_state;
            start_state = {
              user: end_state.name,
              state: (ref = state_map[end_state]) != null ? ref : 0
            };
            return flow = flow.then(function() {
              var defer, from, range, to;
              from = [start_state.user, start_state.number];
              to = [end_state.user, end_state.number];
              range = IDBKeyRange.bound(from, to);
              defer = Promise.defer();
              hb.openCursor(range).onsuccess = function() {
                var cursor;
                cursor = event.target.result;
                if (cursor != null) {
                  ops.push(cursor.value);
                  return cursor["continue"]();
                } else {
                  return defer.resolve(ops);
                }
              };
              return defer.promise;
            });
          })(end_state));
        }
        return results;
      });
    };

    DBTransaction.prototype.setState = function(state) {
      var that;
      that = this;
      return new Promise(function(resolve, reject) {
        var req;
        req = that.t.objectStore("StateVector").put(state);
        req.onsuccess = function(event) {
          return resolve(state);
        };
        return req.onerror = function(event) {
          return reject("Could not set state vector!");
        };
      });
    };

    DBTransaction.prototype.getState = function(user) {
      var defer, req;
      defer = Promise.defer();
      req = this.t.objectStore("StateVector").get(user);
      req.onsuccess = function(event) {
        return defer.resolve(req.result);
      };
      req.onerror = function(event) {
        return defer.reject("Could not get state vector!");
      };
      return defer.promise;
    };

    DBTransaction.prototype.getStateVector = function() {
      var defer, state_vector;
      defer = Promise.defer();
      state_vector = [];
      this.t.objectStore("StateVector").openCursor().onsuccess = function() {
        var cursor, state;
        cursor = event.target.result;
        if (cursor != null) {
          state = cursor.value;
          state_vector.push(state);
          return cursor["continue"]();
        } else {
          return defer.resolve(state_vector);
        }
      };
      return defer.promise;
    };

    return DBTransaction;

  })();

  Transaction = (function() {
    function Transaction(t1) {
      this.t = t1;
    }

    Transaction.prototype.updateOperation = function(op) {
      return this.t.setOperation(op);
    };

    Transaction.prototype.addOperation = function(op) {
      var that;
      that = this;
      return this.t.getState(op.uid[0]).then(function(state) {
        if (state == null) {
          state = {
            user: op.uid[0],
            number: 0
          };
        }
        if (op.uid[1] === state.number) {
          state.number++;
          return that.t.setState(state);
        } else {
          return Promise.reject("Unexpected Operation");
        }
      }).then(that.t.setOperation(op));
    };

    Transaction.prototype.getOperation = function(uid) {
      return this.t.getOperation(uid);
    };

    Transaction.prototype.getState = function(user) {
      return this.t.getState(user);
    };

    Transaction.prototype.getOperations = function(state_vector) {
      return this.t.getOperations(state_vector);
    };

    return Transaction;

  })();

  window.DB = (function() {
    function DB() {
      this.ready = (new Promise(function(resolve, reject) {
        var req;
        req = indexedDB.open("Testy", 7);
        req.onerror = function() {
          return reject("Couldn't open the IndexedDB database!");
        };
        req.onsuccess = function(event) {
          return resolve(event.target.result);
        };
        return req.onupgradeneeded = function(event) {
          var db, objectStore;
          db = event.target.result;
          objectStore = db.createObjectStore("HistoryBuffer", {
            keyPath: "uid"
          });
          return objectStore = db.createObjectStore("StateVector", {
            keyPath: "user"
          });
        };
      }))["catch"](function(message) {
        throw new Error(message);
      });
    }

    DB.prototype.requestTransaction = function() {
      return this.ready.then(function(db) {
        return new Promise(function(resolve, reject) {
          return resolve(new Transaction(new DBTransaction(db.transaction(["HistoryBuffer", "StateVector"], "readwrite"))));
        });
      });
    };

    DB.prototype.removeDatabase = function() {
      var req;
      req = indexedDB.deleteDatabase("Testy");
      req.onsuccess = function() {
        return console.log("Deleted database successfully");
      };
      req.onblocked = function() {
        console.log("Database is currently being blocked");
        return console.dir(arguments);
      };
      req.onerror = function() {
        console.log("Couldn't delete database");
        return console.dir(arguments);
      };
      return null;
    };

    return DB;

  })();

  window.db = new DB();

  window.addDummyDataSet = function() {
    return db.requestTransaction().then(function(t) {
      return t.getState("dmonad").then(function(state) {
        if (state == null) {
          state = {
            number: 0
          };
        }
        return t.addOperation({
          uid: ["dmonad", state.number]
        });
      });
    });
  };

  window.getOp = function(num) {
    if (num == null) {
      num = 3;
    }
    return db.requestTransaction().then(function(t) {
      return t.getOperation(["dmonad", num]).then(function(op) {
        console.log("yay:");
        return console.log(op);
      });
    });
  };

  window.getOps = function(state_map) {
    if (state_map == null) {
      state_map = {
        dmonad: 5
      };
    }
    return db.requestTransaction().then(function(t) {
      return t.getOperations(state_map).then(function(op) {
        console.log("yay:");
        return console.log(op);
      });
    });
  };

}).call(this);
