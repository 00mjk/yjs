{"version":3,"file":"y.js","sources":["src/MessageHandler/integrateRemoteStructs.js","src/MessageHandler/stateSet.js","src/MessageHandler/deleteSet.js","src/MessageHandler/syncStep1.js","src/MessageHandler/syncStep2.js","src/MessageHandler/messageToString.js","src/Struct/Delete.js","src/Transaction.js","src/Struct/Item.js","src/Struct/Type.js","src/Type/y-xml/utils.js","src/Util/relativePosition.js","src/Type/y-xml/selection.js","node_modules/fast-diff/diff.js","src/Type/y-xml/YXmlFragment.js","src/Util/structReferences.js","src/Util/generateUserID.js","src/Util/UndoManager.js","node_modules/ms/index.js","src/Persistence.js","src/Util/Tree.js","src/Util/ID.js","src/Store/DeleteStore.js","node_modules/string.fromcodepoint/fromcodepoint.js","node_modules/string.prototype.codepointat/codepointat.js","node_modules/utf-8/src/UTF8.js","src/Binary/Decoder.js","src/Binary/Encoder.js","src/Util/EventHandler.js","src/Struct/ItemJSON.js","src/Struct/ItemString.js","src/Util/YEvent.js","src/Type/YArray.js","src/Type/YMap.js","src/Type/YText.js","src/Type/y-xml/YXmlText.js","src/Type/y-xml/YXmlEvent.js","src/Type/y-xml/YXmlElement.js","src/Util/RootID.js","src/Store/OperationStore.js","src/Store/StateStore.js","src/Util/NamedEventHandler.js","node_modules/debug/src/debug.js","node_modules/debug/src/browser.js","src/Connector.js","src/Type/y-xml/y-xml.js","src/Y.js"],"sourcesContent":["import { getStruct } from '../Util/structReferences.js'\nimport BinaryDecoder from '../Binary/Decoder.js'\nimport { logID } from './messageToString.js'\n\nclass MissingEntry {\n  constructor (decoder, missing, struct) {\n    this.decoder = decoder\n    this.missing = missing.length\n    this.struct = struct\n  }\n}\n\n/**\n * Integrate remote struct\n * When a remote struct is integrated, other structs might be ready to ready to\n * integrate.\n */\nfunction _integrateRemoteStructHelper (y, struct) {\n  const id = struct._id\n  if (id === undefined) {\n    struct._integrate(y)\n  } else {\n    if (y.ss.getState(id.user) > id.clock) {\n      return\n    }\n    struct._integrate(y)\n    let msu = y._missingStructs.get(id.user)\n    if (msu != null) {\n      let clock = id.clock\n      const finalClock = clock + struct._length\n      for (;clock < finalClock; clock++) {\n        const missingStructs = msu.get(clock)\n        if (missingStructs !== undefined) {\n          missingStructs.forEach(missingDef => {\n            missingDef.missing--\n            if (missingDef.missing === 0) {\n              const decoder = missingDef.decoder\n              let oldPos = decoder.pos\n              let missing = missingDef.struct._fromBinary(y, decoder)\n              decoder.pos = oldPos\n              if (missing.length === 0) {\n                y._readyToIntegrate.push(missingDef.struct)\n              }\n            }\n          })\n          msu.delete(clock)\n        }\n      }\n    }\n  }\n}\n\nexport function stringifyStructs (y, decoder, strBuilder) {\n  const len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let reference = decoder.readVarUint()\n    let Constr = getStruct(reference)\n    let struct = new Constr()\n    let missing = struct._fromBinary(y, decoder)\n    let logMessage = '  ' + struct._logString()\n    if (missing.length > 0) {\n      logMessage += ' .. missing: ' + missing.map(logID).join(', ')\n    }\n    strBuilder.push(logMessage)\n  }\n}\n\nexport function integrateRemoteStructs (decoder, encoder, y) {\n  const len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let reference = decoder.readVarUint()\n    let Constr = getStruct(reference)\n    let struct = new Constr()\n    let decoderPos = decoder.pos\n    let missing = struct._fromBinary(y, decoder)\n    if (missing.length === 0) {\n      while (struct != null) {\n        _integrateRemoteStructHelper(y, struct)\n        struct = y._readyToIntegrate.shift()\n      }\n    } else {\n      let _decoder = new BinaryDecoder(decoder.uint8arr)\n      _decoder.pos = decoderPos\n      let missingEntry = new MissingEntry(_decoder, missing, struct)\n      let missingStructs = y._missingStructs\n      for (let i = missing.length - 1; i >= 0; i--) {\n        let m = missing[i]\n        if (!missingStructs.has(m.user)) {\n          missingStructs.set(m.user, new Map())\n        }\n        let msu = missingStructs.get(m.user)\n        if (!msu.has(m.clock)) {\n          msu.set(m.clock, [])\n        }\n        let mArray = msu = msu.get(m.clock)\n        mArray.push(missingEntry)\n      }\n    }\n  }\n}\n","\nexport function readStateSet (decoder) {\n  let ss = new Map()\n  let ssLength = decoder.readUint32()\n  for (let i = 0; i < ssLength; i++) {\n    let user = decoder.readVarUint()\n    let clock = decoder.readVarUint()\n    ss.set(user, clock)\n  }\n  return ss\n}\n\nexport function writeStateSet (y, encoder) {\n  let lenPosition = encoder.pos\n  let len = 0\n  encoder.writeUint32(0)\n  for (let [user, clock] of y.ss.state) {\n    encoder.writeVarUint(user)\n    encoder.writeVarUint(clock)\n    len++\n  }\n  encoder.setUint32(lenPosition, len)\n}\n","import { deleteItemRange } from '../Struct/Delete.js'\nimport ID from '../Util/ID.js'\n\nexport function stringifyDeleteSet (y, decoder, strBuilder) {\n  let dsLength = decoder.readUint32()\n  for (let i = 0; i < dsLength; i++) {\n    let user = decoder.readVarUint()\n    strBuilder.push(' -' + user + ':')\n    let dvLength = decoder.readVarUint()\n    for (let j = 0; j < dvLength; j++) {\n      let from = decoder.readVarUint()\n      let len = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      strBuilder.push(`clock: ${from}, length: ${len}, gc: ${gc}`)\n    }\n  }\n  return strBuilder\n}\n\nexport function writeDeleteSet (y, encoder) {\n  let currentUser = null\n  let currentLength\n  let lastLenPos\n\n  let numberOfUsers = 0\n  let laterDSLenPus = encoder.pos\n  encoder.writeUint32(0)\n\n  y.ds.iterate(null, null, function (n) {\n    var user = n._id.user\n    var clock = n._id.clock\n    var len = n.len\n    var gc = n.gc\n    if (currentUser !== user) {\n      numberOfUsers++\n      // a new user was found\n      if (currentUser !== null) { // happens on first iteration\n        encoder.setUint32(lastLenPos, currentLength)\n      }\n      currentUser = user\n      encoder.writeVarUint(user)\n      // pseudo-fill pos\n      lastLenPos = encoder.pos\n      encoder.writeUint32(0)\n      currentLength = 0\n    }\n    encoder.writeVarUint(clock)\n    encoder.writeVarUint(len)\n    encoder.writeUint8(gc ? 1 : 0)\n    currentLength++\n  })\n  if (currentUser !== null) { // happens on first iteration\n    encoder.setUint32(lastLenPos, currentLength)\n  }\n  encoder.setUint32(laterDSLenPus, numberOfUsers)\n}\n\nexport function readDeleteSet (y, decoder) {\n  let dsLength = decoder.readUint32()\n  for (let i = 0; i < dsLength; i++) {\n    let user = decoder.readVarUint()\n    let dv = []\n    let dvLength = decoder.readUint32()\n    for (let j = 0; j < dvLength; j++) {\n      let from = decoder.readVarUint()\n      let len = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      dv.push([from, len, gc])\n    }\n    if (dvLength > 0) {\n      let pos = 0\n      let d = dv[pos]\n      let deletions = []\n      y.ds.iterate(new ID(user, 0), new ID(user, Number.MAX_VALUE), function (n) {\n        // cases:\n        // 1. d deletes something to the right of n\n        //  => go to next n (break)\n        // 2. d deletes something to the left of n\n        //  => create deletions\n        //  => reset d accordingly\n        //  *)=> if d doesn't delete anything anymore, go to next d (continue)\n        // 3. not 2) and d deletes something that also n deletes\n        //  => reset d so that it doesn't contain n's deletion\n        //  *)=> if d does not delete anything anymore, go to next d (continue)\n        while (d != null) {\n          var diff = 0 // describe the diff of length in 1) and 2)\n          if (n._id.clock + n.len <= d[0]) {\n            // 1)\n            break\n          } else if (d[0] < n._id.clock) {\n            // 2)\n            // delete maximum the len of d\n            // else delete as much as possible\n            diff = Math.min(n._id.clock - d[0], d[1])\n            // deleteItemRange(y, user, d[0], diff)\n            deletions.push([user, d[0], diff])\n          } else {\n            // 3)\n            diff = n._id.clock + n.len - d[0] // never null (see 1)\n            if (d[2] && !n.gc) {\n              // d marks as gc'd but n does not\n              // then delete either way\n              // deleteItemRange(y, user, d[0], Math.min(diff, d[1]))\n              deletions.push([user, d[0], Math.min(diff, d[1])])\n            }\n          }\n          if (d[1] <= diff) {\n            // d doesn't delete anything anymore\n            d = dv[++pos]\n          } else {\n            d[0] = d[0] + diff // reset pos\n            d[1] = d[1] - diff // reset length\n          }\n        }\n      })\n      // TODO: It would be more performant to apply the deletes in the above loop\n      // Adapt the Tree implementation to support delete while iterating\n      for (let i = deletions.length - 1; i >= 0; i--) {\n        const del = deletions[i]\n        deleteItemRange(y, del[0], del[1], del[2])\n      }\n      // for the rest.. just apply it\n      for (; pos < dv.length; pos++) {\n        d = dv[pos]\n        deleteItemRange(y, user, d[0], d[1])\n        // deletions.push([user, d[0], d[1], d[2]])\n      }\n    }\n  }\n}\n","import BinaryEncoder from '../Binary/Encoder.js'\nimport { readStateSet, writeStateSet } from './stateSet.js'\nimport { writeDeleteSet } from './deleteSet.js'\nimport ID from '../Util/ID.js'\nimport { RootFakeUserID } from '../Util/RootID.js'\n\nexport function stringifySyncStep1 (y, decoder, strBuilder) {\n  let auth = decoder.readVarString()\n  let protocolVersion = decoder.readVarUint()\n  strBuilder.push(`  - auth: \"${auth}\"`)\n  strBuilder.push(`  - protocolVersion: ${protocolVersion}`)\n  // write SS\n  let ssBuilder = []\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let user = decoder.readVarUint()\n    let clock = decoder.readVarUint()\n    ssBuilder.push(`(${user}:${clock})`)\n  }\n  strBuilder.push('  == SS: ' + ssBuilder.join(','))\n}\n\nexport function sendSyncStep1 (connector, syncUser) {\n  let encoder = new BinaryEncoder()\n  encoder.writeVarString(connector.y.room)\n  encoder.writeVarString('sync step 1')\n  encoder.writeVarString(connector.authInfo || '')\n  encoder.writeVarUint(connector.protocolVersion)\n  writeStateSet(connector.y, encoder)\n  connector.send(syncUser, encoder.createBuffer())\n}\n\nexport default function writeStructs (encoder, decoder, y, ss) {\n  const lenPos = encoder.pos\n  encoder.writeUint32(0)\n  let len = 0\n  for (let user of y.ss.state.keys()) {\n    let clock = ss.get(user) || 0\n    if (user !== RootFakeUserID) {\n      y.os.iterate(new ID(user, clock), new ID(user, Number.MAX_VALUE), function (struct) {\n        struct._toBinary(encoder)\n        len++\n      })\n    }\n  }\n  encoder.setUint32(lenPos, len)\n}\n\nexport function readSyncStep1 (decoder, encoder, y, senderConn, sender) {\n  let protocolVersion = decoder.readVarUint()\n  // check protocol version\n  if (protocolVersion !== y.connector.protocolVersion) {\n    console.warn(\n      `You tried to sync with a Yjs instance that has a different protocol version\n      (You: ${protocolVersion}, Client: ${protocolVersion}).\n      `)\n    y.destroy()\n  }\n  // write sync step 2\n  encoder.writeVarString('sync step 2')\n  encoder.writeVarString(y.connector.authInfo || '')\n  const ss = readStateSet(decoder)\n  writeStructs(encoder, decoder, y, ss)\n  writeDeleteSet(y, encoder)\n  y.connector.send(senderConn.uid, encoder.createBuffer())\n  senderConn.receivedSyncStep2 = true\n  if (y.connector.role === 'slave') {\n    sendSyncStep1(y.connector, sender)\n  }\n}\n","import { stringifyStructs, integrateRemoteStructs } from './integrateRemoteStructs.js'\nimport { readDeleteSet } from './deleteSet.js'\n\nexport function stringifySyncStep2 (y, decoder, strBuilder) {\n  strBuilder.push('     - auth: ' + decoder.readVarString())\n  strBuilder.push('  == OS:')\n  stringifyStructs(y, decoder, strBuilder)\n  // write DS to string\n  strBuilder.push('  == DS:')\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let user = decoder.readVarUint()\n    strBuilder.push(`    User: ${user}: `)\n    let len2 = decoder.readUint32()\n    for (let j = 0; j < len2; j++) {\n      let from = decoder.readVarUint()\n      let to = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      strBuilder.push(`[${from}, ${to}, ${gc}]`)\n    }\n  }\n}\n\nexport function readSyncStep2 (decoder, encoder, y, senderConn, sender) {\n  integrateRemoteStructs(decoder, encoder, y)\n  readDeleteSet(y, decoder)\n  y.connector._setSyncedWith(sender)\n}\n","import BinaryDecoder from '../Binary/Decoder.js'\nimport { stringifyStructs } from './integrateRemoteStructs.js'\nimport { stringifySyncStep1 } from './syncStep1.js'\nimport { stringifySyncStep2 } from './syncStep2.js'\nimport ID from '../Util/ID.js'\nimport RootID from '../Util/RootID.js'\nimport Y from '../Y.js'\n\nexport function messageToString ([y, buffer]) {\n  let decoder = new BinaryDecoder(buffer)\n  decoder.readVarString() // read roomname\n  let type = decoder.readVarString()\n  let strBuilder = []\n  strBuilder.push('\\n === ' + type + ' ===')\n  if (type === 'update') {\n    stringifyStructs(y, decoder, strBuilder)\n  } else if (type === 'sync step 1') {\n    stringifySyncStep1(y, decoder, strBuilder)\n  } else if (type === 'sync step 2') {\n    stringifySyncStep2(y, decoder, strBuilder)\n  } else {\n    strBuilder.push('-- Unknown message type - probably an encoding issue!!!')\n  }\n  return strBuilder.join('\\n')\n}\n\nexport function messageToRoomname (buffer) {\n  let decoder = new BinaryDecoder(buffer)\n  decoder.readVarString() // roomname\n  return decoder.readVarString() // messageType\n}\n\nexport function logID (id) {\n  if (id !== null && id._id != null) {\n    id = id._id\n  }\n  if (id === null) {\n    return '()'\n  } else if (id instanceof ID) {\n    return `(${id.user},${id.clock})`\n  } else if (id instanceof RootID) {\n    return `(${id.name},${id.type})`\n  } else if (id.constructor === Y) {\n    return `y`\n  } else {\n    throw new Error('This is not a valid ID!')\n  }\n}\n","import { getReference } from '../Util/structReferences.js'\nimport ID from '../Util/ID.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\n/**\n * Delete all items in an ID-range\n * TODO: implement getItemCleanStartNode for better performance (only one lookup)\n */\nexport function deleteItemRange (y, user, clock, range) {\n  const createDelete = y.connector._forwardAppliedStructs\n  let item = y.os.getItemCleanStart(new ID(user, clock))\n  if (item !== null) {\n    if (!item._deleted) {\n      item._splitAt(y, range)\n      item._delete(y, createDelete)\n    }\n    let itemLen = item._length\n    range -= itemLen\n    clock += itemLen\n    if (range > 0) {\n      let node = y.os.findNode(new ID(user, clock))\n      while (node !== null && range > 0 && node.val._id.equals(new ID(user, clock))) {\n        const nodeVal = node.val\n        if (!nodeVal._deleted) {\n          nodeVal._splitAt(y, range)\n          nodeVal._delete(y, createDelete)\n        }\n        const nodeLen = nodeVal._length\n        range -= nodeLen\n        clock += nodeLen\n        node = node.next()\n      }\n    }\n  }\n}\n\n/**\n * Delete is not a real struct. It will not be saved in OS\n */\nexport default class Delete {\n  constructor () {\n    this._target = null\n    this._length = null\n  }\n  _fromBinary (y, decoder) {\n    // TODO: set target, and add it to missing if not found\n    // There is an edge case in p2p networks!\n    const targetID = decoder.readID()\n    this._targetID = targetID\n    this._length = decoder.readVarUint()\n    if (y.os.getItem(targetID) === null) {\n      return [targetID]\n    } else {\n      return []\n    }\n  }\n  _toBinary (encoder) {\n    encoder.writeUint8(getReference(this.constructor))\n    encoder.writeID(this._targetID)\n    encoder.writeVarUint(this._length)\n  }\n  /**\n   * - If created remotely (a remote user deleted something),\n   *   this Delete is applied to all structs in id-range.\n   * - If created lokally (e.g. when y-array deletes a range of elements),\n   *   this struct is broadcasted only (it is already executed)\n   */\n  _integrate (y, locallyCreated = false) {\n    if (!locallyCreated) {\n      // from remote\n      const id = this._targetID\n      deleteItemRange(y, id.user, id.clock, this._length)\n    } else {\n      // from local\n      y.connector.broadcastStruct(this)\n    }\n    if (y.persistence !== null) {\n      y.persistence.saveOperations(this)\n    }\n  }\n  _logString () {\n    return `Delete - target: ${logID(this._targetID)}, len: ${this._length}`\n  }\n}\n","\nexport default class Transaction {\n  constructor (y) {\n    this.y = y\n    // types added during transaction\n    this.newTypes = new Set()\n    // changed types (does not include new types)\n    // maps from type to parentSubs (item._parentSub = null for array elements)\n    this.changedTypes = new Map()\n    this.deletedStructs = new Set()\n    this.beforeState = new Map()\n    this.changedParentTypes = new Map()\n  }\n}\n\nexport function transactionTypeChanged (y, type, sub) {\n  if (type !== y && !type._deleted && !y._transaction.newTypes.has(type)) {\n    const changedTypes = y._transaction.changedTypes\n    let subs = changedTypes.get(type)\n    if (subs === undefined) {\n      // create if it doesn't exist yet\n      subs = new Set()\n      changedTypes.set(type, subs)\n    }\n    subs.add(sub)\n  }\n}\n","import { getReference } from '../Util/structReferences.js'\nimport ID from '../Util/ID.js'\nimport { RootFakeUserID } from '../Util/RootID.js'\nimport Delete from './Delete.js'\nimport { transactionTypeChanged } from '../Transaction.js'\n\n/**\n * Helper utility to split an Item (see _splitAt)\n * - copy all properties from a to b\n * - connect a to b\n * - assigns the correct _id\n * - save b to os\n */\nexport function splitHelper (y, a, b, diff) {\n  const aID = a._id\n  b._id = new ID(aID.user, aID.clock + diff)\n  b._origin = a\n  b._left = a\n  b._right = a._right\n  if (b._right !== null) {\n    b._right._left = b\n  }\n  b._right_origin = a._right_origin\n  // do not set a._right_origin, as this will lead to problems when syncing\n  a._right = b\n  b._parent = a._parent\n  b._parentSub = a._parentSub\n  b._deleted = a._deleted\n  // now search all relevant items to the right and update origin\n  // if origin is not it foundOrigins, we don't have to search any longer\n  let foundOrigins = new Set()\n  foundOrigins.add(a)\n  let o = b._right\n  while (o !== null && foundOrigins.has(o._origin)) {\n    if (o._origin === a) {\n      o._origin = b\n    }\n    foundOrigins.add(o)\n    o = o._right\n  }\n  y.os.put(b)\n}\n\nexport default class Item {\n  constructor () {\n    this._id = null\n    this._origin = null\n    this._left = null\n    this._right = null\n    this._right_origin = null\n    this._parent = null\n    this._parentSub = null\n    this._deleted = false\n  }\n  /**\n   * Copy the effect of struct\n   */\n  _copy () {\n    let struct = new this.constructor()\n    struct._origin = this._left\n    struct._left = this._left\n    struct._right = this\n    struct._right_origin = this\n    struct._parent = this._parent\n    struct._parentSub = this._parentSub\n    return struct\n  }\n  get _lastId () {\n    return new ID(this._id.user, this._id.clock + this._length - 1)\n  }\n  get _length () {\n    return 1\n  }\n  /**\n   * Splits this struct so that another struct can be inserted in-between.\n   * This must be overwritten if _length > 1\n   * Returns right part after split\n   * - diff === 0 => this\n   * - diff === length => this._right\n   * - otherwise => split _content and return right part of split\n   * (see ItemJSON/ItemString for implementation)\n   */\n  _splitAt (y, diff) {\n    if (diff === 0) {\n      return this\n    }\n    return this._right\n  }\n  _delete (y, createDelete = true) {\n    this._deleted = true\n    y.ds.markDeleted(this._id, this._length)\n    if (createDelete) {\n      let del = new Delete()\n      del._targetID = this._id\n      del._length = this._length\n      del._integrate(y, true)\n    }\n    transactionTypeChanged(y, this._parent, this._parentSub)\n    y._transaction.deletedStructs.add(this)\n  }\n  /**\n   * This is called right before this struct receives any children.\n   * It can be overwritten to apply pending changes before applying remote changes\n   */\n  _beforeChange () {\n    // nop\n  }\n  /*\n   * - Integrate the struct so that other types/structs can see it\n   * - Add this struct to y.os\n   * - Check if this is struct deleted\n   */\n  _integrate (y) {\n    const parent = this._parent\n    const selfID = this._id\n    const userState = selfID === null ? 0 : y.ss.getState(selfID.user)\n    if (selfID === null) {\n      this._id = y.ss.getNextID(this._length)\n    } else if (selfID.user === RootFakeUserID) {\n      // nop\n    } else if (selfID.clock < userState) {\n      // already applied..\n      return []\n    } else if (selfID.clock === userState) {\n      y.ss.setState(selfID.user, userState + this._length)\n    } else {\n      // missing content from user\n      throw new Error('Can not apply yet!')\n    }\n    if (!parent._deleted && !y._transaction.changedTypes.has(parent) && !y._transaction.newTypes.has(parent)) {\n      // this is the first time parent is updated\n      // or this types is new\n      this._parent._beforeChange()\n    }\n    /*\n    # $this has to find a unique position between origin and the next known character\n    # case 1: $origin equals $o.origin: the $creator parameter decides if left or right\n    #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4\n    #         o2,o3 and o4 origin is 1 (the position of o2)\n    #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator\n    #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex\n    #         therefore $this would be always to the right of o3\n    # case 2: $origin < $o.origin\n    #         if current $this insert_position > $o origin: $this ins\n    #         else $insert_position will not change\n    #         (maybe we encounter case 1 later, then this will be to the right of $o)\n    # case 3: $origin > $o.origin\n    #         $this insert_position is to the left of $o (forever!)\n    */\n    // handle conflicts\n    let o\n    // set o to the first conflicting item\n    if (this._left !== null) {\n      o = this._left._right\n    } else if (this._parentSub !== null) {\n      o = this._parent._map.get(this._parentSub) || null\n    } else {\n      o = this._parent._start\n    }\n    let conflictingItems = new Set()\n    let itemsBeforeOrigin = new Set()\n    // Let c in conflictingItems, b in itemsBeforeOrigin\n    // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n    // Note that conflictingItems is a subset of itemsBeforeOrigin\n    while (o !== null && o !== this._right) {\n      itemsBeforeOrigin.add(o)\n      conflictingItems.add(o)\n      if (this._origin === o._origin) {\n        // case 1\n        if (o._id.user < this._id.user) {\n          this._left = o\n          conflictingItems.clear()\n        }\n      } else if (itemsBeforeOrigin.has(o._origin)) {\n        // case 2\n        if (!conflictingItems.has(o._origin)) {\n          this._left = o\n          conflictingItems.clear()\n        }\n      } else {\n        break\n      }\n      // TODO: try to use right_origin instead.\n      // Then you could basically omit conflictingItems!\n      // Note: you probably can't use right_origin in every case.. only when setting _left\n      o = o._right\n    }\n    // reconnect left/right + update parent map/start if necessary\n    const parentSub = this._parentSub\n    if (this._left === null) {\n      let right\n      if (parentSub !== null) {\n        const pmap = parent._map\n        right = pmap.get(parentSub) || null\n        pmap.set(parentSub, this)\n      } else {\n        right = parent._start\n        parent._start = this\n      }\n      this._right = right\n      if (right !== null) {\n        right._left = this\n      }\n    } else {\n      const left = this._left\n      const right = left._right\n      this._right = right\n      left._right = this\n      if (right !== null) {\n        right._left = this\n      }\n    }\n    if (parent._deleted) {\n      this._delete(y, false)\n    }\n    y.os.put(this)\n    transactionTypeChanged(y, parent, parentSub)\n    if (this._id.user !== RootFakeUserID) {\n      if (y.connector._forwardAppliedStructs || this._id.user === y.userID) {\n        y.connector.broadcastStruct(this)\n      }\n      if (y.persistence !== null) {\n        y.persistence.saveOperations(this)\n      }\n    }\n  }\n  _toBinary (encoder) {\n    encoder.writeUint8(getReference(this.constructor))\n    let info = 0\n    if (this._origin !== null) {\n      info += 0b1 // origin is defined\n    }\n    // TODO: remove\n    /* no longer send _left\n    if (this._left !== this._origin) {\n      info += 0b10 // do not copy origin to left\n    }\n    */\n    if (this._right_origin !== null) {\n      info += 0b100\n    }\n    if (this._parentSub !== null) {\n      info += 0b1000\n    }\n    encoder.writeUint8(info)\n    encoder.writeID(this._id)\n    if (info & 0b1) {\n      encoder.writeID(this._origin._lastId)\n    }\n    // TODO: remove\n    /* see above\n    if (info & 0b10) {\n      encoder.writeID(this._left._lastId)\n    }\n    */\n    if (info & 0b100) {\n      encoder.writeID(this._right_origin._id)\n    }\n    if ((info & 0b101) === 0) {\n      // neither origin nor right is defined\n      encoder.writeID(this._parent._id)\n    }\n    if (info & 0b1000) {\n      encoder.writeVarString(JSON.stringify(this._parentSub))\n    }\n  }\n  _fromBinary (y, decoder) {\n    let missing = []\n    const info = decoder.readUint8()\n    const id = decoder.readID()\n    this._id = id\n    // read origin\n    if (info & 0b1) {\n      // origin != null\n      const originID = decoder.readID()\n      // we have to query for left again because it might have been split/merged..\n      const origin = y.os.getItemCleanEnd(originID)\n      if (origin === null) {\n        missing.push(originID)\n      } else {\n        this._origin = origin\n        this._left = this._origin\n      }\n    }\n    // read right\n    if (info & 0b100) {\n      // right != null\n      const rightID = decoder.readID()\n      // we have to query for right again because it might have been split/merged..\n      const right = y.os.getItemCleanStart(rightID)\n      if (right === null) {\n        missing.push(rightID)\n      } else {\n        this._right = right\n        this._right_origin = right\n      }\n    }\n    // read parent\n    if ((info & 0b101) === 0) {\n      // neither origin nor right is defined\n      const parentID = decoder.readID()\n      // parent does not change, so we don't have to search for it again\n      if (this._parent === null) {\n        const parent = y.os.get(parentID)\n        if (parent === null) {\n          missing.push(parentID)\n        } else {\n          this._parent = parent\n        }\n      }\n    } else if (this._parent === null) {\n      if (this._origin !== null) {\n        this._parent = this._origin._parent\n      } else if (this._right_origin !== null) {\n        this._parent = this._right_origin._parent\n      }\n    }\n    if (info & 0b1000) {\n      // TODO: maybe put this in read parent condition (you can also read parentsub from left/right)\n      this._parentSub = JSON.parse(decoder.readVarString())\n    }\n    if (y.ss.getState(id.user) < id.clock) {\n      missing.push(new ID(id.user, id.clock - 1))\n    }\n    return missing\n  }\n}\n","import Item from './Item.js'\nimport EventHandler from '../Util/EventHandler.js'\nimport ID from '../Util/ID.js'\n\n// restructure children as if they were inserted one after another\nfunction integrateChildren (y, start) {\n  let right\n  do {\n    right = start._right\n    start._right = null\n    start._right_origin = null\n    start._origin = start._left\n    start._integrate(y)\n    start = right\n  } while (right !== null)\n}\n\nexport function getListItemIDByPosition (type, i) {\n  let pos = 0\n  let n = type._start\n  while (n !== null) {\n    if (!n._deleted) {\n      if (pos <= i && i < pos + n._length) {\n        const id = n._id\n        return new ID(id.user, id.clock + i - pos)\n      }\n      pos++\n    }\n    n = n._right\n  }\n}\n\nexport default class Type extends Item {\n  constructor () {\n    super()\n    this._map = new Map()\n    this._start = null\n    this._y = null\n    this._eventHandler = new EventHandler()\n    this._deepEventHandler = new EventHandler()\n  }\n  getPathTo (type) {\n    if (type === this) {\n      return []\n    }\n    const path = []\n    const y = this._y\n    while (type._parent !== this && this._parent !== y) {\n      let parent = type._parent\n      if (type._parentSub !== null) {\n        path.push(type._parentSub)\n      } else {\n        // parent is array-ish\n        for (let [i, child] of parent) {\n          if (child === type) {\n            path.push(i)\n            break\n          }\n        }\n      }\n      type = parent\n    }\n    if (this._parent !== this) {\n      throw new Error('The type is not a child of this node')\n    }\n    return path\n  }\n  _callEventHandler (transaction, event) {\n    const changedParentTypes = transaction.changedParentTypes\n    this._eventHandler.callEventListeners(transaction, event)\n    let type = this\n    while (type !== this._y) {\n      let events = changedParentTypes.get(type)\n      if (events === undefined) {\n        events = []\n        changedParentTypes.set(type, events)\n      }\n      events.push(event)\n      type = type._parent\n    }\n  }\n  _copy (undeleteChildren) {\n    let copy = super._copy()\n    let map = new Map()\n    copy._map = map\n    for (let [key, value] of this._map) {\n      if (undeleteChildren.has(value) || !value.deleted) {\n        let _item = value._copy(undeleteChildren)\n        _item._parent = copy\n        map.set(key, value._copy(undeleteChildren))\n      }\n    }\n    let prevUndeleted = null\n    copy._start = null\n    let item = this._start\n    while (item !== null) {\n      if (undeleteChildren.has(item) || !item.deleted) {\n        let _item = item._copy(undeleteChildren)\n        _item._left = prevUndeleted\n        _item._origin = prevUndeleted\n        _item._right = null\n        _item._right_origin = null\n        _item._parent = copy\n        if (prevUndeleted === null) {\n          copy._start = _item\n        } else {\n          prevUndeleted._right = _item\n        }\n        prevUndeleted = _item\n      }\n      item = item._right\n    }\n    return copy\n  }\n  _transact (f) {\n    const y = this._y\n    if (y !== null) {\n      y.transact(f)\n    } else {\n      f(y)\n    }\n  }\n  observe (f) {\n    this._eventHandler.addEventListener(f)\n  }\n  observeDeep (f) {\n    this._deepEventHandler.addEventListener(f)\n  }\n  unobserve (f) {\n    this._eventHandler.removeEventListener(f)\n  }\n  unobserveDeep (f) {\n    this._deepEventHandler.removeEventListener(f)\n  }\n  _integrate (y) {\n    y._transaction.newTypes.add(this)\n    super._integrate(y)\n    this._y = y\n    // when integrating children we must make sure to\n    // integrate start\n    const start = this._start\n    if (start !== null) {\n      this._start = null\n      integrateChildren(y, start)\n    }\n    // integrate map children\n    const map = this._map\n    this._map = new Map()\n    for (let t of map.values()) {\n      // TODO make sure that right elements are deleted!\n      integrateChildren(y, t)\n    }\n  }\n  _delete (y, createDelete) {\n    super._delete(y, createDelete)\n    y._transaction.changedTypes.delete(this)\n    // delete map types\n    for (let value of this._map.values()) {\n      if (value instanceof Item && !value._deleted) {\n        value._delete(y, false)\n      }\n    }\n    // delete array types\n    let t = this._start\n    while (t !== null) {\n      if (!t._deleted) {\n        t._delete(y, false)\n      }\n      t = t._right\n    }\n  }\n}\n","import YXmlText from './YXmlText.js'\n\nexport function defaultDomFilter (node, attributes) {\n  return attributes\n}\n\nexport function getAnchorViewPosition (scrollElement) {\n  if (scrollElement == null) {\n    return null\n  }\n  let anchor = document.getSelection().anchorNode\n  if (anchor != null) {\n    let top = getBoundingClientRect(anchor).top\n    if (top >= 0 && top <= document.documentElement.clientHeight) {\n      return {\n        anchor: anchor,\n        top: top\n      }\n    }\n  }\n  return {\n    anchor: null,\n    scrollTop: scrollElement.scrollTop,\n    scrollHeight: scrollElement.scrollHeight\n  }\n}\n\n// get BoundingClientRect that works on text nodes\nexport function getBoundingClientRect (element) {\n  if (element.getBoundingClientRect != null) {\n    // is element node\n    return element.getBoundingClientRect()\n  } else {\n    // is text node\n    if (element.parentNode == null) {\n      // range requires that text nodes have a parent\n      let span = document.createElement('span')\n      span.appendChild(element)\n    }\n    let range = document.createRange()\n    range.selectNode(element)\n    return range.getBoundingClientRect()\n  }\n}\n\nexport function fixScrollPosition (scrollElement, fix) {\n  if (scrollElement !== null && fix !== null) {\n    if (fix.anchor === null) {\n      if (scrollElement.scrollTop === fix.scrollTop) {\n        scrollElement.scrollTop = scrollElement.scrollHeight - fix.scrollHeight\n      }\n    } else {\n      scrollElement.scrollTop = getBoundingClientRect(fix.anchor).top - fix.top\n    }\n  }\n}\n\nfunction iterateUntilUndeleted (item) {\n  while (item !== null && item._deleted) {\n    item = item._right\n  }\n  return item\n}\n\nfunction _insertNodeHelper (yxml, prevExpectedNode, child) {\n  let insertedNodes = yxml.insertDomElementsAfter(prevExpectedNode, [child])\n  if (insertedNodes.length > 0) {\n    return insertedNodes[0]\n  } else {\n    return prevExpectedNode\n  }\n}\n\n/*\n * 1. Check if any of the nodes was deleted\n * 2. Iterate over the children.\n *    2.1 If a node exists without _yxml property, insert a new node\n *    2.2 If _contents.length < dom.childNodes.length, fill the\n *        rest of _content with childNodes\n *    2.3 If a node was moved, delete it and\n *       recreate a new yxml element that is bound to that node.\n *       You can detect that a node was moved because expectedId\n *       !== actualId in the list\n */\nexport function applyChangesFromDom (dom) {\n  const yxml = dom._yxml\n  const y = yxml._y\n  let knownChildren =\n    new Set(\n      Array.prototype.map.call(dom.childNodes, child => child._yxml)\n      .filter(id => id !== undefined)\n    )\n  // 1. Check if any of the nodes was deleted\n  yxml.forEach(function (childType, i) {\n    if (!knownChildren.has(childType)) {\n      childType._delete(y)\n    }\n  })\n  // 2. iterate\n  let childNodes = dom.childNodes\n  let len = childNodes.length\n  let prevExpectedNode = null\n  let expectedNode = iterateUntilUndeleted(yxml._start)\n  for (let domCnt = 0; domCnt < len; domCnt++) {\n    const child = childNodes[domCnt]\n    const childYXml = child._yxml\n    if (childYXml != null) {\n      if (childYXml === false) {\n        // should be ignored or is going to be deleted\n        continue\n      }\n      if (expectedNode !== null) {\n        if (expectedNode !== childYXml) {\n          // 2.3 Not expected node\n          if (childYXml._parent !== this) {\n            // element is going to be deleted by its previous parent\n            child._yxml = null\n          } else {\n            childYXml._delete(y)\n          }\n          prevExpectedNode = _insertNodeHelper(yxml, prevExpectedNode, child)\n        } else {\n          prevExpectedNode = expectedNode\n          expectedNode = iterateUntilUndeleted(expectedNode._right)\n        }\n        // if this is the expected node id, just continue\n      } else {\n        // 2.2 fill _conten with child nodes\n        prevExpectedNode = _insertNodeHelper(yxml, prevExpectedNode, child)\n      }\n    } else {\n      // 2.1 A new node was found\n      prevExpectedNode = _insertNodeHelper(yxml, prevExpectedNode, child)\n    }\n  }\n}\n\nexport function reflectChangesOnDom (events, _document) {\n  // Make sure that no filtered attributes are applied to the structure\n  // if they were, delete them\n  /*\n  events.forEach(event => {\n    const target = event.target\n    if (event.attributesChanged === undefined) {\n      // event.target is Y.XmlText\n      return\n    }\n    const keys = this._domFilter(target.nodeName, Array.from(event.attributesChanged))\n    if (keys === null) {\n      target._delete()\n    } else {\n      const removeKeys = new Set() // is a copy of event.attributesChanged\n      event.attributesChanged.forEach(key => { removeKeys.add(key) })\n      keys.forEach(key => {\n        // remove all accepted keys from removeKeys\n        removeKeys.delete(key)\n      })\n      // remove the filtered attribute\n      removeKeys.forEach(key => {\n        target.removeAttribute(key)\n      })\n    }\n  })\n  */\n  this._mutualExclude(() => {\n    events.forEach(event => {\n      const yxml = event.target\n      const dom = yxml._dom\n      if (dom != null) {\n        // TODO: do this once before applying stuff\n        // let anchorViewPosition = getAnchorViewPosition(yxml._scrollElement)\n        if (yxml.constructor === YXmlText) {\n          yxml._dom.nodeValue = yxml.toString()\n        } else {\n          // update attributes\n          event.attributesChanged.forEach(attributeName => {\n            const value = yxml.getAttribute(attributeName)\n            if (value === undefined) {\n              dom.removeAttribute(attributeName)\n            } else {\n              dom.setAttribute(attributeName, value)\n            }\n          })\n          if (event.childListChanged) {\n            // create fragment of undeleted nodes\n            const fragment = _document.createDocumentFragment()\n            yxml.forEach(function (t) {\n              fragment.appendChild(t.getDom(_document))\n            })\n            // remove remainding nodes\n            let lastChild = dom.lastChild\n            while (lastChild !== null) {\n              dom.removeChild(lastChild)\n              lastChild = dom.lastChild\n            }\n            // insert fragment of undeleted nodes\n            dom.appendChild(fragment)\n          }\n        }\n        /* TODO: smartscrolling\n        .. else if (event.type === 'childInserted' || event.type === 'insert') {\n          let nodes = event.values\n          for (let i = nodes.length - 1; i >= 0; i--) {\n            let node = nodes[i]\n            node.setDomFilter(yxml._domFilter)\n            node.enableSmartScrolling(yxml._scrollElement)\n            let dom = node.getDom()\n            let fixPosition = null\n            let nextDom = null\n            if (yxml._content.length > event.index + i + 1) {\n              nextDom = yxml.get(event.index + i + 1).getDom()\n            }\n            yxml._dom.insertBefore(dom, nextDom)\n            if (anchorViewPosition === null) {\n              // nop\n            } else if (anchorViewPosition.anchor !== null) {\n              // no scrolling when current selection\n              if (!dom.contains(anchorViewPosition.anchor) && !anchorViewPosition.anchor.contains(dom)) {\n                fixPosition = anchorViewPosition\n              }\n            } else if (getBoundingClientRect(dom).top <= 0) {\n              // adjust scrolling if modified element is out of view,\n              // there is no anchor element, and the browser did not adjust scrollTop (this is checked later)\n              fixPosition = anchorViewPosition\n            }\n            fixScrollPosition(yxml._scrollElement, fixPosition)\n          }\n        } else if (event.type === 'childRemoved' || event.type === 'delete') {\n          for (let i = event.values.length - 1; i >= 0; i--) {\n            let dom = event.values[i]._dom\n            let fixPosition = null\n            if (anchorViewPosition === null) {\n              // nop\n            } else if (anchorViewPosition.anchor !== null) {\n              // no scrolling when current selection\n              if (!dom.contains(anchorViewPosition.anchor) && !anchorViewPosition.anchor.contains(dom)) {\n                fixPosition = anchorViewPosition\n              }\n            } else if (getBoundingClientRect(dom).top <= 0) {\n              // adjust scrolling if modified element is out of view,\n              // there is no anchor element, and the browser did not adjust scrollTop (this is checked later)\n              fixPosition = anchorViewPosition\n            }\n            dom.remove()\n            fixScrollPosition(yxml._scrollElement, fixPosition)\n          }\n        }\n        */\n      }\n    })\n  })\n}\n","import ID from './ID.js'\nimport RootID from './RootID.js'\n\nexport function getRelativePosition (type, offset) {\n  if (offset === 0) {\n    return ['startof', type._id.user, type._id.clock || null, type._id.name || null, type._id.type || null]\n  } else {\n    let t = type._start\n    while (t !== null) {\n      if (t._length >= offset) {\n        return [t._id.user, t._id.clock + offset - 1]\n      }\n      if (t._right === null) {\n        return [t._id.user, t._id.clock + t._length - 1]\n      }\n      if (!t._deleted) {\n        offset -= t._length\n      }\n      t = t._right\n    }\n    return null\n  }\n}\n\nexport function fromRelativePosition (y, rpos) {\n  if (rpos[0] === 'startof') {\n    let id\n    if (rpos[3] === null) {\n      id = new ID(rpos[1], rpos[2])\n    } else {\n      id = new RootID(rpos[3], rpos[4])\n    }\n    return {\n      type: y.os.get(id),\n      offset: 0\n    }\n  } else {\n    let offset = 0\n    let struct = y.os.findNodeWithUpperBound(new ID(rpos[0], rpos[1])).val\n    const parent = struct._parent\n    if (parent._deleted) {\n      return null\n    }\n    if (!struct._deleted) {\n      offset = rpos[1] - struct._id.clock + 1\n    }\n    struct = struct._left\n    while (struct !== null) {\n      if (!struct._deleted) {\n        offset += struct._length\n      }\n      struct = struct._left\n    }\n    return {\n      type: parent,\n      offset: offset\n    }\n  }\n}\n","/* globals getSelection */\n\nimport { getRelativePosition, fromRelativePosition } from '../../Util/relativePosition.js'\n\nlet browserSelection = null\nlet relativeSelection = null\n\nexport let beforeTransactionSelectionFixer\nif (typeof getSelection !== 'undefined') {\n  beforeTransactionSelectionFixer = function _beforeTransactionSelectionFixer (y, transaction, remote) {\n    if (!remote) {\n      return\n    }\n    relativeSelection = { from: null, to: null, fromY: null, toY: null }\n    browserSelection = getSelection()\n    const anchorNode = browserSelection.anchorNode\n    if (anchorNode !== null && anchorNode._yxml != null) {\n      const yxml = anchorNode._yxml\n      relativeSelection.from = getRelativePosition(yxml, browserSelection.anchorOffset)\n      relativeSelection.fromY = yxml._y\n    }\n    const focusNode = browserSelection.focusNode\n    if (focusNode !== null && focusNode._yxml != null) {\n      const yxml = focusNode._yxml\n      relativeSelection.to = getRelativePosition(yxml, browserSelection.focusOffset)\n      relativeSelection.toY = yxml._y\n    }\n  }\n} else {\n  beforeTransactionSelectionFixer = function _fakeBeforeTransactionSelectionFixer () {}\n}\n\nexport function afterTransactionSelectionFixer (y, transaction, remote) {\n  if (relativeSelection === null || !remote) {\n    return\n  }\n  const to = relativeSelection.to\n  const from = relativeSelection.from\n  const fromY = relativeSelection.fromY\n  const toY = relativeSelection.toY\n  let shouldUpdate = false\n  let anchorNode = browserSelection.anchorNode\n  let anchorOffset = browserSelection.anchorOffset\n  let focusNode = browserSelection.focusNode\n  let focusOffset = browserSelection.focusOffset\n  if (from !== null) {\n    let sel = fromRelativePosition(fromY, from)\n    if (sel !== null) {\n      shouldUpdate = true\n      anchorNode = sel.type.getDom()\n      anchorOffset = sel.offset\n    }\n  }\n  if (to !== null) {\n    let sel = fromRelativePosition(toY, to)\n    if (sel !== null) {\n      focusNode = sel.type.getDom()\n      focusOffset = sel.offset\n      shouldUpdate = true\n    }\n  }\n  if (shouldUpdate) {\n    browserSelection.setBaseAndExtent(\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    )\n  }\n  // delete, so the objects can be gc'd\n  relativeSelection = null\n  browserSelection = null\n}\n","/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int} cursor_pos Expected edit position in text1 (optional)\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos) {\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  // Check cursor_pos within bounds\n  if (cursor_pos < 0 || text1.length < cursor_pos) {\n    cursor_pos = null;\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs);\n  if (cursor_pos != null) {\n    diffs = fix_cursor(diffs, cursor_pos);\n  }\n  diffs = fix_emoji(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = diff_commonPrefix(longtext.substring(i),\n                                           shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(longtext.substring(0, i),\n                                           shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n */\nfunction diff_cleanupMerge(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n\n\nvar diff = diff_main;\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n\n/*\n * Modify a diff such that the cursor position points to the start of a change:\n * E.g.\n *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)\n *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]\n *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)\n *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} A tuple [cursor location in the modified diff, modified diff]\n */\nfunction cursor_normalize_diff (diffs, cursor_pos) {\n  if (cursor_pos === 0) {\n    return [DIFF_EQUAL, diffs];\n  }\n  for (var current_pos = 0, i = 0; i < diffs.length; i++) {\n    var d = diffs[i];\n    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {\n      var next_pos = current_pos + d[1].length;\n      if (cursor_pos === next_pos) {\n        return [i + 1, diffs];\n      } else if (cursor_pos < next_pos) {\n        // copy to prevent side effects\n        diffs = diffs.slice();\n        // split d into two diff changes\n        var split_pos = cursor_pos - current_pos;\n        var d_left = [d[0], d[1].slice(0, split_pos)];\n        var d_right = [d[0], d[1].slice(split_pos)];\n        diffs.splice(i, 1, d_left, d_right);\n        return [i + 1, diffs];\n      } else {\n        current_pos = next_pos;\n      }\n    }\n  }\n  throw new Error('cursor_pos is out of bounds!')\n}\n\n/*\n * Modify a diff such that the edit position is \"shifted\" to the proposed edit location (cursor_position).\n *\n * Case 1)\n *   Check if a naive shift is possible:\n *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)\n *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result\n * Case 2)\n *   Check if the following shifts are possible:\n *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']\n *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']\n *         ^            ^\n *         d          d_next\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} Array of diff tuples\n */\nfunction fix_cursor (diffs, cursor_pos) {\n  var norm = cursor_normalize_diff(diffs, cursor_pos);\n  var ndiffs = norm[1];\n  var cursor_pointer = norm[0];\n  var d = ndiffs[cursor_pointer];\n  var d_next = ndiffs[cursor_pointer + 1];\n\n  if (d == null) {\n    // Text was deleted from end of original string,\n    // cursor is now out of bounds in new string\n    return diffs;\n  } else if (d[0] !== DIFF_EQUAL) {\n    // A modification happened at the cursor location.\n    // This is the expected outcome, so we can return the original diff.\n    return diffs;\n  } else {\n    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {\n      // Case 1)\n      // It is possible to perform a naive shift\n      ndiffs.splice(cursor_pointer, 2, d_next, d)\n      return merge_tuples(ndiffs, cursor_pointer, 2)\n    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {\n      // Case 2)\n      // d[1] is a prefix of d_next[1]\n      // We can assume that d_next[0] !== 0, since d[0] === 0\n      // Shift edit locations..\n      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);\n      var suffix = d_next[1].slice(d[1].length);\n      if (suffix.length > 0) {\n        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);\n      }\n      return merge_tuples(ndiffs, cursor_pointer, 3)\n    } else {\n      // Not possible to perform any modification\n      return diffs;\n    }\n  }\n}\n\n/*\n * Check diff did not split surrogate pairs.\n * Ex. [0, '\\uD83D'], [-1, '\\uDC36'], [1, '\\uDC2F'] -> [-1, '\\uD83D\\uDC36'], [1, '\\uD83D\\uDC2F']\n *     '\\uD83D\\uDC36' === '🐶', '\\uD83D\\uDC2F' === '🐯'\n *\n * @param {Array} diffs Array of diff tuples\n * @return {Array} Array of diff tuples\n */\nfunction fix_emoji (diffs) {\n  var compact = false;\n  var starts_with_pair_end = function(str) {\n    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;\n  }\n  var ends_with_pair_start = function(str) {\n    return str.charCodeAt(str.length-1) >= 0xD800 && str.charCodeAt(str.length-1) <= 0xDBFF;\n  }\n  for (var i = 2; i < diffs.length; i += 1) {\n    if (diffs[i-2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i-2][1]) &&\n        diffs[i-1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i-1][1]) &&\n        diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {\n      compact = true;\n\n      diffs[i-1][1] = diffs[i-2][1].slice(-1) + diffs[i-1][1];\n      diffs[i][1] = diffs[i-2][1].slice(-1) + diffs[i][1];\n\n      diffs[i-2][1] = diffs[i-2][1].slice(0, -1);\n    }\n  }\n  if (!compact) {\n    return diffs;\n  }\n  var fixed_diffs = [];\n  for (var i = 0; i < diffs.length; i += 1) {\n    if (diffs[i][1].length > 0) {\n      fixed_diffs.push(diffs[i]);\n    }\n  }\n  return fixed_diffs;\n}\n\n/*\n * Try to merge tuples with their neigbors in a given range.\n * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']\n *\n * @param {Array} diffs Array of diff tuples.\n * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).\n * @param {Int} length Number of consecutive elements to check.\n * @return {Array} Array of merged diff tuples.\n */\nfunction merge_tuples (diffs, start, length) {\n  // Check from (start-1) to (start+length).\n  for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {\n    if (i + 1 < diffs.length) {\n      var left_d = diffs[i];\n      var right_d = diffs[i+1];\n      if (left_d[0] === right_d[1]) {\n        diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);\n      }\n    }\n  }\n  return diffs;\n}\n","/* global MutationObserver */\n\nimport { defaultDomFilter, applyChangesFromDom, reflectChangesOnDom } from './utils.js'\nimport { beforeTransactionSelectionFixer, afterTransactionSelectionFixer } from './selection.js'\n\nimport YArray from '../YArray.js'\nimport YXmlText from './YXmlText.js'\nimport YXmlEvent from './YXmlEvent.js'\nimport { logID } from '../../MessageHandler/messageToString.js'\nimport diff from 'fast-diff'\n\nfunction domToYXml (parent, doms, _document) {\n  const types = []\n  doms.forEach(d => {\n    if (d._yxml != null && d._yxml !== false) {\n      d._yxml._unbindFromDom()\n    }\n    if (parent._domFilter(d, []) !== null) {\n      let type\n      if (d.nodeType === d.TEXT_NODE) {\n        type = new YXmlText(d)\n      } else if (d.nodeType === d.ELEMENT_NODE) {\n        type = new YXmlFragment._YXmlElement(d, parent._domFilter, _document)\n      } else {\n        throw new Error('Unsupported node!')\n      }\n      type.enableSmartScrolling(parent._scrollElement)\n      types.push(type)\n    } else {\n      d._yxml = false\n    }\n  })\n  return types\n}\n\nclass YXmlTreeWalker {\n  constructor (root, f) {\n    this._filter = f || (() => true)\n    this._root = root\n    this._currentNode = root\n    this._firstCall = true\n  }\n  [Symbol.iterator] () {\n    return this\n  }\n  next () {\n    let n = this._currentNode\n    if (this._firstCall) {\n      this._firstCall = false\n      if (!n._deleted && this._filter(n)) {\n        return { value: n, done: false }\n      }\n    }\n    do {\n      if (!n._deleted && n.constructor === YXmlFragment._YXmlElement && n._start !== null) {\n        // walk down in the tree\n        n = n._start\n      } else {\n        // walk right or up in the tree\n        while (n !== this._root) {\n          if (n._right !== null) {\n            n = n._right\n            break\n          }\n          n = n._parent\n        }\n        if (n === this._root) {\n          n = null\n        }\n      }\n      if (n === this._root) {\n        break\n      }\n    } while (n !== null && (n._deleted || !this._filter(n)))\n    this._currentNode = n\n    if (n === null) {\n      return { done: true }\n    } else {\n      return { value: n, done: false }\n    }\n  }\n}\n\nexport default class YXmlFragment extends YArray {\n  constructor () {\n    super()\n    this._dom = null\n    this._domFilter = defaultDomFilter\n    this._domObserver = null\n    // this function makes sure that either the\n    // dom event is executed, or the yjs observer is executed\n    var token = true\n    this._mutualExclude = f => {\n      if (token) {\n        token = false\n        try {\n          f()\n        } catch (e) {\n          console.error(e)\n        }\n        if (this._domObserver !== null) {\n          this._domObserver.takeRecords()\n        }\n        token = true\n      }\n    }\n  }\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n  /**\n   * Retrieve first element that matches *query*\n   * Similar to DOM's querySelector, but only accepts a subset of its queries\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   */\n  querySelector (query) {\n    query = query.toUpperCase()\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName === query)\n    const next = iterator.next()\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n  querySelectorAll (query) {\n    query = query.toUpperCase()\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName === query))\n  }\n  enableSmartScrolling (scrollElement) {\n    this._scrollElement = scrollElement\n    this.forEach(xml => {\n      xml.enableSmartScrolling(scrollElement)\n    })\n  }\n  setDomFilter (f) {\n    this._domFilter = f\n    this.forEach(xml => {\n      xml.setDomFilter(f)\n    })\n  }\n  _callObserver (transaction, parentSubs, remote) {\n    this._callEventHandler(transaction, new YXmlEvent(this, parentSubs, remote))\n  }\n  toString () {\n    return this.map(xml => xml.toString()).join('')\n  }\n  _delete (y, createDelete) {\n    this._unbindFromDom()\n    super._delete(y, createDelete)\n  }\n  _unbindFromDom () {\n    if (this._domObserver != null) {\n      this._domObserver.disconnect()\n      this._domObserver = null\n    }\n    if (this._dom != null) {\n      this._dom._yxml = null\n      this._dom = null\n    }\n  }\n  insertDomElementsAfter (prev, doms, _document) {\n    const types = domToYXml(this, doms, _document)\n    this.insertAfter(prev, types)\n    return types\n  }\n  insertDomElements (pos, doms, _document) {\n    const types = domToYXml(this, doms, _document)\n    this.insert(pos, types)\n    return types\n  }\n  getDom () {\n    return this._dom\n  }\n  bindToDom (dom, _document) {\n    if (this._dom != null) {\n      this._unbindFromDom()\n    }\n    if (dom._yxml != null) {\n      dom._yxml._unbindFromDom()\n    }\n    dom.innerHTML = ''\n    this.forEach(t => {\n      dom.insertBefore(t.getDom(_document), null)\n    })\n    this._bindToDom(dom, _document)\n  }\n  // binds to a dom element\n  // Only call if dom and YXml are isomorph\n  _bindToDom (dom, _document) {\n    _document = _document || document\n    this._dom = dom\n    dom._yxml = this\n    // TODO: refine this..\n    if ((this.constructor !== YXmlFragment && this._parent !== this._y) || this._parent === null) {\n      // TODO: only top level YXmlFragment can bind. Also allow YXmlElements..\n      return\n    }\n    this._y.on('beforeTransaction', beforeTransactionSelectionFixer)\n    this._y.on('afterTransaction', afterTransactionSelectionFixer)\n    // Apply Y.Xml events to dom\n    this.observeDeep(events => {\n      reflectChangesOnDom.call(this, events, _document)\n    })\n    // Apply Dom changes on Y.Xml\n    if (typeof MutationObserver !== 'undefined') {\n      this._y.on('beforeTransaction', () => {\n        this._domObserverListener(this._domObserver.takeRecords())\n      })\n      this._domObserverListener = mutations => {\n        this._mutualExclude(() => {\n          this._y.transact(() => {\n            let diffChildren = new Set()\n            mutations.forEach(mutation => {\n              const dom = mutation.target\n              const yxml = dom._yxml\n              if (yxml == null) {\n                // dom element is filtered\n                return\n              }\n              switch (mutation.type) {\n                case 'characterData':\n                  var diffs = diff(yxml.toString(), dom.nodeValue)\n                  var pos = 0\n                  for (var i = 0; i < diffs.length; i++) {\n                    var d = diffs[i]\n                    if (d[0] === 0) { // EQUAL\n                      pos += d[1].length\n                    } else if (d[0] === -1) { // DELETE\n                      yxml.delete(pos, d[1].length)\n                    } else { // INSERT\n                      yxml.insert(pos, d[1])\n                      pos += d[1].length\n                    }\n                  }\n                  break\n                case 'attributes':\n                  let name = mutation.attributeName\n                  // check if filter accepts attribute\n                  if (this._domFilter(dom, [name]).length > 0 && yxml.constructor !== YXmlFragment) {\n                    var val = dom.getAttribute(name)\n                    if (yxml.getAttribute(name) !== val) {\n                      if (val == null) {\n                        yxml.removeAttribute(name)\n                      } else {\n                        yxml.setAttribute(name, val)\n                      }\n                    }\n                  }\n                  break\n                case 'childList':\n                  diffChildren.add(mutation.target)\n                  break\n              }\n            })\n            for (let dom of diffChildren) {\n              if (dom._yxml != null && dom._yxml !== false) {\n                applyChangesFromDom(dom)\n              }\n            }\n          })\n        })\n      }\n      this._domObserver = new MutationObserver(this._domObserverListener)\n      this._domObserver.observe(dom, {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n      })\n    }\n    return dom\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YXml(id:${logID(this._id)},left:${logID(left)},origin:${logID(origin)},right:${this._right},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import YArray from '../Type/YArray.js'\nimport YMap from '../Type/YMap.js'\nimport YText from '../Type/YText.js'\nimport YXmlFragment from '../Type/y-xml/YXmlFragment.js'\nimport YXmlElement from '../Type/y-xml/YXmlElement.js'\nimport YXmlText from '../Type/y-xml/YXmlText.js'\n\nimport Delete from '../Struct/Delete.js'\nimport ItemJSON from '../Struct/ItemJSON.js'\nimport ItemString from '../Struct/ItemString.js'\n\nconst structs = new Map()\nconst references = new Map()\n\nfunction addStruct (reference, structConstructor) {\n  structs.set(reference, structConstructor)\n  references.set(structConstructor, reference)\n}\n\nexport function getStruct (reference) {\n  return structs.get(reference)\n}\n\nexport function getReference (typeConstructor) {\n  return references.get(typeConstructor)\n}\n\naddStruct(0, ItemJSON)\naddStruct(1, ItemString)\naddStruct(2, Delete)\n\naddStruct(3, YArray)\naddStruct(4, YMap)\naddStruct(5, YText)\naddStruct(6, YXmlFragment)\naddStruct(7, YXmlElement)\naddStruct(8, YXmlText)\n","/* global crypto */\n\nexport function generateUserID () {\n  if (typeof crypto !== 'undefined' && crypto.getRandomValue != null) {\n    // browser\n    let arr = new Uint32Array(1)\n    crypto.getRandomValues(arr)\n    return arr[0]\n  } else if (typeof crypto !== 'undefined' && crypto.randomBytes != null) {\n    // node\n    let buf = crypto.randomBytes(4)\n    return new Uint32Array(buf.buffer)[0]\n  } else {\n    return Math.ceil(Math.random() * 0xFFFFFFFF)\n  }\n}\n","import ID from './ID.js'\n\nclass ReverseOperation {\n  constructor (y, transaction) {\n    this.created = new Date()\n    const beforeState = transaction.beforeState\n    this.toState = new ID(y.userID, y.ss.getState(y.userID) - 1)\n    if (beforeState.has(y.userID)) {\n      this.fromState = new ID(y.userID, beforeState.get(y.userID))\n    } else {\n      this.fromState = this.toState\n    }\n    this.deletedStructs = transaction.deletedStructs\n  }\n}\n\nfunction isStructInScope (y, struct, scope) {\n  while (struct !== y) {\n    if (struct === scope) {\n      return true\n    }\n    struct = struct._parent\n  }\n  return false\n}\n\nfunction applyReverseOperation (y, scope, reverseBuffer) {\n  let performedUndo = false\n  y.transact(() => {\n    while (!performedUndo && reverseBuffer.length > 0) {\n      let undoOp = reverseBuffer.pop()\n      // make sure that it is possible to iterate {from}-{to}\n      y.os.getItemCleanStart(undoOp.fromState)\n      y.os.getItemCleanEnd(undoOp.toState)\n      y.os.iterate(undoOp.fromState, undoOp.toState, op => {\n        if (!op._deleted && isStructInScope(y, op, scope)) {\n          performedUndo = true\n          op._delete(y)\n        }\n      })\n      for (let op of undoOp.deletedStructs) {\n        if (\n          isStructInScope(y, op, scope) &&\n          op._parent !== y &&\n          !op._parent._deleted &&\n          (\n            op._parent._id.user !== y.userID ||\n            op._parent._id.clock < undoOp.fromState.clock ||\n            op._parent._id.clock > undoOp.fromState.clock\n          )\n        ) {\n          performedUndo = true\n          op = op._copy(undoOp.deletedStructs)\n          op._integrate(y)\n        }\n      }\n    }\n  })\n  return performedUndo\n}\n\nexport default class UndoManager {\n  constructor (scope, options = {}) {\n    this.options = options\n    options.captureTimeout = options.captureTimeout == null ? 500 : options.captureTimeout\n    this._undoBuffer = []\n    this._redoBuffer = []\n    this._scope = scope\n    this._undoing = false\n    this._redoing = false\n    const y = scope._y\n    this.y = y\n    y.on('afterTransaction', (y, transaction, remote) => {\n      if (!remote && transaction.changedParentTypes.has(scope)) {\n        let reverseOperation = new ReverseOperation(y, transaction)\n        if (!this._undoing) {\n          let lastUndoOp = this._undoBuffer.length > 0 ? this._undoBuffer[this._undoBuffer.length - 1] : null\n          if (lastUndoOp !== null && reverseOperation.created - lastUndoOp.created <= options.captureTimeout) {\n            lastUndoOp.created = reverseOperation.created\n            lastUndoOp.toState = reverseOperation.toState\n            reverseOperation.deletedStructs.forEach(lastUndoOp.deletedStructs.add, lastUndoOp.deletedStructs)\n          } else {\n            this._undoBuffer.push(reverseOperation)\n          }\n          if (!this._redoing) {\n            this._redoBuffer = []\n          }\n        } else {\n          this._redoBuffer.push(reverseOperation)\n        }\n      }\n    })\n  }\n  undo () {\n    this._undoing = true\n    const performedUndo = applyReverseOperation(this.y, this._scope, this._undoBuffer)\n    this._undoing = false\n    return performedUndo\n  }\n  redo () {\n    this._redoing = true\n    const performedRedo = applyReverseOperation(this.y, this._scope, this._redoBuffer)\n    this._redoing = false\n    return performedRedo\n  }\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// import BinaryEncoder from './Binary/Encoder.js'\n\nexport default function extendPersistence (Y) {\n  class AbstractPersistence {\n    constructor (y, opts) {\n      this.y = y\n      this.opts = opts\n      this.saveOperationsBuffer = []\n      this.log = Y.debug('y:persistence')\n    }\n\n    saveToMessageQueue (binary) {\n      this.log('Room %s: Save message to message queue', this.y.options.connector.room)\n    }\n\n    saveOperations (ops) {\n      ops = ops.map(function (op) {\n        return Y.Struct[op.struct].encode(op)\n      })\n      /*\n      const saveOperations = () => {\n        if (this.saveOperationsBuffer.length > 0) {\n          let encoder = new BinaryEncoder()\n          encoder.writeVarString(this.opts.room)\n          encoder.writeVarString('update')\n          let ops = this.saveOperationsBuffer\n          this.saveOperationsBuffer = []\n          let length = ops.length\n          encoder.writeUint32(length)\n          for (var i = 0; i < length; i++) {\n            let op = ops[i]\n            Y.Struct[op.struct].binaryEncode(encoder, op)\n          }\n          this.saveToMessageQueue(encoder.createBuffer())\n        }\n      }\n      */\n      if (this.saveOperationsBuffer.length === 0) {\n        this.saveOperationsBuffer = ops\n      } else {\n        this.saveOperationsBuffer = this.saveOperationsBuffer.concat(ops)\n      }\n    }\n  }\n\n  Y.AbstractPersistence = AbstractPersistence\n}\n","\nclass N {\n  // A created node is always red!\n  constructor (val) {\n    this.val = val\n    this.color = true\n    this._left = null\n    this._right = null\n    this._parent = null\n  }\n  isRed () { return this.color }\n  isBlack () { return !this.color }\n  redden () { this.color = true; return this }\n  blacken () { this.color = false; return this }\n  get grandparent () {\n    return this.parent.parent\n  }\n  get parent () {\n    return this._parent\n  }\n  get sibling () {\n    return (this === this.parent.left)\n      ? this.parent.right : this.parent.left\n  }\n  get left () {\n    return this._left\n  }\n  get right () {\n    return this._right\n  }\n  set left (n) {\n    if (n !== null) {\n      n._parent = this\n    }\n    this._left = n\n  }\n  set right (n) {\n    if (n !== null) {\n      n._parent = this\n    }\n    this._right = n\n  }\n  rotateLeft (tree) {\n    var parent = this.parent\n    var newParent = this.right\n    var newRight = this.right.left\n    newParent.left = this\n    this.right = newRight\n    if (parent === null) {\n      tree.root = newParent\n      newParent._parent = null\n    } else if (parent.left === this) {\n      parent.left = newParent\n    } else if (parent.right === this) {\n      parent.right = newParent\n    } else {\n      throw new Error('The elements are wrongly connected!')\n    }\n  }\n  next () {\n    if (this.right !== null) {\n      // search the most left node in the right tree\n      var o = this.right\n      while (o.left !== null) {\n        o = o.left\n      }\n      return o\n    } else {\n      var p = this\n      while (p.parent !== null && p !== p.parent.left) {\n        p = p.parent\n      }\n      return p.parent\n    }\n  }\n  prev () {\n    if (this.left !== null) {\n      // search the most right node in the left tree\n      var o = this.left\n      while (o.right !== null) {\n        o = o.right\n      }\n      return o\n    } else {\n      var p = this\n      while (p.parent !== null && p !== p.parent.right) {\n        p = p.parent\n      }\n      return p.parent\n    }\n  }\n  rotateRight (tree) {\n    var parent = this.parent\n    var newParent = this.left\n    var newLeft = this.left.right\n    newParent.right = this\n    this.left = newLeft\n    if (parent === null) {\n      tree.root = newParent\n      newParent._parent = null\n    } else if (parent.left === this) {\n      parent.left = newParent\n    } else if (parent.right === this) {\n      parent.right = newParent\n    } else {\n      throw new Error('The elements are wrongly connected!')\n    }\n  }\n  getUncle () {\n    // we can assume that grandparent exists when this is called!\n    if (this.parent === this.parent.parent.left) {\n      return this.parent.parent.right\n    } else {\n      return this.parent.parent.left\n    }\n  }\n}\n\n/*\n * This is a Red Black Tree implementation\n */\nexport default class Tree {\n  constructor () {\n    this.root = null\n    this.length = 0\n  }\n  findNext (id) {\n    var nextID = id.clone()\n    nextID.clock += 1\n    return this.findWithLowerBound(nextID)\n  }\n  findPrev (id) {\n    let prevID = id.clone()\n    prevID.clock -= 1\n    return this.findWithUpperBound(prevID)\n  }\n  findNodeWithLowerBound (from) {\n    var o = this.root\n    if (o === null) {\n      return null\n    } else {\n      while (true) {\n        if (from === null || (from.lessThan(o.val._id) && o.left !== null)) {\n          // o is included in the bound\n          // try to find an element that is closer to the bound\n          o = o.left\n        } else if (from !== null && o.val._id.lessThan(from)) {\n          // o is not within the bound, maybe one of the right elements is..\n          if (o.right !== null) {\n            o = o.right\n          } else {\n            // there is no right element. Search for the next bigger element,\n            // this should be within the bounds\n            return o.next()\n          }\n        } else {\n          return o\n        }\n      }\n    }\n  }\n  findNodeWithUpperBound (to) {\n    if (to === void 0) {\n      throw new Error('You must define from!')\n    }\n    var o = this.root\n    if (o === null) {\n      return null\n    } else {\n      while (true) {\n        if ((to === null || o.val._id.lessThan(to)) && o.right !== null) {\n          // o is included in the bound\n          // try to find an element that is closer to the bound\n          o = o.right\n        } else if (to !== null && to.lessThan(o.val._id)) {\n          // o is not within the bound, maybe one of the left elements is..\n          if (o.left !== null) {\n            o = o.left\n          } else {\n            // there is no left element. Search for the prev smaller element,\n            // this should be within the bounds\n            return o.prev()\n          }\n        } else {\n          return o\n        }\n      }\n    }\n  }\n  findSmallestNode () {\n    var o = this.root\n    while (o != null && o.left != null) {\n      o = o.left\n    }\n    return o\n  }\n  findWithLowerBound (from) {\n    var n = this.findNodeWithLowerBound(from)\n    return n == null ? null : n.val\n  }\n  findWithUpperBound (to) {\n    var n = this.findNodeWithUpperBound(to)\n    return n == null ? null : n.val\n  }\n  iterate (from, to, f) {\n    var o\n    if (from === null) {\n      o = this.findSmallestNode()\n    } else {\n      o = this.findNodeWithLowerBound(from)\n    }\n    while (\n      o !== null &&\n      (\n        to === null || // eslint-disable-line no-unmodified-loop-condition\n        o.val._id.lessThan(to) ||\n        o.val._id.equals(to)\n      )\n    ) {\n      f(o.val)\n      o = o.next()\n    }\n  }\n  find (id) {\n    let n = this.findNode(id)\n    if (n !== null) {\n      return n.val\n    } else {\n      return null\n    }\n  }\n  findNode (id) {\n    var o = this.root\n    if (o === null) {\n      return null\n    } else {\n      while (true) {\n        if (o === null) {\n          return null\n        }\n        if (id.lessThan(o.val._id)) {\n          o = o.left\n        } else if (o.val._id.lessThan(id)) {\n          o = o.right\n        } else {\n          return o\n        }\n      }\n    }\n  }\n  delete (id) {\n    var d = this.findNode(id)\n    if (d == null) {\n      // throw new Error('Element does not exist!')\n      return\n    }\n    this.length--\n    if (d.left !== null && d.right !== null) {\n      // switch d with the greates element in the left subtree.\n      // o should have at most one child.\n      var o = d.left\n      // find\n      while (o.right !== null) {\n        o = o.right\n      }\n      // switch\n      d.val = o.val\n      d = o\n    }\n    // d has at most one child\n    // let n be the node that replaces d\n    var isFakeChild\n    var child = d.left || d.right\n    if (child === null) {\n      isFakeChild = true\n      child = new N(null)\n      child.blacken()\n      d.right = child\n    } else {\n      isFakeChild = false\n    }\n\n    if (d.parent === null) {\n      if (!isFakeChild) {\n        this.root = child\n        child.blacken()\n        child._parent = null\n      } else {\n        this.root = null\n      }\n      return\n    } else if (d.parent.left === d) {\n      d.parent.left = child\n    } else if (d.parent.right === d) {\n      d.parent.right = child\n    } else {\n      throw new Error('Impossible!')\n    }\n    if (d.isBlack()) {\n      if (child.isRed()) {\n        child.blacken()\n      } else {\n        this._fixDelete(child)\n      }\n    }\n    this.root.blacken()\n    if (isFakeChild) {\n      if (child.parent.left === child) {\n        child.parent.left = null\n      } else if (child.parent.right === child) {\n        child.parent.right = null\n      } else {\n        throw new Error('Impossible #3')\n      }\n    }\n  }\n  _fixDelete (n) {\n    function isBlack (node) {\n      return node !== null ? node.isBlack() : true\n    }\n    function isRed (node) {\n      return node !== null ? node.isRed() : false\n    }\n    if (n.parent === null) {\n      // this can only be called after the first iteration of fixDelete.\n      return\n    }\n    // d was already replaced by the child\n    // d is not the root\n    // d and child are black\n    var sibling = n.sibling\n    if (isRed(sibling)) {\n      // make sibling the grandfather\n      n.parent.redden()\n      sibling.blacken()\n      if (n === n.parent.left) {\n        n.parent.rotateLeft(this)\n      } else if (n === n.parent.right) {\n        n.parent.rotateRight(this)\n      } else {\n        throw new Error('Impossible #2')\n      }\n      sibling = n.sibling\n    }\n    // parent, sibling, and children of n are black\n    if (n.parent.isBlack() &&\n      sibling.isBlack() &&\n      isBlack(sibling.left) &&\n      isBlack(sibling.right)\n    ) {\n      sibling.redden()\n      this._fixDelete(n.parent)\n    } else if (n.parent.isRed() &&\n      sibling.isBlack() &&\n      isBlack(sibling.left) &&\n      isBlack(sibling.right)\n    ) {\n      sibling.redden()\n      n.parent.blacken()\n    } else {\n      if (n === n.parent.left &&\n        sibling.isBlack() &&\n        isRed(sibling.left) &&\n        isBlack(sibling.right)\n      ) {\n        sibling.redden()\n        sibling.left.blacken()\n        sibling.rotateRight(this)\n        sibling = n.sibling\n      } else if (n === n.parent.right &&\n        sibling.isBlack() &&\n        isRed(sibling.right) &&\n        isBlack(sibling.left)\n      ) {\n        sibling.redden()\n        sibling.right.blacken()\n        sibling.rotateLeft(this)\n        sibling = n.sibling\n      }\n      sibling.color = n.parent.color\n      n.parent.blacken()\n      if (n === n.parent.left) {\n        sibling.right.blacken()\n        n.parent.rotateLeft(this)\n      } else {\n        sibling.left.blacken()\n        n.parent.rotateRight(this)\n      }\n    }\n  }\n  put (v) {\n    var node = new N(v)\n    if (this.root !== null) {\n      var p = this.root // p abbrev. parent\n      while (true) {\n        if (node.val._id.lessThan(p.val._id)) {\n          if (p.left === null) {\n            p.left = node\n            break\n          } else {\n            p = p.left\n          }\n        } else if (p.val._id.lessThan(node.val._id)) {\n          if (p.right === null) {\n            p.right = node\n            break\n          } else {\n            p = p.right\n          }\n        } else {\n          p.val = node.val\n          return p\n        }\n      }\n      this._fixInsert(node)\n    } else {\n      this.root = node\n    }\n    this.length++\n    this.root.blacken()\n    return node\n  }\n  _fixInsert (n) {\n    if (n.parent === null) {\n      n.blacken()\n      return\n    } else if (n.parent.isBlack()) {\n      return\n    }\n    var uncle = n.getUncle()\n    if (uncle !== null && uncle.isRed()) {\n      // Note: parent: red, uncle: red\n      n.parent.blacken()\n      uncle.blacken()\n      n.grandparent.redden()\n      this._fixInsert(n.grandparent)\n    } else {\n      // Note: parent: red, uncle: black or null\n      // Now we transform the tree in such a way that\n      // either of these holds:\n      //   1) grandparent.left.isRed\n      //     and grandparent.left.left.isRed\n      //   2) grandparent.right.isRed\n      //     and grandparent.right.right.isRed\n      if (n === n.parent.right && n.parent === n.grandparent.left) {\n        n.parent.rotateLeft(this)\n        // Since we rotated and want to use the previous\n        // cases, we need to set n in such a way that\n        // n.parent.isRed again\n        n = n.left\n      } else if (n === n.parent.left && n.parent === n.grandparent.right) {\n        n.parent.rotateRight(this)\n        // see above\n        n = n.right\n      }\n      // Case 1) or 2) hold from here on.\n      // Now traverse grandparent, make parent a black node\n      // on the highest level which holds two red nodes.\n      n.parent.blacken()\n      n.grandparent.redden()\n      if (n === n.parent.left) {\n        // Case 1\n        n.grandparent.rotateRight(this)\n      } else {\n        // Case 2\n        n.grandparent.rotateLeft(this)\n      }\n    }\n  }\n  flush () {}\n}\n","\nexport default class ID {\n  constructor (user, clock) {\n    this.user = user\n    this.clock = clock\n  }\n  clone () {\n    return new ID(this.user, this.clock)\n  }\n  equals (id) {\n    return id !== null && id.user === this.user && id.clock === this.clock\n  }\n  lessThan (id) {\n    return this.user < id.user || (this.user === id.user && this.clock < id.clock)\n  }\n}\n","import Tree from '../Util/Tree.js'\nimport ID from '../Util/ID.js'\n\nclass DSNode {\n  constructor (id, len, gc) {\n    this._id = id\n    this.len = len\n    this.gc = gc\n  }\n  clone () {\n    return new DSNode(this._id, this.len, this.gc)\n  }\n}\n\nexport default class DeleteStore extends Tree {\n  logTable () {\n    const deletes = []\n    this.iterate(null, null, function (n) {\n      deletes.push({\n        user: n._id.user,\n        clock: n._id.clock,\n        len: n.len,\n        gc: n.gc\n      })\n    })\n    console.table(deletes)\n  }\n  isDeleted (id) {\n    var n = this.findWithUpperBound(id)\n    return n !== null && n._id.user === id.user && id.clock < n._id.clock + n.len\n  }\n  /*\n   * Mark an operation as deleted. returns the deleted node\n   */\n  markDeleted (id, length) {\n    if (length == null) {\n      throw new Error('length must be defined')\n    }\n    var n = this.findWithUpperBound(id)\n    if (n != null && n._id.user === id.user) {\n      if (n._id.clock <= id.clock && id.clock <= n._id.clock + n.len) {\n        // id is in n's range\n        var diff = id.clock + length - (n._id.clock + n.len) // overlapping right\n        if (diff > 0) {\n          // id+length overlaps n\n          if (!n.gc) {\n            n.len += diff\n          } else {\n            diff = n._id.clock + n.len - id.clock // overlapping left (id till n.end)\n            if (diff < length) {\n              // a partial deletion\n              let nId = id.clone()\n              nId.clock += diff\n              n = new DSNode(nId, length - diff, false)\n              this.put(n)\n            } else {\n              // already gc'd\n              throw new Error(\n                'DS reached an inconsistent state. Please report this issue!'\n              )\n            }\n          }\n        } else {\n          // no overlapping, already deleted\n          return n\n        }\n      } else {\n        // cannot extend left (there is no left!)\n        n = new DSNode(id, length, false)\n        this.put(n) // TODO: you double-put !!\n      }\n    } else {\n      // cannot extend left\n      n = new DSNode(id, length, false)\n      this.put(n)\n    }\n    // can extend right?\n    var next = this.findNext(n._id)\n    if (\n      next != null &&\n      n._id.user === next._id.user &&\n      n._id.clock + n.len >= next._id.clock\n    ) {\n      diff = n._id.clock + n.len - next._id.clock // from next.start to n.end\n      while (diff >= 0) {\n        // n overlaps with next\n        if (next.gc) {\n          // gc is stronger, so reduce length of n\n          n.len -= diff\n          if (diff >= next.len) {\n            // delete the missing range after next\n            diff = diff - next.len // missing range after next\n            if (diff > 0) {\n              this.put(n) // unneccessary? TODO!\n              this.markDeleted(new ID(next._id.user, next._id.clock + next.len), diff)\n            }\n          }\n          break\n        } else {\n          // we can extend n with next\n          if (diff > next.len) {\n            // n is even longer than next\n            // get next.next, and try to extend it\n            var _next = this.findNext(next._id)\n            this.delete(next._id)\n            if (_next == null || n._id.user !== _next._id.user) {\n              break\n            } else {\n              next = _next\n              diff = n._id.clock + n.len - next._id.clock // from next.start to n.end\n              // continue!\n            }\n          } else {\n            // n just partially overlaps with next. extend n, delete next, and break this loop\n            n.len += next.len - diff\n            this.delete(next._id)\n            break\n          }\n        }\n      }\n    }\n    this.put(n)\n    return n\n  }\n}\n","/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/*! http://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n","// UTF8 : Manage UTF-8 strings in ArrayBuffers\nif(module.require) {\n  require('string.fromcodepoint');\n  require('string.prototype.codepointat');\n}\n\nvar UTF8={\n  // non UTF8 encoding detection (cf README file for details)\n  'isNotUTF8': function(bytes, byteOffset, byteLength) {\n    try {\n      UTF8.getStringFromBytes(bytes, byteOffset, byteLength, true);\n    } catch(e) {\n      return true;\n    }\n    return false;\n  },\n  // UTF8 decoding functions\n  'getCharLength': function(theByte) {\n    // 4 bytes encoded char (mask 11110000)\n    if(0xF0 == (theByte&0xF0)) {\n      return 4;\n    // 3 bytes encoded char (mask 11100000)\n    } else if(0xE0 == (theByte&0xE0)) {\n      return 3;\n    // 2 bytes encoded char (mask 11000000)\n    } else if(0xC0 == (theByte&0xC0)) {\n      return 2;\n    // 1 bytes encoded char\n    } else if(theByte == (theByte&0x7F)) {\n      return 1;\n    }\n    return 0;\n  },\n  'getCharCode': function(bytes, byteOffset, charLength) {\n    var charCode = 0, mask = '';\n    byteOffset = byteOffset || 0;\n    // Retrieve charLength if not given\n    charLength = charLength || UTF8.getCharLength(bytes[byteOffset]);\n    if(charLength == 0) {\n      throw new Error(bytes[byteOffset].toString(2)+' is not a significative' +\n        ' byte (offset:'+byteOffset+').');\n    }\n    // Return byte value if charlength is 1\n    if(1 === charLength) {\n      return bytes[byteOffset];\n    }\n    // Test UTF8 integrity\n    mask = '00000000'.slice(0, charLength) + 1 + '00000000'.slice(charLength + 1);\n    if(bytes[byteOffset]&(parseInt(mask, 2))) {\n      throw Error('Index ' + byteOffset + ': A ' + charLength + ' bytes' +\n        ' encoded char' +' cannot encode the '+(charLength+1)+'th rank bit to 1.');\n    }\n    // Reading the first byte\n    mask='0000'.slice(0,charLength+1)+'11111111'.slice(charLength+1);\n    charCode+=(bytes[byteOffset]&parseInt(mask,2))<<((--charLength)*6);\n    // Reading the next bytes\n    while(charLength) {\n      if(0x80!==(bytes[byteOffset+1]&0x80)\n        ||0x40===(bytes[byteOffset+1]&0x40)) {\n        throw Error('Index '+(byteOffset+1)+': Next bytes of encoded char'\n          +' must begin with a \"10\" bit sequence.');\n      }\n      charCode += ((bytes[++byteOffset]&0x3F) << ((--charLength) * 6));\n    }\n    return charCode;\n  },\n  'getStringFromBytes': function(bytes, byteOffset, byteLength, strict) {\n    var charLength, chars = [];\n    byteOffset = byteOffset|0;\n    byteLength=('number' === typeof byteLength ?\n      byteLength :\n      bytes.byteLength || bytes.length\n    );\n    for(; byteOffset < byteLength; byteOffset++) {\n      charLength = UTF8.getCharLength(bytes[byteOffset]);\n      if(byteOffset + charLength > byteLength) {\n        if(strict) {\n          throw Error('Index ' + byteOffset + ': Found a ' + charLength +\n            ' bytes encoded char declaration but only ' +\n            (byteLength - byteOffset) +' bytes are available.');\n        }\n      } else {\n        chars.push(String.fromCodePoint(\n          UTF8.getCharCode(bytes, byteOffset, charLength, strict)\n        ));\n      }\n      byteOffset += charLength - 1;\n    }\n    return chars.join('');\n  },\n  // UTF8 encoding functions\n  'getBytesForCharCode': function(charCode) {\n    if(charCode < 128) {\n      return 1;\n    } else if(charCode < 2048) {\n      return 2;\n    } else if(charCode < 65536) {\n      return 3;\n    } else if(charCode < 2097152) {\n      return 4;\n    }\n    throw new Error('CharCode '+charCode+' cannot be encoded with UTF8.');\n  },\n  'setBytesFromCharCode': function(charCode, bytes, byteOffset, neededBytes) {\n    charCode = charCode|0;\n    bytes = bytes || [];\n    byteOffset = byteOffset|0;\n    neededBytes = neededBytes || UTF8.getBytesForCharCode(charCode);\n    // Setting the charCode as it to bytes if the byte length is 1\n    if(1 == neededBytes) {\n      bytes[byteOffset] = charCode;\n    } else {\n      // Computing the first byte\n      bytes[byteOffset++] =\n        (parseInt('1111'.slice(0, neededBytes), 2) << 8 - neededBytes) +\n        (charCode >>> ((--neededBytes) * 6));\n      // Computing next bytes\n      for(;neededBytes>0;) {\n        bytes[byteOffset++] = ((charCode>>>((--neededBytes) * 6))&0x3F)|0x80;\n      }\n    }\n    return bytes;\n  },\n  'setBytesFromString': function(string, bytes, byteOffset, byteLength, strict) {\n    string = string || '';\n    bytes = bytes || [];\n    byteOffset = byteOffset|0;\n    byteLength = ('number' === typeof byteLength ?\n      byteLength :\n      bytes.byteLength||Infinity\n    );\n    for(var i = 0, j = string.length; i < j; i++) {\n      var neededBytes = UTF8.getBytesForCharCode(string[i].codePointAt(0));\n      if(strict && byteOffset + neededBytes > byteLength) {\n        throw new Error('Not enought bytes to encode the char \"' + string[i] +\n          '\" at the offset \"' + byteOffset + '\".');\n      }\n      UTF8.setBytesFromCharCode(string[i].codePointAt(0),\n        bytes, byteOffset, neededBytes, strict);\n      byteOffset += neededBytes;\n    }\n    return bytes;\n  }\n};\n\nif('undefined' !== typeof module) {\n  module.exports = UTF8;\n}\n\n","import utf8 from 'utf-8'\nimport ID from '../Util/ID.js'\nimport { default as RootID, RootFakeUserID } from '../Util/RootID.js'\n\nexport default class BinaryDecoder {\n  constructor (buffer) {\n    if (buffer instanceof ArrayBuffer) {\n      this.uint8arr = new Uint8Array(buffer)\n    } else if (buffer instanceof Uint8Array || (typeof Buffer !== 'undefined' && buffer instanceof Buffer)) {\n      this.uint8arr = buffer\n    } else {\n      throw new Error('Expected an ArrayBuffer or Uint8Array!')\n    }\n    this.pos = 0\n  }\n  /**\n   * Clone this decoder instance\n   * Optionally set a new position parameter\n   */\n  clone (newPos = this.pos) {\n    let decoder = new BinaryDecoder(this.uint8arr)\n    decoder.pos = newPos\n    return decoder\n  }\n  /**\n   * Number of bytes\n   */\n  get length () {\n    return this.uint8arr.length\n  }\n  /**\n   * Skip one byte, jump to the next position\n   */\n  skip8 () {\n    this.pos++\n  }\n  /**\n   * Read one byte as unsigned integer\n   */\n  readUint8 () {\n    return this.uint8arr[this.pos++]\n  }\n  /**\n   * Read 4 bytes as unsigned integer\n   */\n  readUint32 () {\n    let uint =\n      this.uint8arr[this.pos] +\n      (this.uint8arr[this.pos + 1] << 8) +\n      (this.uint8arr[this.pos + 2] << 16) +\n      (this.uint8arr[this.pos + 3] << 24)\n    this.pos += 4\n    return uint\n  }\n  /**\n   * Look ahead without incrementing position\n   * to the next byte and read it as unsigned integer\n   */\n  peekUint8 () {\n    return this.uint8arr[this.pos]\n  }\n  /**\n   * Read unsigned integer (32bit) with variable length\n   * 1/8th of the storage is used as encoding overhead\n   *  - numbers < 2^7 is stored in one byte\n   *  - numbers < 2^14 is stored in two bytes\n   *  ..\n   */\n  readVarUint () {\n    let num = 0\n    let len = 0\n    while (true) {\n      let r = this.uint8arr[this.pos++]\n      num = num | ((r & 0b1111111) << len)\n      len += 7\n      if (r < 1 << 7) {\n        return num >>> 0 // return unsigned number!\n      }\n      if (len > 35) {\n        throw new Error('Integer out of range!')\n      }\n    }\n  }\n  /**\n   * Read string of variable length\n   * - varUint is used to store the length of the string\n   */\n  readVarString () {\n    let len = this.readVarUint()\n    let bytes = new Array(len)\n    for (let i = 0; i < len; i++) {\n      bytes[i] = this.uint8arr[this.pos++]\n    }\n    return utf8.getStringFromBytes(bytes)\n  }\n  /**\n   *  Look ahead and read varString without incrementing position\n   */\n  peekVarString () {\n    let pos = this.pos\n    let s = this.readVarString()\n    this.pos = pos\n    return s\n  }\n  /**\n   * Read ID\n   * - If first varUint read is 0xFFFFFF a RootID is returned\n   * - Otherwise an ID is returned\n   */\n  readID () {\n    let user = this.readVarUint()\n    if (user === RootFakeUserID) {\n      // read property name and type id\n      const rid = new RootID(this.readVarString(), null)\n      rid.type = this.readVarUint()\n      return rid\n    }\n    return new ID(user, this.readVarUint())\n  }\n}\n","import utf8 from 'utf-8'\nimport { RootFakeUserID } from '../Util/RootID.js'\n\nconst bits7 = 0b1111111\nconst bits8 = 0b11111111\n\nexport default class BinaryEncoder {\n  constructor () {\n    // TODO: implement chained Uint8Array buffers instead of Array buffer\n    this.data = []\n  }\n\n  get length () {\n    return this.data.length\n  }\n\n  get pos () {\n    return this.data.length\n  }\n\n  createBuffer () {\n    return Uint8Array.from(this.data).buffer\n  }\n\n  writeUint8 (num) {\n    this.data.push(num & bits8)\n  }\n\n  setUint8 (pos, num) {\n    this.data[pos] = num & bits8\n  }\n\n  writeUint16 (num) {\n    this.data.push(num & bits8, (num >>> 8) & bits8)\n  }\n\n  setUint16 (pos, num) {\n    this.data[pos] = num & bits8\n    this.data[pos + 1] = (num >>> 8) & bits8\n  }\n\n  writeUint32 (num) {\n    for (let i = 0; i < 4; i++) {\n      this.data.push(num & bits8)\n      num >>>= 8\n    }\n  }\n\n  setUint32 (pos, num) {\n    for (let i = 0; i < 4; i++) {\n      this.data[pos + i] = num & bits8\n      num >>>= 8\n    }\n  }\n\n  writeVarUint (num) {\n    while (num >= 0b10000000) {\n      this.data.push(0b10000000 | (bits7 & num))\n      num >>>= 7\n    }\n    this.data.push(bits7 & num)\n  }\n\n  writeVarString (str) {\n    let bytes = utf8.setBytesFromString(str)\n    let len = bytes.length\n    this.writeVarUint(len)\n    for (let i = 0; i < len; i++) {\n      this.data.push(bytes[i])\n    }\n  }\n\n  writeID (id) {\n    const user = id.user\n    this.writeVarUint(user)\n    if (user !== RootFakeUserID) {\n      this.writeVarUint(id.clock)\n    } else {\n      this.writeVarString(id.name)\n      this.writeVarUint(id.type)\n    }\n  }\n}\n","\nexport default class EventHandler {\n  constructor () {\n    this.eventListeners = []\n  }\n  destroy () {\n    this.eventListeners = null\n  }\n  addEventListener (f) {\n    this.eventListeners.push(f)\n  }\n  removeEventListener (f) {\n    this.eventListeners = this.eventListeners.filter(function (g) {\n      return f !== g\n    })\n  }\n  removeAllEventListeners () {\n    this.eventListeners = []\n  }\n  callEventListeners (transaction, event) {\n    for (var i = 0; i < this.eventListeners.length; i++) {\n      try {\n        const f = this.eventListeners[i]\n        f(event)\n      } catch (e) {\n        /*\n          Your observer threw an error. This error was caught so that Yjs\n          can ensure data consistency! In order to debug this error you\n          have to check \"Pause On Caught Exceptions\" in developer tools.\n        */\n        console.error(e)\n      }\n    }\n  }\n}\n","import { splitHelper, default as Item } from './Item.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class ItemJSON extends Item {\n  constructor () {\n    super()\n    this._content = null\n  }\n  _copy () {\n    let struct = super._copy()\n    struct._content = this._content\n    return struct\n  }\n  get _length () {\n    return this._content.length\n  }\n  _fromBinary (y, decoder) {\n    let missing = super._fromBinary(y, decoder)\n    let len = decoder.readVarUint()\n    this._content = new Array(len)\n    for (let i = 0; i < len; i++) {\n      const ctnt = decoder.readVarString()\n      let parsed\n      if (ctnt === 'undefined') {\n        parsed = undefined\n      } else {\n        parsed = JSON.parse(ctnt)\n      }\n      this._content[i] = parsed\n    }\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    let len = this._content.length\n    encoder.writeVarUint(len)\n    for (let i = 0; i < len; i++) {\n      let encoded\n      let content = this._content[i]\n      if (content === undefined) {\n        encoded = 'undefined'\n      } else {\n        encoded = JSON.stringify(content)\n      }\n      encoder.writeVarString(encoded)\n    }\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `ItemJSON(id:${logID(this._id)},content:${JSON.stringify(this._content)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n  _splitAt (y, diff) {\n    if (diff === 0) {\n      return this\n    } else if (diff >= this._length) {\n      return this._right\n    }\n    let item = new ItemJSON()\n    item._content = this._content.splice(diff)\n    splitHelper(y, this, item, diff)\n    return item\n  }\n}\n","import { splitHelper, default as Item } from './Item.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class ItemString extends Item {\n  constructor () {\n    super()\n    this._content = null\n  }\n  _copy () {\n    let struct = super._copy()\n    struct._content = this._content\n    return struct\n  }\n  get _length () {\n    return this._content.length\n  }\n  _fromBinary (y, decoder) {\n    let missing = super._fromBinary(y, decoder)\n    this._content = decoder.readVarString()\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    encoder.writeVarString(this._content)\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `ItemJSON(id:${logID(this._id)},content:${JSON.stringify(this._content)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n  _splitAt (y, diff) {\n    if (diff === 0) {\n      return this\n    } else if (diff >= this._length) {\n      return this._right\n    }\n    let item = new ItemString()\n    item._content = this._content.slice(diff)\n    this._content = this._content.slice(0, diff)\n    splitHelper(y, this, item, diff)\n    return item\n  }\n}\n","\nexport default class YEvent {\n  constructor (target) {\n    this.target = target\n    this.currentTarget = target\n  }\n  get path () {\n    const path = []\n    let type = this.target\n    const y = type._y\n    while (type !== this.currentTarget && type !== y) {\n      let parent = type._parent\n      if (type._parentSub !== null) {\n        path.unshift(type._parentSub)\n      } else {\n        // parent is array-ish\n        for (let [i, child] of parent) {\n          if (child === type) {\n            path.unshift(i)\n            break\n          }\n        }\n      }\n      type = parent\n    }\n    return path\n  }\n}\n","import Type from '../Struct/Type.js'\nimport ItemJSON from '../Struct/ItemJSON.js'\nimport ItemString from '../Struct/ItemString.js'\nimport { logID } from '../MessageHandler/messageToString.js'\nimport YEvent from '../Util/YEvent.js'\n\nclass YArrayEvent extends YEvent {\n  constructor (yarray, remote) {\n    super(yarray)\n    this.remote = remote\n  }\n}\n\nexport default class YArray extends Type {\n  _callObserver (transaction, parentSubs, remote) {\n    this._callEventHandler(transaction, new YArrayEvent(this, remote))\n  }\n  get (pos) {\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        if (pos < n._length) {\n          if (n.constructor === ItemJSON || n.constructor === ItemString) {\n            return n._content[pos]\n          } else {\n            return n\n          }\n        }\n        pos -= n._length\n      }\n      n = n._right\n    }\n  }\n  toArray () {\n    return this.map(c => c)\n  }\n  toJSON () {\n    return this.map(c => {\n      if (c instanceof Type) {\n        if (c.toJSON !== null) {\n          return c.toJSON()\n        } else {\n          return c.toString()\n        }\n      }\n      return c\n    })\n  }\n  map (f) {\n    const res = []\n    this.forEach((c, i) => {\n      res.push(f(c, i, this))\n    })\n    return res\n  }\n  forEach (f) {\n    let pos = 0\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        if (n instanceof Type) {\n          f(n, pos++, this)\n        } else {\n          const content = n._content\n          const contentLen = content.length\n          for (let i = 0; i < contentLen; i++) {\n            pos++\n            f(content[i], pos, this)\n          }\n        }\n      }\n      n = n._right\n    }\n  }\n  get length () {\n    let length = 0\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        length += n._length\n      }\n      n = n._right\n    }\n    return length\n  }\n  [Symbol.iterator] () {\n    return {\n      next: function () {\n        while (this._item !== null && (this._item._deleted || this._item._length <= this._itemElement)) {\n          // item is deleted or itemElement does not exist (is deleted)\n          this._item = this._item._right\n          this._itemElement = 0\n        }\n        if (this._item === null) {\n          return {\n            done: true\n          }\n        }\n        let content\n        if (this._item instanceof Type) {\n          content = this._item\n        } else {\n          content = this._item._content[this._itemElement++]\n        }\n        return {\n          value: [this._count, content],\n          done: false\n        }\n      },\n      _item: this._start,\n      _itemElement: 0,\n      _count: 0\n    }\n  }\n  delete (pos, length = 1) {\n    this._y.transact(() => {\n      let item = this._start\n      let count = 0\n      while (item !== null && length > 0) {\n        if (!item._deleted) {\n          if (count <= pos && pos < count + item._length) {\n            const diffDel = pos - count\n            item = item._splitAt(this._y, diffDel)\n            item._splitAt(this._y, length)\n            length -= item._length\n            item._delete(this._y)\n            count += diffDel\n          } else {\n            count += item._length\n          }\n        }\n        item = item._right\n      }\n    })\n    if (length > 0) {\n      throw new Error('Delete exceeds the range of the YArray')\n    }\n  }\n  insertAfter (left, content) {\n    this._transact(y => {\n      let right\n      if (left === null) {\n        right = this._start\n      } else {\n        right = left._right\n      }\n      let prevJsonIns = null\n      for (let i = 0; i < content.length; i++) {\n        let c = content[i]\n        if (typeof c === 'function') {\n          c = new c() // eslint-disable-line new-cap\n        }\n        if (c instanceof Type) {\n          if (prevJsonIns !== null) {\n            if (y !== null) {\n              prevJsonIns._integrate(y)\n            }\n            left = prevJsonIns\n            prevJsonIns = null\n          }\n          c._origin = left\n          c._left = left\n          c._right = right\n          c._right_origin = right\n          c._parent = this\n          if (y !== null) {\n            c._integrate(y)\n          } else if (left === null) {\n            this._start = c\n          } else {\n            left._right = c\n          }\n          left = c\n        } else {\n          if (prevJsonIns === null) {\n            prevJsonIns = new ItemJSON()\n            prevJsonIns._origin = left\n            prevJsonIns._left = left\n            prevJsonIns._right = right\n            prevJsonIns._right_origin = right\n            prevJsonIns._parent = this\n            prevJsonIns._content = []\n          }\n          prevJsonIns._content.push(c)\n        }\n      }\n      if (prevJsonIns !== null && y !== null) {\n        prevJsonIns._integrate(y)\n      }\n    })\n  }\n  insert (pos, content) {\n    let left = null\n    let right = this._start\n    let count = 0\n    const y = this._y\n    while (right !== null) {\n      const rightLen = right._deleted ? 0 : (right._length - 1)\n      if (count <= pos && pos <= count + rightLen) {\n        const splitDiff = pos - count\n        right = right._splitAt(y, splitDiff)\n        left = right._left\n        count += splitDiff\n        break\n      }\n      if (!right._deleted) {\n        count += right._length\n      }\n      left = right\n      right = right._right\n    }\n    if (pos > count) {\n      throw new Error('Position exceeds array range!')\n    }\n    this.insertAfter(left, content)\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YArray(id:${logID(this._id)},start:${logID(this._start)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import Type from '../Struct/Type.js'\nimport Item from '../Struct/Item.js'\nimport ItemJSON from '../Struct/ItemJSON.js'\nimport { logID } from '../MessageHandler/messageToString.js'\nimport YEvent from '../Util/YEvent.js'\n\nclass YMapEvent extends YEvent {\n  constructor (ymap, subs, remote) {\n    super(ymap)\n    this.keysChanged = subs\n    this.remote = remote\n  }\n}\n\nexport default class YMap extends Type {\n  _callObserver (transaction, parentSubs, remote) {\n    this._callEventHandler(transaction, new YMapEvent(this, parentSubs, remote))\n  }\n  toJSON () {\n    const map = {}\n    for (let [key, item] of this._map) {\n      if (!item._deleted) {\n        let res\n        if (item instanceof Type) {\n          if (item.toJSON !== undefined) {\n            res = item.toJSON()\n          } else {\n            res = item.toString()\n          }\n        } else {\n          res = item._content[0]\n        }\n        map[key] = res\n      }\n    }\n    return map\n  }\n  keys () {\n    let keys = []\n    for (let [key, value] of this._map) {\n      if (!value._deleted) {\n        keys.push(key)\n      }\n    }\n    return keys\n  }\n  delete (key) {\n    this._transact((y) => {\n      let c = this._map.get(key)\n      if (y !== null && c !== undefined) {\n        c._delete(y)\n      }\n    })\n  }\n  set (key, value) {\n    this._transact(y => {\n      const old = this._map.get(key) || null\n      if (old !== null) {\n        if (old instanceof ItemJSON && old._content[0] === value) {\n          // Trying to overwrite with same value\n          // break here\n          return value\n        }\n        if (y !== null) {\n          old._delete(y)\n        }\n      }\n      let v\n      if (typeof value === 'function') {\n        v = new value() // eslint-disable-line new-cap\n        value = v\n      } else if (value instanceof Item) {\n        v = value\n      } else {\n        v = new ItemJSON()\n        v._content = [value]\n      }\n      v._right = old\n      v._right_origin = old\n      v._parent = this\n      v._parentSub = key\n      if (y !== null) {\n        v._integrate(y)\n      } else {\n        this._map.set(key, v)\n      }\n    })\n    return value\n  }\n  get (key) {\n    let v = this._map.get(key)\n    if (v === undefined || v._deleted) {\n      return undefined\n    }\n    if (v instanceof Type) {\n      return v\n    } else {\n      return v._content[v._content.length - 1]\n    }\n  }\n  has (key) {\n    let v = this._map.get(key)\n    if (v === undefined || v._deleted) {\n      return false\n    } else {\n      return true\n    }\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YMap(id:${logID(this._id)},mapSize:${this._map.size},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import ItemString from '../Struct/ItemString.js'\nimport YArray from './YArray.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class YText extends YArray {\n  constructor (string) {\n    super()\n    if (typeof string === 'string') {\n      const start = new ItemString()\n      start._parent = this\n      start._content = string\n      this._start = start\n    }\n  }\n  toString () {\n    const strBuilder = []\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        strBuilder.push(n._content)\n      }\n      n = n._right\n    }\n    return strBuilder.join('')\n  }\n  insert (pos, text) {\n    this._transact(y => {\n      let left = null\n      let right = this._start\n      let count = 0\n      while (right !== null) {\n        if (count <= pos && pos < count + right._length) {\n          const splitDiff = pos - count\n          right = right._splitAt(this._y, pos - count)\n          left = right._left\n          count += splitDiff\n          break\n        }\n        count += right._length\n        left = right\n        right = right._right\n      }\n      if (pos > count) {\n        throw new Error('Position exceeds array range!')\n      }\n      let item = new ItemString()\n      item._origin = left\n      item._left = left\n      item._right = right\n      item._right_origin = right\n      item._parent = this\n      item._content = text\n      if (y !== null) {\n        item._integrate(this._y)\n      } else if (left === null) {\n        this._start = item\n      } else {\n        left._right = item\n      }\n    })\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YText(id:${logID(this._id)},start:${logID(this._start)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import YText from '../YText.js'\n\nexport default class YXmlText extends YText {\n  constructor (arg1) {\n    let dom = null\n    let initialText = null\n    if (arg1 != null) {\n      if (arg1.nodeType != null && arg1.nodeType === arg1.TEXT_NODE) {\n        dom = arg1\n        initialText = dom.nodeValue\n      } else if (typeof arg1 === 'string') {\n        initialText = arg1\n      }\n    }\n    super(initialText)\n    this._dom = null\n    this._domObserver = null\n    this._domObserverListener = null\n    this._scrollElement = null\n    if (dom !== null) {\n      this._setDom(arg1)\n    }\n    /*\n    var token = true\n    this._mutualExclude = f => {\n      if (token) {\n        token = false\n        try {\n          f()\n        } catch (e) {\n          console.error(e)\n        }\n        this._domObserver.takeRecords()\n        token = true\n      }\n    }\n    this.observe(event => {\n      if (this._dom != null) {\n        const dom = this._dom\n        this._mutualExclude(() => {\n          let anchorViewPosition = getAnchorViewPosition(this._scrollElement)\n          let anchorViewFix\n          if (anchorViewPosition !== null && (anchorViewPosition.anchor !== null || getBoundingClientRect(this._dom).top <= 0)) {\n            anchorViewFix = anchorViewPosition\n          } else {\n            anchorViewFix = null\n          }\n          dom.nodeValue = this.toString()\n          fixScrollPosition(this._scrollElement, anchorViewFix)\n        })\n      }\n    })\n    */\n  }\n  setDomFilter () {}\n  enableSmartScrolling (scrollElement) {\n    this._scrollElement = scrollElement\n  }\n  _setDom (dom) {\n    if (this._dom != null) {\n      this._unbindFromDom()\n    }\n    if (dom._yxml != null) {\n      dom._yxml._unbindFromDom()\n    }\n    // set marker\n    this._dom = dom\n    dom._yxml = this\n  }\n  getDom (_document) {\n    _document = _document || document\n    if (this._dom === null) {\n      const dom = _document.createTextNode(this.toString())\n      this._setDom(dom)\n      return dom\n    }\n    return this._dom\n  }\n  _delete (y, createDelete) {\n    this._unbindFromDom()\n    super._delete(y, createDelete)\n  }\n  _unbindFromDom () {\n    if (this._domObserver != null) {\n      this._domObserver.disconnect()\n      this._domObserver = null\n    }\n    if (this._dom != null) {\n      this._dom._yxml = null\n      this._dom = null\n    }\n  }\n}\n","import YEvent from '../../Util/YEvent.js'\n\nexport default class YXmlEvent extends YEvent {\n  constructor (target, subs, remote) {\n    super(target)\n    this.childListChanged = false\n    this.attributesChanged = new Set()\n    this.remote = remote\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.attributesChanged.add(sub)\n      }\n    })\n  }\n}\n","// import diff from 'fast-diff'\nimport { defaultDomFilter } from './utils.js'\n\nimport YMap from '../YMap.js'\nimport YXmlFragment from './YXmlFragment.js'\n\nexport default class YXmlElement extends YXmlFragment {\n  constructor (arg1, arg2, _document) {\n    super()\n    this.nodeName = null\n    this._scrollElement = null\n    if (typeof arg1 === 'string') {\n      this.nodeName = arg1.toUpperCase()\n    } else if (arg1 != null && arg1.nodeType != null && arg1.nodeType === arg1.ELEMENT_NODE) {\n      this.nodeName = arg1.nodeName\n      this._setDom(arg1, _document)\n    } else {\n      this.nodeName = 'UNDEFINED'\n    }\n    if (typeof arg2 === 'function') {\n      this._domFilter = arg2\n    }\n  }\n  _copy (undeleteChildren) {\n    let struct = super._copy(undeleteChildren)\n    struct.nodeName = this.nodeName\n    return struct\n  }\n  _setDom (dom, _document) {\n    if (this._dom != null) {\n      throw new Error('Only call this method if you know what you are doing ;)')\n    } else if (dom._yxml != null) { // TODO do i need to check this? - no.. but for dev purps..\n      throw new Error('Already bound to an YXml type')\n    } else {\n      // tag is already set in constructor\n      // set attributes\n      let attrNames = []\n      for (let i = 0; i < dom.attributes.length; i++) {\n        attrNames.push(dom.attributes[i].name)\n      }\n      attrNames = this._domFilter(dom, attrNames)\n      for (let i = 0; i < attrNames.length; i++) {\n        let attrName = attrNames[i]\n        let attrValue = dom.getAttribute(attrName)\n        this.setAttribute(attrName, attrValue)\n      }\n      this.insertDomElements(0, Array.prototype.slice.call(dom.childNodes), _document)\n      this._bindToDom(dom, _document)\n      return dom\n    }\n  }\n  _fromBinary (y, decoder) {\n    const missing = super._fromBinary(y, decoder)\n    this.nodeName = decoder.readVarString()\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    encoder.writeVarString(this.nodeName)\n  }\n  _integrate (y) {\n    if (this.nodeName === null) {\n      throw new Error('nodeName must be defined!')\n    }\n    if (this._domFilter === defaultDomFilter && this._parent instanceof YXmlFragment) {\n      this._domFilter = this._parent._domFilter\n    }\n    super._integrate(y)\n  }\n  /**\n   * Returns the string representation of the XML document.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   */\n  toString () {\n    const attrs = this.getAttributes()\n    const stringBuilder = []\n    const keys = []\n    for (let key in attrs) {\n      keys.push(key)\n    }\n    keys.sort()\n    const keysLen = keys.length\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i]\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"')\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase()\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : ''\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n  removeAttribute () {\n    return YMap.prototype.delete.apply(this, arguments)\n  }\n\n  setAttribute () {\n    return YMap.prototype.set.apply(this, arguments)\n  }\n\n  getAttribute () {\n    return YMap.prototype.get.apply(this, arguments)\n  }\n\n  getAttributes () {\n    const obj = {}\n    for (let [key, value] of this._map) {\n      obj[key] = value._content[0]\n    }\n    return obj\n  }\n  getDom (_document) {\n    _document = _document || document\n    let dom = this._dom\n    if (dom == null) {\n      dom = _document.createElement(this.nodeName)\n      dom._yxml = this\n      let attrs = this.getAttributes()\n      for (let key in attrs) {\n        dom.setAttribute(key, attrs[key])\n      }\n      this.forEach(yxml => {\n        dom.appendChild(yxml.getDom(_document))\n      })\n      this._bindToDom(dom, _document)\n    }\n    return dom\n  }\n}\n","import { getReference } from './structReferences.js'\n\nexport const RootFakeUserID = 0xFFFFFF\n\nexport default class RootID {\n  constructor (name, typeConstructor) {\n    this.user = RootFakeUserID\n    this.name = name\n    this.type = getReference(typeConstructor)\n  }\n  equals (id) {\n    return id !== null && id.user === this.user && id.name === this.name && id.type === this.type\n  }\n  lessThan (id) {\n    return this.user < id.user || (this.user === id.user && (this.name < id.name || (this.name === id.name && this.type < id.type)))\n  }\n}\n","import Tree from '../Util/Tree.js'\nimport RootID from '../Util/RootID.js'\nimport { getStruct } from '../Util/structReferences.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class OperationStore extends Tree {\n  constructor (y) {\n    super()\n    this.y = y\n  }\n  logTable () {\n    const items = []\n    this.iterate(null, null, function (item) {\n      items.push({\n        id: logID(item),\n        origin: logID(item._origin === null ? null : item._origin._lastId),\n        left: logID(item._left === null ? null : item._left._lastId),\n        right: logID(item._right),\n        right_origin: logID(item._right_origin),\n        parent: logID(item._parent),\n        parentSub: item._parentSub,\n        deleted: item._deleted,\n        content: JSON.stringify(item._content)\n      })\n    })\n    console.table(items)\n  }\n  get (id) {\n    let struct = this.find(id)\n    if (struct === null && id instanceof RootID) {\n      const Constr = getStruct(id.type)\n      const y = this.y\n      struct = new Constr()\n      struct._id = id\n      struct._parent = y\n      y.transact(() => {\n        struct._integrate(y)\n      })\n      this.put(struct)\n    }\n    return struct\n  }\n  // Use getItem for structs with _length > 1\n  getItem (id) {\n    var item = this.findWithUpperBound(id)\n    if (item === null) {\n      return null\n    }\n    const itemID = item._id\n    if (id.user === itemID.user && id.clock < itemID.clock + item._length) {\n      return item\n    } else {\n      return null\n    }\n  }\n  // Return an insertion such that id is the first element of content\n  // This function manipulates an item, if necessary\n  getItemCleanStart (id) {\n    var ins = this.getItem(id)\n    if (ins === null || ins._length === 1) {\n      return ins\n    }\n    const insID = ins._id\n    if (insID.clock === id.clock) {\n      return ins\n    } else {\n      return ins._splitAt(this.y, id.clock - insID.clock)\n    }\n  }\n  // Return an insertion such that id is the last element of content\n  // This function manipulates an operation, if necessary\n  getItemCleanEnd (id) {\n    var ins = this.getItem(id)\n    if (ins === null || ins._length === 1) {\n      return ins\n    }\n    const insID = ins._id\n    if (insID.clock + ins._length - 1 === id.clock) {\n      return ins\n    } else {\n      ins._splitAt(this.y, id.clock - insID.clock + 1)\n      return ins\n    }\n  }\n}\n","import ID from '../Util/ID.js'\n\nexport default class StateStore {\n  constructor (y) {\n    this.y = y\n    this.state = new Map()\n  }\n  logTable () {\n    const entries = []\n    for (let [user, state] of this.state) {\n      entries.push({\n        user, state\n      })\n    }\n    console.table(entries)\n  }\n  getNextID (len) {\n    const user = this.y.userID\n    const state = this.getState(user)\n    this.setState(user, state + len)\n    return new ID(user, state)\n  }\n  updateRemoteState (struct) {\n    let user = struct._id.user\n    let userState = this.state.get(user)\n    while (struct !== null && struct._id.clock === userState) {\n      userState += struct._length\n      struct = this.y.os.get(new ID(user, userState))\n    }\n    this.state.set(user, userState)\n  }\n  getState (user) {\n    let state = this.state.get(user)\n    if (state == null) {\n      return 0\n    }\n    return state\n  }\n  setState (user, state) {\n    // TODO: modify missingi structs here\n    const beforeState = this.y._transaction.beforeState\n    if (!beforeState.has(user)) {\n      beforeState.set(user, this.getState(user))\n    }\n    this.state.set(user, state)\n  }\n}\n","export default class NamedEventHandler {\n  constructor () {\n    this._eventListener = new Map()\n  }\n  _getListener (name) {\n    let listeners = this._eventListener.get(name)\n    if (listeners === undefined) {\n      listeners = {\n        once: new Set(),\n        on: new Set()\n      }\n      this._eventListener.set(name, listeners)\n    }\n    return listeners\n  }\n  once (name, f) {\n    let listeners = this._getListener(name)\n    listeners.once.add(f)\n  }\n  on (name, f) {\n    let listeners = this._getListener(name)\n    listeners.on.add(f)\n  }\n  off (name, f) {\n    if (name == null || f == null) {\n      throw new Error('You must specify event name and function!')\n    }\n    const listener = this._eventListener.get(name)\n    if (listener !== undefined) {\n      listener.remove(f)\n    }\n  }\n  emit (name, ...args) {\n    const listener = this._eventListener.get(name)\n    if (listener !== undefined) {\n      listener.on.forEach(f => f.apply(null, args))\n      listener.once.forEach(f => f.apply(null, args))\n      listener.once = new Set()\n    } else if (name === 'error') {\n      console.error(args[0])\n    }\n  }\n  destroy () {\n    this._eventListener = null\n  }\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","import BinaryEncoder from './Binary/Encoder.js'\nimport BinaryDecoder from './Binary/Decoder.js'\n\nimport { sendSyncStep1, readSyncStep1 } from './MessageHandler/syncStep1.js'\nimport { readSyncStep2 } from './MessageHandler/syncStep2.js'\nimport { integrateRemoteStructs } from './MessageHandler/integrateRemoteStructs.js'\n\nimport debug from 'debug'\n\nexport default class AbstractConnector {\n  constructor (y, opts) {\n    this.y = y\n    this.opts = opts\n    if (opts.role == null || opts.role === 'master') {\n      this.role = 'master'\n    } else if (opts.role === 'slave') {\n      this.role = 'slave'\n    } else {\n      throw new Error(\"Role must be either 'master' or 'slave'!\")\n    }\n    this.log = debug('y:connector')\n    this.logMessage = debug('y:connector-message')\n    this._forwardAppliedStructs = opts.forwardAppliedOperations || false // TODO: rename\n    this.role = opts.role\n    this.connections = new Map()\n    this.isSynced = false\n    this.userEventListeners = []\n    this.whenSyncedListeners = []\n    this.currentSyncTarget = null\n    this.debug = opts.debug === true\n    this.broadcastBuffer = new BinaryEncoder()\n    this.broadcastBufferSize = 0\n    this.protocolVersion = 11\n    this.authInfo = opts.auth || null\n    this.checkAuth = opts.checkAuth || function () { return Promise.resolve('write') } // default is everyone has write access\n    if (opts.maxBufferLength == null) {\n      this.maxBufferLength = -1\n    } else {\n      this.maxBufferLength = opts.maxBufferLength\n    }\n  }\n\n  reconnect () {\n    this.log('reconnecting..')\n  }\n\n  disconnect () {\n    this.log('discronnecting..')\n    this.connections = new Map()\n    this.isSynced = false\n    this.currentSyncTarget = null\n    this.whenSyncedListeners = []\n    return Promise.resolve()\n  }\n\n  onUserEvent (f) {\n    this.userEventListeners.push(f)\n  }\n\n  removeUserEventListener (f) {\n    this.userEventListeners = this.userEventListeners.filter(g => f !== g)\n  }\n\n  userLeft (user) {\n    if (this.connections.has(user)) {\n      this.log('%s: User left %s', this.y.userID, user)\n      this.connections.delete(user)\n      // check if isSynced event can be sent now\n      this._setSyncedWith(null)\n      for (var f of this.userEventListeners) {\n        f({\n          action: 'userLeft',\n          user: user\n        })\n      }\n    }\n  }\n\n  userJoined (user, role, auth) {\n    if (role == null) {\n      throw new Error('You must specify the role of the joined user!')\n    }\n    if (this.connections.has(user)) {\n      throw new Error('This user already joined!')\n    }\n    this.log('%s: User joined %s', this.y.userID, user)\n    this.connections.set(user, {\n      uid: user,\n      isSynced: false,\n      role: role,\n      processAfterAuth: [],\n      processAfterSync: [],\n      auth: auth || null,\n      receivedSyncStep2: false\n    })\n    let defer = {}\n    defer.promise = new Promise(function (resolve) { defer.resolve = resolve })\n    this.connections.get(user).syncStep2 = defer\n    for (var f of this.userEventListeners) {\n      f({\n        action: 'userJoined',\n        user: user,\n        role: role\n      })\n    }\n    this._syncWithUser(user)\n  }\n\n  // Execute a function _when_ we are connected.\n  // If not connected, wait until connected\n  whenSynced (f) {\n    if (this.isSynced) {\n      f()\n    } else {\n      this.whenSyncedListeners.push(f)\n    }\n  }\n\n  _syncWithUser (userID) {\n    if (this.role === 'slave') {\n      return // \"The current sync has not finished or this is controlled by a master!\"\n    }\n    sendSyncStep1(this, userID)\n  }\n\n  _fireIsSyncedListeners () {\n    if (!this.isSynced) {\n      this.isSynced = true\n      // It is safer to remove this!\n      // call whensynced listeners\n      for (var f of this.whenSyncedListeners) {\n        f()\n      }\n      this.whenSyncedListeners = []\n      this.y.emit('synced')\n    }\n  }\n\n  send (uid, buffer) {\n    const y = this.y\n    if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n      throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\\'t use this method to send custom messages')\n    }\n    this.log('User%s to User%s: Send \\'%y\\'', y.userID, uid, buffer)\n    this.logMessage('User%s to User%s: Send %Y', y.userID, uid, [y, buffer])\n  }\n\n  broadcast (buffer) {\n    const y = this.y\n    if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n      throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\\'t use this method to send custom messages')\n    }\n    this.log('User%s: Broadcast \\'%y\\'', y.userID, buffer)\n    this.logMessage('User%s: Broadcast: %Y', y.userID, [y, buffer])\n  }\n\n  /*\n    Buffer operations, and broadcast them when ready.\n  */\n  broadcastStruct (struct) {\n    const firstContent = this.broadcastBuffer.length === 0\n    if (firstContent) {\n      this.broadcastBuffer.writeVarString(this.y.room)\n      this.broadcastBuffer.writeVarString('update')\n      this.broadcastBufferSize = 0\n      this.broadcastBufferSizePos = this.broadcastBuffer.pos\n      this.broadcastBuffer.writeUint32(0)\n    }\n    this.broadcastBufferSize++\n    struct._toBinary(this.broadcastBuffer)\n    if (this.maxBufferLength > 0 && this.broadcastBuffer.length > this.maxBufferLength) {\n      // it is necessary to send the buffer now\n      // cache the buffer and check if server is responsive\n      const buffer = this.broadcastBuffer\n      buffer.setUint32(this.broadcastBufferSizePos, this.broadcastBufferSize)\n      this.broadcastBuffer = new BinaryEncoder()\n      this.whenRemoteResponsive().then(() => {\n        this.broadcast(buffer.createBuffer())\n      })\n    } else if (firstContent) {\n      // send the buffer when all transactions are finished\n      // (or buffer exceeds maxBufferLength)\n      setTimeout(() => {\n        if (this.broadcastBuffer.length > 0) {\n          const buffer = this.broadcastBuffer\n          buffer.setUint32(this.broadcastBufferSizePos, this.broadcastBufferSize)\n          this.broadcast(buffer.createBuffer())\n          this.broadcastBuffer = new BinaryEncoder()\n        }\n      }, 0)\n    }\n  }\n\n  /*\n   * Somehow check the responsiveness of the remote clients/server\n   * Default behavior:\n   *   Wait 100ms before broadcasting the next batch of operations\n   *\n   * Only used when maxBufferLength is set\n   *\n   */\n  whenRemoteResponsive () {\n    return new Promise(function (resolve) {\n      setTimeout(resolve, 100)\n    })\n  }\n\n  /*\n    You received a raw message, and you know that it is intended for Yjs. Then call this function.\n  */\n  receiveMessage (sender, buffer, skipAuth) {\n    const y = this.y\n    const userID = y.userID\n    skipAuth = skipAuth || false\n    if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n      return Promise.reject(new Error('Expected Message to be an ArrayBuffer or Uint8Array!'))\n    }\n    if (sender === userID) {\n      return Promise.resolve()\n    }\n    let decoder = new BinaryDecoder(buffer)\n    let encoder = new BinaryEncoder()\n    let roomname = decoder.readVarString() // read room name\n    encoder.writeVarString(roomname)\n    let messageType = decoder.readVarString()\n    let senderConn = this.connections.get(sender)\n    this.log('User%s from User%s: Receive \\'%s\\'', userID, sender, messageType)\n    this.logMessage('User%s from User%s: Receive %Y', userID, sender, [y, buffer])\n    if (senderConn == null && !skipAuth) {\n      throw new Error('Received message from unknown peer!')\n    }\n    if (messageType === 'sync step 1' || messageType === 'sync step 2') {\n      let auth = decoder.readVarUint()\n      if (senderConn.auth == null) {\n        senderConn.processAfterAuth.push([messageType, senderConn, decoder, encoder, sender])\n        // check auth\n        return this.checkAuth(auth, y, sender).then(authPermissions => {\n          if (senderConn.auth == null) {\n            senderConn.auth = authPermissions\n            y.emit('userAuthenticated', {\n              user: senderConn.uid,\n              auth: authPermissions\n            })\n          }\n          let messages = senderConn.processAfterAuth\n          senderConn.processAfterAuth = []\n\n          messages.forEach(m =>\n            this.computeMessage(m[0], m[1], m[2], m[3], m[4])\n          )\n        })\n      }\n    }\n    if ((skipAuth || senderConn.auth != null) && (messageType !== 'update' || senderConn.isSynced)) {\n      this.computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth)\n    } else {\n      senderConn.processAfterSync.push([messageType, senderConn, decoder, encoder, sender, false])\n    }\n  }\n\n  computeMessage (messageType, senderConn, decoder, encoder, sender, skipAuth) {\n    if (messageType === 'sync step 1' && (senderConn.auth === 'write' || senderConn.auth === 'read')) {\n      // cannot wait for sync step 1 to finish, because we may wait for sync step 2 in sync step 1 (->lock)\n      readSyncStep1(decoder, encoder, this.y, senderConn, sender)\n    } else {\n      const y = this.y\n      y.transact(function () {\n        if (messageType === 'sync step 2' && senderConn.auth === 'write') {\n          readSyncStep2(decoder, encoder, y, senderConn, sender)\n        } else if (messageType === 'update' && (skipAuth || senderConn.auth === 'write')) {\n          integrateRemoteStructs(decoder, encoder, y, senderConn, sender)\n        } else {\n          throw new Error('Unable to receive message')\n        }\n      }, true)\n    }\n  }\n\n  _setSyncedWith (user) {\n    if (user != null) {\n      const userConn = this.connections.get(user)\n      userConn.isSynced = true\n      const messages = userConn.processAfterSync\n      userConn.processAfterSync = []\n      messages.forEach(m => {\n        this.computeMessage(m[0], m[1], m[2], m[3], m[4])\n      })\n    }\n    const conns = Array.from(this.connections.values())\n    if (conns.length > 0 && conns.every(u => u.isSynced)) {\n      this._fireIsSyncedListeners()\n    }\n  }\n}\n","\nimport YXmlFragment from './YXmlFragment.js'\nimport YXmlElement from './YXmlElement.js'\n\nexport { default as YXmlFragment } from './YXmlFragment.js'\nexport { default as YXmlElement } from './YXmlElement.js'\nexport { default as YXmlText } from './YXmlText.js'\n\nYXmlFragment._YXmlElement = YXmlElement\n","import DeleteStore from './Store/DeleteStore.js'\nimport OperationStore from './Store/OperationStore.js'\nimport StateStore from './Store/StateStore.js'\nimport { generateUserID } from './Util/generateUserID.js'\nimport RootID from './Util/RootID.js'\nimport NamedEventHandler from './Util/NamedEventHandler.js'\nimport UndoManager from './Util/UndoManager.js'\n\nimport { messageToString, messageToRoomname } from './MessageHandler/messageToString.js'\n\nimport Connector from './Connector.js'\nimport Persistence from './Persistence.js'\nimport YArray from './Type/YArray.js'\nimport YMap from './Type/YMap.js'\nimport YText from './Type/YText.js'\nimport { YXmlFragment, YXmlElement, YXmlText } from './Type/y-xml/y-xml.js'\nimport BinaryDecoder from './Binary/Decoder.js'\nimport { getRelativePosition, fromRelativePosition } from './Util/relativePosition.js'\n\nimport debug from 'debug'\nimport Transaction from './Transaction.js'\n\nexport default class Y extends NamedEventHandler {\n  constructor (opts) {\n    super()\n    this._opts = opts\n    this.userID = opts._userID != null ? opts._userID : generateUserID()\n    this.share = {}\n    this.ds = new DeleteStore(this)\n    this.os = new OperationStore(this)\n    this.ss = new StateStore(this)\n    this.connector = new Y[opts.connector.name](this, opts.connector)\n    if (opts.persistence != null) {\n      this.persistence = new Y[opts.persistence.name](this, opts.persistence)\n      this.persistence.retrieveContent()\n    } else {\n      this.persistence = null\n    }\n    this.connected = true\n    this._missingStructs = new Map()\n    this._readyToIntegrate = []\n    this._transaction = null\n  }\n  _beforeChange () {}\n  transact (f, remote = false) {\n    let initialCall = this._transaction === null\n    if (initialCall) {\n      this._transaction = new Transaction(this)\n      this.emit('beforeTransaction', this, this._transaction, remote)\n    }\n    try {\n      f(this)\n    } catch (e) {\n      console.error(e)\n    }\n    if (initialCall) {\n      const transaction = this._transaction\n      this._transaction = null\n      // emit change events on changed types\n      transaction.changedTypes.forEach(function (subs, type) {\n        if (!type._deleted) {\n          type._callObserver(transaction, subs, remote)\n        }\n      })\n      transaction.changedParentTypes.forEach(function (events, type) {\n        if (!type._deleted) {\n          events = events\n            .filter(event =>\n              !event.target._deleted\n            )\n          events\n            .forEach(event => {\n              event.currentTarget = type\n            })\n          // we don't have to check for events.length\n          // because there is no way events is empty..\n          type._deepEventHandler.callEventListeners(transaction, events)\n        }\n      })\n      // when all changes & events are processed, emit afterTransaction event\n      this.emit('afterTransaction', this, transaction, remote)\n    }\n  }\n  // fake _start for root properties (y.set('name', type))\n  get _start () {\n    return null\n  }\n  set _start (start) {\n    return null\n  }\n  get room () {\n    return this._opts.connector.room\n  }\n  define (name, TypeConstructor) {\n    let id = new RootID(name, TypeConstructor)\n    let type = this.os.get(id)\n    if (type === null) {\n      type = new TypeConstructor()\n      type._id = id\n      type._parent = this\n      type._integrate(this)\n      if (this.share[name] !== undefined) {\n        throw new Error('Type is already defined with a different constructor!')\n      }\n    }\n    if (this.share[name] === undefined) {\n      this.share[name] = type\n    }\n    return type\n  }\n  get (name) {\n    return this.share[name]\n  }\n  disconnect () {\n    if (this.connected) {\n      this.connected = false\n      return this.connector.disconnect()\n    } else {\n      return Promise.resolve()\n    }\n  }\n  reconnect () {\n    if (!this.connected) {\n      this.connected = true\n      return this.connector.reconnect()\n    } else {\n      return Promise.resolve()\n    }\n  }\n  destroy () {\n    this.share = null\n    if (this.connector.destroy != null) {\n      this.connector.destroy()\n    } else {\n      this.connector.disconnect()\n    }\n    this.os = null\n    this.ds = null\n    this.ss = null\n  }\n  whenSynced () {\n    return new Promise(resolve => {\n      this.once('synced', () => {\n        resolve()\n      })\n    })\n  }\n}\n\nY.extend = function extendYjs () {\n  for (var i = 0; i < arguments.length; i++) {\n    var f = arguments[i]\n    if (typeof f === 'function') {\n      f(Y)\n    } else {\n      throw new Error('Expected a function!')\n    }\n  }\n}\n\n// TODO: The following assignments should be moved to yjs-dist\nY.AbstractConnector = Connector\nY.Persisence = Persistence\nY.Array = YArray\nY.Map = YMap\nY.Text = YText\nY.XmlElement = YXmlElement\nY.XmlFragment = YXmlFragment\nY.XmlText = YXmlText\n\nY.utils = {\n  BinaryDecoder,\n  UndoManager,\n  getRelativePosition,\n  fromRelativePosition\n}\n\nY.debug = debug\ndebug.formatters.Y = messageToString\ndebug.formatters.y = messageToRoomname\n"],"names":["_integrateRemoteStructHelper","y","struct","id","_id","undefined","_integrate","ss","getState","user","clock","msu","_missingStructs","get","finalClock","_length","missingStructs","forEach","missing","decoder","missingDef","oldPos","pos","_fromBinary","length","_readyToIntegrate","push","delete","stringifyStructs","strBuilder","len","readUint32","i","reference","readVarUint","Constr","getStruct","logMessage","_logString","map","logID","join","integrateRemoteStructs","encoder","decoderPos","shift","_decoder","BinaryDecoder","uint8arr","missingEntry","MissingEntry","m","has","set","Map","readStateSet","ssLength","writeStateSet","lenPosition","writeUint32","state","writeVarUint","setUint32","writeDeleteSet","currentUser","currentLength","lastLenPos","numberOfUsers","laterDSLenPus","ds","iterate","n","gc","writeUint8","readDeleteSet","dsLength","dv","dvLength","j","from","readUint8","d","deletions","ID","Number","MAX_VALUE","diff","Math","min","del","stringifySyncStep1","auth","readVarString","protocolVersion","ssBuilder","sendSyncStep1","connector","syncUser","BinaryEncoder","writeVarString","room","authInfo","send","createBuffer","writeStructs","lenPos","keys","RootFakeUserID","os","_toBinary","readSyncStep1","senderConn","sender","warn","destroy","uid","receivedSyncStep2","role","stringifySyncStep2","len2","to","readSyncStep2","_setSyncedWith","messageToString","buffer","type","messageToRoomname","RootID","name","constructor","Y","Error","deleteItemRange","range","createDelete","_forwardAppliedStructs","item","getItemCleanStart","_deleted","_splitAt","_delete","itemLen","node","findNode","val","equals","nodeVal","nodeLen","next","transactionTypeChanged","sub","_transaction","newTypes","changedTypes","subs","Set","add","splitHelper","a","b","aID","_origin","_left","_right","_right_origin","_parent","_parentSub","foundOrigins","o","put","integrateChildren","start","right","defaultDomFilter","attributes","iterateUntilUndeleted","_insertNodeHelper","yxml","prevExpectedNode","child","insertedNodes","insertDomElementsAfter","applyChangesFromDom","dom","_yxml","_y","knownChildren","Array","prototype","call","childNodes","filter","childType","expectedNode","_start","domCnt","childYXml","this","reflectChangesOnDom","events","_document","_mutualExclude","event","target","_dom","YXmlText","nodeValue","toString","attributesChanged","value","getAttribute","attributeName","removeAttribute","setAttribute","childListChanged","fragment","createDocumentFragment","t","appendChild","getDom","lastChild","removeChild","getRelativePosition","offset","fromRelativePosition","rpos","findNodeWithUpperBound","parent","afterTransactionSelectionFixer","transaction","remote","relativeSelection","fromY","toY","shouldUpdate","anchorNode","browserSelection","anchorOffset","focusNode","focusOffset","sel","setBaseAndExtent","diff_main","text1","text2","cursor_pos","DIFF_EQUAL","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","diffs","diff_compute_","unshift","fix_cursor","fix_emoji","DIFF_INSERT","DIFF_DELETE","longtext","shorttext","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_bisect_","text1_length","text2_length","max_d","ceil","v_offset","v_length","v1","v2","x","delta","front","k1start","k1end","k2start","k2end","k1","x1","k1_offset","y1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","text1a","text2a","text1b","text2b","diffsb","pointermin","pointermax","pointermid","pointerstart","floor","pointerend","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","diff_cleanupMerge","pointer","count_delete","count_insert","text_delete","text_insert","splice","pop","changes","cursor_normalize_diff","current_pos","next_pos","slice","split_pos","d_left","d_right","norm","ndiffs","cursor_pointer","d_next","merge_tuples","suffix","compact","starts_with_pair_end","str","charCodeAt","fixed_diffs","left_d","right_d","domToYXml","doms","types","_unbindFromDom","_domFilter","nodeType","TEXT_NODE","ELEMENT_NODE","YXmlFragment","_YXmlElement","enableSmartScrolling","_scrollElement","addStruct","structConstructor","structs","getReference","typeConstructor","references","generateUserID","crypto","getRandomValue","arr","Uint32Array","getRandomValues","randomBytes","buf","random","isStructInScope","scope","applyReverseOperation","reverseBuffer","performedUndo","transact","undoOp","fromState","getItemCleanEnd","toState","op","deletedStructs","userID","_copy","parse","String","match","exec","parseFloat","toLowerCase","h","s","fmtShort","ms","round","fmtLong","plural","extendPersistence","AbstractPersistence","opts","saveOperationsBuffer","log","debug","binary","options","ops","Struct","encode","N","color","tree","newParent","newRight","left","root","p","newLeft","Tree","nextID","clone","findWithLowerBound","prevID","findWithUpperBound","lessThan","prev","findNodeWithLowerBound","f","findSmallestNode","isFakeChild","blacken","isBlack","isRed","_fixDelete","sibling","redden","rotateLeft","rotateRight","v","_fixInsert","uncle","getUncle","grandparent","DSNode","DeleteStore","deletes","table","nId","findNext","markDeleted","_next","fromCodePoint","defineProperty","object","$defineProperty","Object","result","error","stringFromCharCode","fromCharCode","_","highSurrogate","lowSurrogate","codeUnits","index","arguments","codePoint","isFinite","RangeError","apply","codePointAt","position","TypeError","string","size","second","first","module","require","UTF8","bytes","byteOffset","byteLength","getStringFromBytes","e","theByte","charLength","charCode","mask","getCharLength","parseInt","strict","chars","getCharCode","neededBytes","getBytesForCharCode","Infinity","setBytesFromCharCode","ArrayBuffer","Uint8Array","Buffer","newPos","uint","num","r","utf8","rid","data","setBytesFromString","Delete","_target","targetID","readID","_targetID","getItem","writeID","broadcastStruct","persistence","saveOperations","Transaction","beforeState","changedParentTypes","Item","selfID","userState","getNextID","setState","_beforeChange","_map","conflictingItems","itemsBeforeOrigin","clear","parentSub","pmap","info","_lastId","JSON","stringify","originID","origin","rightID","parentID","EventHandler","eventListeners","g","Type","_eventHandler","_deepEventHandler","path","callEventListeners","undeleteChildren","copy","key","deleted","prevUndeleted","_item","addEventListener","removeEventListener","values","ItemJSON","_content","ctnt","parsed","encoded","content","ItemString","YEvent","currentTarget","YArrayEvent","yarray","YArray","parentSubs","_callEventHandler","c","toJSON","res","contentLen","Symbol","iterator","_itemElement","_count","_this4","count","diffDel","_transact","_this5","prevJsonIns","rightLen","splitDiff","insertAfter","YMapEvent","ymap","keysChanged","YMap","_this3","old","YText","text","_this2","arg1","initialText","_domObserver","_domObserverListener","_setDom","scrollElement","document","createTextNode","disconnect","beforeTransactionSelectionFixer","getSelection","YXmlEvent","INSERT","DELETE","EQUAL","YXmlTreeWalker","_filter","_root","_currentNode","_firstCall","done","token","_this","takeRecords","query","toUpperCase","element","nodeName","setDomFilter","xml","insert","innerHTML","insertBefore","_bindToDom","on","observeDeep","MutationObserver","diffChildren","mutation","observe","YXmlElement","arg2","attrNames","attrName","attrValue","insertDomElements","attrs","getAttributes","stringBuilder","sort","keysLen","toLocaleLowerCase","obj","createElement","OperationStore","items","find","itemID","ins","insID","StateStore","entries","NamedEventHandler","_eventListener","listeners","_getListener","once","listener","remove","args","ReverseOperation","created","Date","UndoManager","captureTimeout","_undoBuffer","_redoBuffer","_scope","_undoing","_redoing","reverseOperation","lastUndoOp","performedRedo","isNaN","long","selectColor","namespace","hash","exports","colors","abs","createDebug","enabled","self","curr","prevTime","coerce","replace","format","formatter","formatters","formatArgs","console","bind","useColors","init","enable","namespaces","save","split","skips","RegExp","substr","names","disable","test","stack","message","require$$0","window","process","documentElement","style","WebkitAppearance","firebug","exception","navigator","userAgent","$1","humanize","lastC","Function","storage","removeItem","load","env","DEBUG","chrome","local","localStorage","err","AbstractConnector","forwardAppliedOperations","connections","isSynced","userEventListeners","whenSyncedListeners","currentSyncTarget","broadcastBuffer","broadcastBufferSize","checkAuth","Promise","resolve","maxBufferLength","defer","promise","syncStep2","_syncWithUser","emit","firstContent","broadcastBufferSizePos","whenRemoteResponsive","then","broadcast","skipAuth","reject","roomname","messageType","processAfterAuth","authPermissions","messages","computeMessage","processAfterSync","userConn","conns","every","u","_fireIsSyncedListeners","_opts","_userID","share","retrieveContent","connected","initialCall","_callObserver","TypeConstructor","reconnect","extend","Connector","Persisence","Persistence","Text","XmlElement","XmlFragment","XmlText","utils"],"mappings":"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"}