{"version":3,"file":"y.js","sources":["src/MessageHandler/integrateRemoteStructs.js","src/MessageHandler/stateSet.js","src/MessageHandler/deleteSet.js","src/MessageHandler/syncStep1.js","src/MessageHandler/syncStep2.js","src/MessageHandler/messageToString.js","src/Struct/Delete.js","src/Transaction.js","src/Struct/Item.js","src/Struct/Type.js","src/Type/y-xml/utils.js","src/Util/relativePosition.js","src/Type/y-xml/selection.js","src/Util/simpleDiff.js","src/Type/y-xml/YXmlFragment.js","src/Type/y-xml/hooks.js","src/Util/structReferences.js","src/Util/generateUserID.js","src/Util/UndoManager.js","node_modules/ms/index.js","src/MessageHandler/binaryEncode.js","src/Util/mutualExclude.js","src/Persistence.js","src/Binding/TextareaBinding.js","src/Util/Tree.js","src/Util/ID.js","src/Store/DeleteStore.js","src/Binary/Decoder.js","src/Binary/Encoder.js","src/Util/EventHandler.js","src/Struct/ItemJSON.js","src/Struct/ItemString.js","src/Util/YEvent.js","src/Type/YArray.js","src/Type/YMap.js","src/Type/YText.js","src/Type/y-xml/YXmlEvent.js","src/Type/y-xml/YXmlElement.js","src/Type/y-xml/YXmlHook.js","src/Type/y-xml/YXmlText.js","src/Type/y-xml/y-xml.js","src/Util/RootID.js","src/Store/OperationStore.js","src/Store/StateStore.js","src/Util/NamedEventHandler.js","node_modules/debug/src/debug.js","node_modules/debug/src/browser.js","src/Connector.js","src/Binding/Binding.js","src/Y.js"],"sourcesContent":["import { getStruct } from '../Util/structReferences.js'\nimport BinaryDecoder from '../Binary/Decoder.js'\nimport { logID } from './messageToString.js'\n\nclass MissingEntry {\n  constructor (decoder, missing, struct) {\n    this.decoder = decoder\n    this.missing = missing.length\n    this.struct = struct\n  }\n}\n\n/**\n * Integrate remote struct\n * When a remote struct is integrated, other structs might be ready to ready to\n * integrate.\n */\nfunction _integrateRemoteStructHelper (y, struct) {\n  const id = struct._id\n  if (id === undefined) {\n    struct._integrate(y)\n  } else {\n    if (y.ss.getState(id.user) > id.clock) {\n      return\n    }\n    struct._integrate(y)\n    let msu = y._missingStructs.get(id.user)\n    if (msu != null) {\n      let clock = id.clock\n      const finalClock = clock + struct._length\n      for (;clock < finalClock; clock++) {\n        const missingStructs = msu.get(clock)\n        if (missingStructs !== undefined) {\n          missingStructs.forEach(missingDef => {\n            missingDef.missing--\n            if (missingDef.missing === 0) {\n              const decoder = missingDef.decoder\n              let oldPos = decoder.pos\n              let missing = missingDef.struct._fromBinary(y, decoder)\n              decoder.pos = oldPos\n              if (missing.length === 0) {\n                y._readyToIntegrate.push(missingDef.struct)\n              }\n            }\n          })\n          msu.delete(clock)\n        }\n      }\n    }\n  }\n}\n\nexport function stringifyStructs (y, decoder, strBuilder) {\n  const len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let reference = decoder.readVarUint()\n    let Constr = getStruct(reference)\n    let struct = new Constr()\n    let missing = struct._fromBinary(y, decoder)\n    let logMessage = '  ' + struct._logString()\n    if (missing.length > 0) {\n      logMessage += ' .. missing: ' + missing.map(logID).join(', ')\n    }\n    strBuilder.push(logMessage)\n  }\n}\n\nexport function integrateRemoteStructs (y, decoder) {\n  const len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let reference = decoder.readVarUint()\n    let Constr = getStruct(reference)\n    let struct = new Constr()\n    let decoderPos = decoder.pos\n    let missing = struct._fromBinary(y, decoder)\n    if (missing.length === 0) {\n      while (struct != null) {\n        _integrateRemoteStructHelper(y, struct)\n        struct = y._readyToIntegrate.shift()\n      }\n    } else {\n      let _decoder = new BinaryDecoder(decoder.uint8arr)\n      _decoder.pos = decoderPos\n      let missingEntry = new MissingEntry(_decoder, missing, struct)\n      let missingStructs = y._missingStructs\n      for (let i = missing.length - 1; i >= 0; i--) {\n        let m = missing[i]\n        if (!missingStructs.has(m.user)) {\n          missingStructs.set(m.user, new Map())\n        }\n        let msu = missingStructs.get(m.user)\n        if (!msu.has(m.clock)) {\n          msu.set(m.clock, [])\n        }\n        let mArray = msu = msu.get(m.clock)\n        mArray.push(missingEntry)\n      }\n    }\n  }\n}\n","\nexport function readStateSet (decoder) {\n  let ss = new Map()\n  let ssLength = decoder.readUint32()\n  for (let i = 0; i < ssLength; i++) {\n    let user = decoder.readVarUint()\n    let clock = decoder.readVarUint()\n    ss.set(user, clock)\n  }\n  return ss\n}\n\nexport function writeStateSet (y, encoder) {\n  let lenPosition = encoder.pos\n  let len = 0\n  encoder.writeUint32(0)\n  for (let [user, clock] of y.ss.state) {\n    encoder.writeVarUint(user)\n    encoder.writeVarUint(clock)\n    len++\n  }\n  encoder.setUint32(lenPosition, len)\n}\n","import { deleteItemRange } from '../Struct/Delete.js'\nimport ID from '../Util/ID.js'\n\nexport function stringifyDeleteSet (y, decoder, strBuilder) {\n  let dsLength = decoder.readUint32()\n  for (let i = 0; i < dsLength; i++) {\n    let user = decoder.readVarUint()\n    strBuilder.push(' -' + user + ':')\n    let dvLength = decoder.readVarUint()\n    for (let j = 0; j < dvLength; j++) {\n      let from = decoder.readVarUint()\n      let len = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      strBuilder.push(`clock: ${from}, length: ${len}, gc: ${gc}`)\n    }\n  }\n  return strBuilder\n}\n\nexport function writeDeleteSet (y, encoder) {\n  let currentUser = null\n  let currentLength\n  let lastLenPos\n\n  let numberOfUsers = 0\n  let laterDSLenPus = encoder.pos\n  encoder.writeUint32(0)\n\n  y.ds.iterate(null, null, function (n) {\n    var user = n._id.user\n    var clock = n._id.clock\n    var len = n.len\n    var gc = n.gc\n    if (currentUser !== user) {\n      numberOfUsers++\n      // a new user was found\n      if (currentUser !== null) { // happens on first iteration\n        encoder.setUint32(lastLenPos, currentLength)\n      }\n      currentUser = user\n      encoder.writeVarUint(user)\n      // pseudo-fill pos\n      lastLenPos = encoder.pos\n      encoder.writeUint32(0)\n      currentLength = 0\n    }\n    encoder.writeVarUint(clock)\n    encoder.writeVarUint(len)\n    encoder.writeUint8(gc ? 1 : 0)\n    currentLength++\n  })\n  if (currentUser !== null) { // happens on first iteration\n    encoder.setUint32(lastLenPos, currentLength)\n  }\n  encoder.setUint32(laterDSLenPus, numberOfUsers)\n}\n\nexport function readDeleteSet (y, decoder) {\n  let dsLength = decoder.readUint32()\n  for (let i = 0; i < dsLength; i++) {\n    let user = decoder.readVarUint()\n    let dv = []\n    let dvLength = decoder.readUint32()\n    for (let j = 0; j < dvLength; j++) {\n      let from = decoder.readVarUint()\n      let len = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      dv.push([from, len, gc])\n    }\n    if (dvLength > 0) {\n      let pos = 0\n      let d = dv[pos]\n      let deletions = []\n      y.ds.iterate(new ID(user, 0), new ID(user, Number.MAX_VALUE), function (n) {\n        // cases:\n        // 1. d deletes something to the right of n\n        //  => go to next n (break)\n        // 2. d deletes something to the left of n\n        //  => create deletions\n        //  => reset d accordingly\n        //  *)=> if d doesn't delete anything anymore, go to next d (continue)\n        // 3. not 2) and d deletes something that also n deletes\n        //  => reset d so that it doesn't contain n's deletion\n        //  *)=> if d does not delete anything anymore, go to next d (continue)\n        while (d != null) {\n          var diff = 0 // describe the diff of length in 1) and 2)\n          if (n._id.clock + n.len <= d[0]) {\n            // 1)\n            break\n          } else if (d[0] < n._id.clock) {\n            // 2)\n            // delete maximum the len of d\n            // else delete as much as possible\n            diff = Math.min(n._id.clock - d[0], d[1])\n            // deleteItemRange(y, user, d[0], diff)\n            deletions.push([user, d[0], diff])\n          } else {\n            // 3)\n            diff = n._id.clock + n.len - d[0] // never null (see 1)\n            if (d[2] && !n.gc) {\n              // d marks as gc'd but n does not\n              // then delete either way\n              // deleteItemRange(y, user, d[0], Math.min(diff, d[1]))\n              deletions.push([user, d[0], Math.min(diff, d[1])])\n            }\n          }\n          if (d[1] <= diff) {\n            // d doesn't delete anything anymore\n            d = dv[++pos]\n          } else {\n            d[0] = d[0] + diff // reset pos\n            d[1] = d[1] - diff // reset length\n          }\n        }\n      })\n      // TODO: It would be more performant to apply the deletes in the above loop\n      // Adapt the Tree implementation to support delete while iterating\n      for (let i = deletions.length - 1; i >= 0; i--) {\n        const del = deletions[i]\n        deleteItemRange(y, del[0], del[1], del[2])\n      }\n      // for the rest.. just apply it\n      for (; pos < dv.length; pos++) {\n        d = dv[pos]\n        deleteItemRange(y, user, d[0], d[1])\n        // deletions.push([user, d[0], d[1], d[2]])\n      }\n    }\n  }\n}\n","import BinaryEncoder from '../Binary/Encoder.js'\nimport { readStateSet, writeStateSet } from './stateSet.js'\nimport { writeDeleteSet } from './deleteSet.js'\nimport ID from '../Util/ID.js'\nimport { RootFakeUserID } from '../Util/RootID.js'\n\nexport function stringifySyncStep1 (y, decoder, strBuilder) {\n  let auth = decoder.readVarString()\n  let protocolVersion = decoder.readVarUint()\n  strBuilder.push(`  - auth: \"${auth}\"`)\n  strBuilder.push(`  - protocolVersion: ${protocolVersion}`)\n  // write SS\n  let ssBuilder = []\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let user = decoder.readVarUint()\n    let clock = decoder.readVarUint()\n    ssBuilder.push(`(${user}:${clock})`)\n  }\n  strBuilder.push('  == SS: ' + ssBuilder.join(','))\n}\n\nexport function sendSyncStep1 (connector, syncUser) {\n  let encoder = new BinaryEncoder()\n  encoder.writeVarString(connector.y.room)\n  encoder.writeVarString('sync step 1')\n  encoder.writeVarString(connector.authInfo || '')\n  encoder.writeVarUint(connector.protocolVersion)\n  writeStateSet(connector.y, encoder)\n  connector.send(syncUser, encoder.createBuffer())\n}\n\nexport function writeStructs (y, encoder, ss) {\n  const lenPos = encoder.pos\n  encoder.writeUint32(0)\n  let len = 0\n  for (let user of y.ss.state.keys()) {\n    let clock = ss.get(user) || 0\n    if (user !== RootFakeUserID) {\n      y.os.iterate(new ID(user, clock), new ID(user, Number.MAX_VALUE), function (struct) {\n        struct._toBinary(encoder)\n        len++\n      })\n    }\n  }\n  encoder.setUint32(lenPos, len)\n}\n\nexport function readSyncStep1 (decoder, encoder, y, senderConn, sender) {\n  let protocolVersion = decoder.readVarUint()\n  // check protocol version\n  if (protocolVersion !== y.connector.protocolVersion) {\n    console.warn(\n      `You tried to sync with a Yjs instance that has a different protocol version\n      (You: ${protocolVersion}, Client: ${protocolVersion}).\n      `)\n    y.destroy()\n  }\n  // write sync step 2\n  encoder.writeVarString('sync step 2')\n  encoder.writeVarString(y.connector.authInfo || '')\n  const ss = readStateSet(decoder)\n  writeStructs(y, encoder, ss)\n  writeDeleteSet(y, encoder)\n  y.connector.send(senderConn.uid, encoder.createBuffer())\n  senderConn.receivedSyncStep2 = true\n  if (y.connector.role === 'slave') {\n    sendSyncStep1(y.connector, sender)\n  }\n}\n","import { stringifyStructs, integrateRemoteStructs } from './integrateRemoteStructs.js'\nimport { readDeleteSet } from './deleteSet.js'\n\nexport function stringifySyncStep2 (y, decoder, strBuilder) {\n  strBuilder.push('     - auth: ' + decoder.readVarString())\n  strBuilder.push('  == OS:')\n  stringifyStructs(y, decoder, strBuilder)\n  // write DS to string\n  strBuilder.push('  == DS:')\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let user = decoder.readVarUint()\n    strBuilder.push(`    User: ${user}: `)\n    let len2 = decoder.readUint32()\n    for (let j = 0; j < len2; j++) {\n      let from = decoder.readVarUint()\n      let to = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      strBuilder.push(`[${from}, ${to}, ${gc}]`)\n    }\n  }\n}\n\nexport function readSyncStep2 (decoder, encoder, y, senderConn, sender) {\n  integrateRemoteStructs(y, decoder)\n  readDeleteSet(y, decoder)\n  y.connector._setSyncedWith(sender)\n}\n","import BinaryDecoder from '../Binary/Decoder.js'\nimport { stringifyStructs } from './integrateRemoteStructs.js'\nimport { stringifySyncStep1 } from './syncStep1.js'\nimport { stringifySyncStep2 } from './syncStep2.js'\nimport ID from '../Util/ID.js'\nimport RootID from '../Util/RootID.js'\nimport Y from '../Y.js'\n\nexport function messageToString ([y, buffer]) {\n  let decoder = new BinaryDecoder(buffer)\n  decoder.readVarString() // read roomname\n  let type = decoder.readVarString()\n  let strBuilder = []\n  strBuilder.push('\\n === ' + type + ' ===')\n  if (type === 'update') {\n    stringifyStructs(y, decoder, strBuilder)\n  } else if (type === 'sync step 1') {\n    stringifySyncStep1(y, decoder, strBuilder)\n  } else if (type === 'sync step 2') {\n    stringifySyncStep2(y, decoder, strBuilder)\n  } else {\n    strBuilder.push('-- Unknown message type - probably an encoding issue!!!')\n  }\n  return strBuilder.join('\\n')\n}\n\nexport function messageToRoomname (buffer) {\n  let decoder = new BinaryDecoder(buffer)\n  decoder.readVarString() // roomname\n  return decoder.readVarString() // messageType\n}\n\nexport function logID (id) {\n  if (id !== null && id._id != null) {\n    id = id._id\n  }\n  if (id === null) {\n    return '()'\n  } else if (id instanceof ID) {\n    return `(${id.user},${id.clock})`\n  } else if (id instanceof RootID) {\n    return `(${id.name},${id.type})`\n  } else if (id.constructor === Y) {\n    return `y`\n  } else {\n    throw new Error('This is not a valid ID!')\n  }\n}\n","import { getReference } from '../Util/structReferences.js'\nimport ID from '../Util/ID.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\n/**\n * Delete all items in an ID-range\n * TODO: implement getItemCleanStartNode for better performance (only one lookup)\n */\nexport function deleteItemRange (y, user, clock, range) {\n  const createDelete = y.connector !== null && y.connector._forwardAppliedStructs\n  let item = y.os.getItemCleanStart(new ID(user, clock))\n  if (item !== null) {\n    if (!item._deleted) {\n      item._splitAt(y, range)\n      item._delete(y, createDelete)\n    }\n    let itemLen = item._length\n    range -= itemLen\n    clock += itemLen\n    if (range > 0) {\n      let node = y.os.findNode(new ID(user, clock))\n      while (node !== null && range > 0 && node.val._id.equals(new ID(user, clock))) {\n        const nodeVal = node.val\n        if (!nodeVal._deleted) {\n          nodeVal._splitAt(y, range)\n          nodeVal._delete(y, createDelete)\n        }\n        const nodeLen = nodeVal._length\n        range -= nodeLen\n        clock += nodeLen\n        node = node.next()\n      }\n    }\n  }\n}\n\n/**\n * Delete is not a real struct. It will not be saved in OS\n */\nexport default class Delete {\n  constructor () {\n    this._target = null\n    this._length = null\n  }\n  _fromBinary (y, decoder) {\n    // TODO: set target, and add it to missing if not found\n    // There is an edge case in p2p networks!\n    const targetID = decoder.readID()\n    this._targetID = targetID\n    this._length = decoder.readVarUint()\n    if (y.os.getItem(targetID) === null) {\n      return [targetID]\n    } else {\n      return []\n    }\n  }\n  _toBinary (encoder) {\n    encoder.writeUint8(getReference(this.constructor))\n    encoder.writeID(this._targetID)\n    encoder.writeVarUint(this._length)\n  }\n  /**\n   * - If created remotely (a remote user deleted something),\n   *   this Delete is applied to all structs in id-range.\n   * - If created lokally (e.g. when y-array deletes a range of elements),\n   *   this struct is broadcasted only (it is already executed)\n   */\n  _integrate (y, locallyCreated = false) {\n    if (!locallyCreated) {\n      // from remote\n      const id = this._targetID\n      deleteItemRange(y, id.user, id.clock, this._length)\n    } else if (y.connector !== null) {\n      // from local\n      y.connector.broadcastStruct(this)\n    }\n    if (y.persistence !== null) {\n      y.persistence.saveStruct(y, this)\n    }\n  }\n  _logString () {\n    return `Delete - target: ${logID(this._targetID)}, len: ${this._length}`\n  }\n}\n","\nexport default class Transaction {\n  constructor (y) {\n    this.y = y\n    // types added during transaction\n    this.newTypes = new Set()\n    // changed types (does not include new types)\n    // maps from type to parentSubs (item._parentSub = null for array elements)\n    this.changedTypes = new Map()\n    this.deletedStructs = new Set()\n    this.beforeState = new Map()\n    this.changedParentTypes = new Map()\n  }\n}\n\nexport function transactionTypeChanged (y, type, sub) {\n  if (type !== y && !type._deleted && !y._transaction.newTypes.has(type)) {\n    const changedTypes = y._transaction.changedTypes\n    let subs = changedTypes.get(type)\n    if (subs === undefined) {\n      // create if it doesn't exist yet\n      subs = new Set()\n      changedTypes.set(type, subs)\n    }\n    subs.add(sub)\n  }\n}\n","import { getReference } from '../Util/structReferences.js'\nimport ID from '../Util/ID.js'\nimport { RootFakeUserID } from '../Util/RootID.js'\nimport Delete from './Delete.js'\nimport { transactionTypeChanged } from '../Transaction.js'\n\n/**\n * Helper utility to split an Item (see _splitAt)\n * - copy all properties from a to b\n * - connect a to b\n * - assigns the correct _id\n * - save b to os\n */\nexport function splitHelper (y, a, b, diff) {\n  const aID = a._id\n  b._id = new ID(aID.user, aID.clock + diff)\n  b._origin = a\n  b._left = a\n  b._right = a._right\n  if (b._right !== null) {\n    b._right._left = b\n  }\n  b._right_origin = a._right_origin\n  // do not set a._right_origin, as this will lead to problems when syncing\n  a._right = b\n  b._parent = a._parent\n  b._parentSub = a._parentSub\n  b._deleted = a._deleted\n  // now search all relevant items to the right and update origin\n  // if origin is not it foundOrigins, we don't have to search any longer\n  let foundOrigins = new Set()\n  foundOrigins.add(a)\n  let o = b._right\n  while (o !== null && foundOrigins.has(o._origin)) {\n    if (o._origin === a) {\n      o._origin = b\n    }\n    foundOrigins.add(o)\n    o = o._right\n  }\n  y.os.put(b)\n}\n\nexport default class Item {\n  constructor () {\n    this._id = null\n    this._origin = null\n    this._left = null\n    this._right = null\n    this._right_origin = null\n    this._parent = null\n    this._parentSub = null\n    this._deleted = false\n    this._redone = null\n  }\n  /**\n   * Create a operation with the same effect (without position effect)\n   */\n  _copy () {\n    return new this.constructor()\n  }\n  /**\n   * Redo the effect of this operation.\n   */\n  _redo (y) {\n    if (this._redone !== null) {\n      return this._redone\n    }\n    let struct = this._copy()\n    let left = this._left\n    let right = this\n    let parent = this._parent\n    // make sure that parent is redone\n    if (parent._deleted === true && parent._redone === null) {\n      parent._redo(y)\n    }\n    if (parent._redone !== null) {\n      parent = parent._redone\n      // find next cloned items\n      while (left !== null && left._redone === null) {\n        left = left._left\n      }\n      if (left !== null) {\n        left = left._redone\n      }\n      while (right !== null && right._redone === null) {\n        right = right._right\n      }\n      if (right !== null) {\n        right = right._redone\n      }\n    }\n    struct._origin = left\n    struct._left = left\n    struct._right = right\n    struct._right_origin = right\n    struct._parent = parent\n    struct._parentSub = this._parentSub\n    struct._integrate(y)\n    this._redone = struct\n    return struct\n  }\n\n  get _lastId () {\n    return new ID(this._id.user, this._id.clock + this._length - 1)\n  }\n  get _length () {\n    return 1\n  }\n  /**\n   * Splits this struct so that another struct can be inserted in-between.\n   * This must be overwritten if _length > 1\n   * Returns right part after split\n   * - diff === 0 => this\n   * - diff === length => this._right\n   * - otherwise => split _content and return right part of split\n   * (see ItemJSON/ItemString for implementation)\n   */\n  _splitAt (y, diff) {\n    if (diff === 0) {\n      return this\n    }\n    return this._right\n  }\n  _delete (y, createDelete = true) {\n    if (!this._deleted) {\n      this._deleted = true\n      y.ds.markDeleted(this._id, this._length)\n      let del = new Delete()\n      del._targetID = this._id\n      del._length = this._length\n      if (createDelete) {\n        // broadcast and persists Delete\n        del._integrate(y, true)\n      } else if (y.persistence !== null) {\n        // only persist Delete\n        y.persistence.saveStruct(y, del)\n      }\n      transactionTypeChanged(y, this._parent, this._parentSub)\n      y._transaction.deletedStructs.add(this)\n    }\n  }\n  /**\n   * This is called right before this struct receives any children.\n   * It can be overwritten to apply pending changes before applying remote changes\n   */\n  _beforeChange () {\n    // nop\n  }\n  /*\n   * - Integrate the struct so that other types/structs can see it\n   * - Add this struct to y.os\n   * - Check if this is struct deleted\n   */\n  _integrate (y) {\n    y._transaction.newTypes.add(this)\n    const parent = this._parent\n    const selfID = this._id\n    const user = selfID === null ? y.userID : selfID.user\n    const userState = y.ss.getState(user)\n    if (selfID === null) {\n      this._id = y.ss.getNextID(this._length)\n    } else if (selfID.user === RootFakeUserID) {\n      // nop\n    } else if (selfID.clock < userState) {\n      // already applied..\n      return []\n    } else if (selfID.clock === userState) {\n      y.ss.setState(selfID.user, userState + this._length)\n    } else {\n      // missing content from user\n      throw new Error('Can not apply yet!')\n    }\n    if (!parent._deleted && !y._transaction.changedTypes.has(parent) && !y._transaction.newTypes.has(parent)) {\n      // this is the first time parent is updated\n      // or this types is new\n      this._parent._beforeChange()\n    }\n    /*\n    # $this has to find a unique position between origin and the next known character\n    # case 1: $origin equals $o.origin: the $creator parameter decides if left or right\n    #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4\n    #         o2,o3 and o4 origin is 1 (the position of o2)\n    #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator\n    #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex\n    #         therefore $this would be always to the right of o3\n    # case 2: $origin < $o.origin\n    #         if current $this insert_position > $o origin: $this ins\n    #         else $insert_position will not change\n    #         (maybe we encounter case 1 later, then this will be to the right of $o)\n    # case 3: $origin > $o.origin\n    #         $this insert_position is to the left of $o (forever!)\n    */\n    // handle conflicts\n    let o\n    // set o to the first conflicting item\n    if (this._left !== null) {\n      o = this._left._right\n    } else if (this._parentSub !== null) {\n      o = this._parent._map.get(this._parentSub) || null\n    } else {\n      o = this._parent._start\n    }\n    let conflictingItems = new Set()\n    let itemsBeforeOrigin = new Set()\n    // Let c in conflictingItems, b in itemsBeforeOrigin\n    // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n    // Note that conflictingItems is a subset of itemsBeforeOrigin\n    while (o !== null && o !== this._right) {\n      itemsBeforeOrigin.add(o)\n      conflictingItems.add(o)\n      if (this._origin === o._origin) {\n        // case 1\n        if (o._id.user < this._id.user) {\n          this._left = o\n          conflictingItems.clear()\n        }\n      } else if (itemsBeforeOrigin.has(o._origin)) {\n        // case 2\n        if (!conflictingItems.has(o._origin)) {\n          this._left = o\n          conflictingItems.clear()\n        }\n      } else {\n        break\n      }\n      // TODO: try to use right_origin instead.\n      // Then you could basically omit conflictingItems!\n      // Note: you probably can't use right_origin in every case.. only when setting _left\n      o = o._right\n    }\n    // reconnect left/right + update parent map/start if necessary\n    const parentSub = this._parentSub\n    if (this._left === null) {\n      let right\n      if (parentSub !== null) {\n        const pmap = parent._map\n        right = pmap.get(parentSub) || null\n        pmap.set(parentSub, this)\n      } else {\n        right = parent._start\n        parent._start = this\n      }\n      this._right = right\n      if (right !== null) {\n        right._left = this\n      }\n    } else {\n      const left = this._left\n      const right = left._right\n      this._right = right\n      left._right = this\n      if (right !== null) {\n        right._left = this\n      }\n    }\n    if (parent._deleted) {\n      this._delete(y, false)\n    }\n    y.os.put(this)\n    transactionTypeChanged(y, parent, parentSub)\n    if (this._id.user !== RootFakeUserID) {\n      if (y.connector !== null && (y.connector._forwardAppliedStructs || this._id.user === y.userID)) {\n        y.connector.broadcastStruct(this)\n      }\n      if (y.persistence !== null) {\n        y.persistence.saveStruct(y, this)\n      }\n    }\n  }\n  _toBinary (encoder) {\n    encoder.writeUint8(getReference(this.constructor))\n    let info = 0\n    if (this._origin !== null) {\n      info += 0b1 // origin is defined\n    }\n    // TODO: remove\n    /* no longer send _left\n    if (this._left !== this._origin) {\n      info += 0b10 // do not copy origin to left\n    }\n    */\n    if (this._right_origin !== null) {\n      info += 0b100\n    }\n    if (this._parentSub !== null) {\n      info += 0b1000\n    }\n    encoder.writeUint8(info)\n    encoder.writeID(this._id)\n    if (info & 0b1) {\n      encoder.writeID(this._origin._lastId)\n    }\n    // TODO: remove\n    /* see above\n    if (info & 0b10) {\n      encoder.writeID(this._left._lastId)\n    }\n    */\n    if (info & 0b100) {\n      encoder.writeID(this._right_origin._id)\n    }\n    if ((info & 0b101) === 0) {\n      // neither origin nor right is defined\n      encoder.writeID(this._parent._id)\n    }\n    if (info & 0b1000) {\n      encoder.writeVarString(JSON.stringify(this._parentSub))\n    }\n  }\n  _fromBinary (y, decoder) {\n    let missing = []\n    const info = decoder.readUint8()\n    const id = decoder.readID()\n    this._id = id\n    // read origin\n    if (info & 0b1) {\n      // origin != null\n      const originID = decoder.readID()\n      // we have to query for left again because it might have been split/merged..\n      const origin = y.os.getItemCleanEnd(originID)\n      if (origin === null) {\n        missing.push(originID)\n      } else {\n        this._origin = origin\n        this._left = this._origin\n      }\n    }\n    // read right\n    if (info & 0b100) {\n      // right != null\n      const rightID = decoder.readID()\n      // we have to query for right again because it might have been split/merged..\n      const right = y.os.getItemCleanStart(rightID)\n      if (right === null) {\n        missing.push(rightID)\n      } else {\n        this._right = right\n        this._right_origin = right\n      }\n    }\n    // read parent\n    if ((info & 0b101) === 0) {\n      // neither origin nor right is defined\n      const parentID = decoder.readID()\n      // parent does not change, so we don't have to search for it again\n      if (this._parent === null) {\n        const parent = y.os.get(parentID)\n        if (parent === null) {\n          missing.push(parentID)\n        } else {\n          this._parent = parent\n        }\n      }\n    } else if (this._parent === null) {\n      if (this._origin !== null) {\n        this._parent = this._origin._parent\n      } else if (this._right_origin !== null) {\n        this._parent = this._right_origin._parent\n      }\n    }\n    if (info & 0b1000) {\n      // TODO: maybe put this in read parent condition (you can also read parentsub from left/right)\n      this._parentSub = JSON.parse(decoder.readVarString())\n    }\n    if (y.ss.getState(id.user) < id.clock) {\n      missing.push(new ID(id.user, id.clock - 1))\n    }\n    return missing\n  }\n}\n","import Item from './Item.js'\nimport EventHandler from '../Util/EventHandler.js'\nimport ID from '../Util/ID.js'\n\n// restructure children as if they were inserted one after another\nfunction integrateChildren (y, start) {\n  let right\n  do {\n    right = start._right\n    start._right = null\n    start._right_origin = null\n    start._origin = start._left\n    start._integrate(y)\n    start = right\n  } while (right !== null)\n}\n\nexport function getListItemIDByPosition (type, i) {\n  let pos = 0\n  let n = type._start\n  while (n !== null) {\n    if (!n._deleted) {\n      if (pos <= i && i < pos + n._length) {\n        const id = n._id\n        return new ID(id.user, id.clock + i - pos)\n      }\n      pos++\n    }\n    n = n._right\n  }\n}\n\nexport default class Type extends Item {\n  constructor () {\n    super()\n    this._map = new Map()\n    this._start = null\n    this._y = null\n    this._eventHandler = new EventHandler()\n    this._deepEventHandler = new EventHandler()\n  }\n  getPathTo (type) {\n    if (type === this) {\n      return []\n    }\n    const path = []\n    const y = this._y\n    while (type._parent !== this && this._parent !== y) {\n      let parent = type._parent\n      if (type._parentSub !== null) {\n        path.push(type._parentSub)\n      } else {\n        // parent is array-ish\n        for (let [i, child] of parent) {\n          if (child === type) {\n            path.push(i)\n            break\n          }\n        }\n      }\n      type = parent\n    }\n    if (this._parent !== this) {\n      throw new Error('The type is not a child of this node')\n    }\n    return path\n  }\n  _callEventHandler (transaction, event) {\n    const changedParentTypes = transaction.changedParentTypes\n    this._eventHandler.callEventListeners(transaction, event)\n    let type = this\n    while (type !== this._y) {\n      let events = changedParentTypes.get(type)\n      if (events === undefined) {\n        events = []\n        changedParentTypes.set(type, events)\n      }\n      events.push(event)\n      type = type._parent\n    }\n  }\n  _transact (f) {\n    const y = this._y\n    if (y !== null) {\n      y.transact(f)\n    } else {\n      f(y)\n    }\n  }\n  observe (f) {\n    this._eventHandler.addEventListener(f)\n  }\n  observeDeep (f) {\n    this._deepEventHandler.addEventListener(f)\n  }\n  unobserve (f) {\n    this._eventHandler.removeEventListener(f)\n  }\n  unobserveDeep (f) {\n    this._deepEventHandler.removeEventListener(f)\n  }\n  _integrate (y) {\n    super._integrate(y)\n    this._y = y\n    // when integrating children we must make sure to\n    // integrate start\n    const start = this._start\n    if (start !== null) {\n      this._start = null\n      integrateChildren(y, start)\n    }\n    // integrate map children\n    const map = this._map\n    this._map = new Map()\n    for (let t of map.values()) {\n      // TODO make sure that right elements are deleted!\n      integrateChildren(y, t)\n    }\n  }\n  _delete (y, createDelete) {\n    super._delete(y, createDelete)\n    y._transaction.changedTypes.delete(this)\n    // delete map types\n    for (let value of this._map.values()) {\n      if (value instanceof Item && !value._deleted) {\n        value._delete(y, false)\n      }\n    }\n    // delete array types\n    let t = this._start\n    while (t !== null) {\n      if (!t._deleted) {\n        t._delete(y, false)\n      }\n      t = t._right\n    }\n  }\n}\n","import { YXmlText, YXmlHook } from './y-xml.js'\n\nexport function defaultDomFilter (node, attributes) {\n  return attributes\n}\n\nexport function getAnchorViewPosition (scrollElement) {\n  if (scrollElement == null) {\n    return null\n  }\n  let anchor = document.getSelection().anchorNode\n  if (anchor != null) {\n    let top = getBoundingClientRect(anchor).top\n    if (top >= 0 && top <= document.documentElement.clientHeight) {\n      return {\n        anchor: anchor,\n        top: top\n      }\n    }\n  }\n  return {\n    anchor: null,\n    scrollTop: scrollElement.scrollTop,\n    scrollHeight: scrollElement.scrollHeight\n  }\n}\n\n// get BoundingClientRect that works on text nodes\nexport function getBoundingClientRect (element) {\n  if (element.getBoundingClientRect != null) {\n    // is element node\n    return element.getBoundingClientRect()\n  } else {\n    // is text node\n    if (element.parentNode == null) {\n      // range requires that text nodes have a parent\n      let span = document.createElement('span')\n      span.appendChild(element)\n    }\n    let range = document.createRange()\n    range.selectNode(element)\n    return range.getBoundingClientRect()\n  }\n}\n\nexport function fixScrollPosition (scrollElement, fix) {\n  if (scrollElement !== null && fix !== null) {\n    if (fix.anchor === null) {\n      if (scrollElement.scrollTop === fix.scrollTop) {\n        scrollElement.scrollTop = scrollElement.scrollHeight - fix.scrollHeight\n      }\n    } else {\n      scrollElement.scrollTop = getBoundingClientRect(fix.anchor).top - fix.top\n    }\n  }\n}\n\nfunction iterateUntilUndeleted (item) {\n  while (item !== null && item._deleted) {\n    item = item._right\n  }\n  return item\n}\n\nfunction _insertNodeHelper (yxml, prevExpectedNode, child) {\n  let insertedNodes = yxml.insertDomElementsAfter(prevExpectedNode, [child])\n  if (insertedNodes.length > 0) {\n    return insertedNodes[0]\n  } else {\n    return prevExpectedNode\n  }\n}\n\n/*\n * 1. Check if any of the nodes was deleted\n * 2. Iterate over the children.\n *    2.1 If a node exists without _yxml property, insert a new node\n *    2.2 If _contents.length < dom.childNodes.length, fill the\n *        rest of _content with childNodes\n *    2.3 If a node was moved, delete it and\n *       recreate a new yxml element that is bound to that node.\n *       You can detect that a node was moved because expectedId\n *       !== actualId in the list\n */\nexport function applyChangesFromDom (dom) {\n  const yxml = dom._yxml\n  if (yxml.constructor === YXmlHook) {\n    return\n  }\n  const y = yxml._y\n  let knownChildren =\n    new Set(\n      Array.prototype.map.call(dom.childNodes, child => child._yxml)\n      .filter(id => id !== undefined)\n    )\n  // 1. Check if any of the nodes was deleted\n  yxml.forEach(function (childType, i) {\n    if (!knownChildren.has(childType)) {\n      childType._delete(y)\n    }\n  })\n  // 2. iterate\n  let childNodes = dom.childNodes\n  let len = childNodes.length\n  let prevExpectedNode = null\n  let expectedNode = iterateUntilUndeleted(yxml._start)\n  for (let domCnt = 0; domCnt < len; domCnt++) {\n    const child = childNodes[domCnt]\n    const childYXml = child._yxml\n    if (childYXml != null) {\n      if (childYXml === false) {\n        // should be ignored or is going to be deleted\n        continue\n      }\n      if (expectedNode !== null) {\n        if (expectedNode !== childYXml) {\n          // 2.3 Not expected node\n          if (childYXml._parent !== this) {\n            // element is going to be deleted by its previous parent\n            child._yxml = null\n          } else {\n            childYXml._delete(y)\n          }\n          prevExpectedNode = _insertNodeHelper(yxml, prevExpectedNode, child)\n        } else {\n          prevExpectedNode = expectedNode\n          expectedNode = iterateUntilUndeleted(expectedNode._right)\n        }\n        // if this is the expected node id, just continue\n      } else {\n        // 2.2 fill _conten with child nodes\n        prevExpectedNode = _insertNodeHelper(yxml, prevExpectedNode, child)\n      }\n    } else {\n      // 2.1 A new node was found\n      prevExpectedNode = _insertNodeHelper(yxml, prevExpectedNode, child)\n    }\n  }\n}\n\nexport function reflectChangesOnDom (events, _document) {\n  // Make sure that no filtered attributes are applied to the structure\n  // if they were, delete them\n  /*\n  events.forEach(event => {\n    const target = event.target\n    if (event.attributesChanged === undefined) {\n      // event.target is Y.XmlText\n      return\n    }\n    const keys = this._domFilter(target.nodeName, Array.from(event.attributesChanged))\n    if (keys === null) {\n      target._delete()\n    } else {\n      const removeKeys = new Set() // is a copy of event.attributesChanged\n      event.attributesChanged.forEach(key => { removeKeys.add(key) })\n      keys.forEach(key => {\n        // remove all accepted keys from removeKeys\n        removeKeys.delete(key)\n      })\n      // remove the filtered attribute\n      removeKeys.forEach(key => {\n        target.removeAttribute(key)\n      })\n    }\n  })\n  */\n  this._mutualExclude(() => {\n    events.forEach(event => {\n      const yxml = event.target\n      const dom = yxml._dom\n      if (dom != null) {\n        // TODO: do this once before applying stuff\n        // let anchorViewPosition = getAnchorViewPosition(yxml._scrollElement)\n        if (yxml.constructor === YXmlText) {\n          yxml._dom.nodeValue = yxml.toString()\n        } else if (event.attributesChanged !== undefined) {\n          // update attributes\n          event.attributesChanged.forEach(attributeName => {\n            const value = yxml.getAttribute(attributeName)\n            if (value === undefined) {\n              dom.removeAttribute(attributeName)\n            } else {\n              dom.setAttribute(attributeName, value)\n            }\n          })\n          /**\n           * TODO: instead of chard-checking the types, it would be best to\n           *       specify the type's features. E.g.\n           *         - _yxmlHasAttributes\n           *         - _yxmlHasChildren\n           *       Furthermore, the features shouldn't be encoded in the types,\n           *       only in the attributes (above)\n           */\n          if (event.childListChanged && yxml.constructor !== YXmlHook) {\n            let currentChild = dom.firstChild\n            yxml.forEach(function (t) {\n              let expectedChild = t.getDom(_document)\n              if (expectedChild.parentNode === dom) {\n                // is already attached to the dom. Look for it\n                while (currentChild !== expectedChild) {\n                  let del = currentChild\n                  currentChild = currentChild.nextSibling\n                  dom.removeChild(del)\n                }\n                currentChild = currentChild.nextSibling\n              } else {\n                // this dom is not yet attached to dom\n                dom.insertBefore(expectedChild, currentChild)\n              }\n            })\n            while (currentChild !== null) {\n              let tmp = currentChild.nextSibling\n              dom.removeChild(currentChild)\n              currentChild = tmp\n            }\n          }\n        }\n        /* TODO: smartscrolling\n        .. else if (event.type === 'childInserted' || event.type === 'insert') {\n          let nodes = event.values\n          for (let i = nodes.length - 1; i >= 0; i--) {\n            let node = nodes[i]\n            node.setDomFilter(yxml._domFilter)\n            node.enableSmartScrolling(yxml._scrollElement)\n            let dom = node.getDom()\n            let fixPosition = null\n            let nextDom = null\n            if (yxml._content.length > event.index + i + 1) {\n              nextDom = yxml.get(event.index + i + 1).getDom()\n            }\n            yxml._dom.insertBefore(dom, nextDom)\n            if (anchorViewPosition === null) {\n              // nop\n            } else if (anchorViewPosition.anchor !== null) {\n              // no scrolling when current selection\n              if (!dom.contains(anchorViewPosition.anchor) && !anchorViewPosition.anchor.contains(dom)) {\n                fixPosition = anchorViewPosition\n              }\n            } else if (getBoundingClientRect(dom).top <= 0) {\n              // adjust scrolling if modified element is out of view,\n              // there is no anchor element, and the browser did not adjust scrollTop (this is checked later)\n              fixPosition = anchorViewPosition\n            }\n            fixScrollPosition(yxml._scrollElement, fixPosition)\n          }\n        } else if (event.type === 'childRemoved' || event.type === 'delete') {\n          for (let i = event.values.length - 1; i >= 0; i--) {\n            let dom = event.values[i]._dom\n            let fixPosition = null\n            if (anchorViewPosition === null) {\n              // nop\n            } else if (anchorViewPosition.anchor !== null) {\n              // no scrolling when current selection\n              if (!dom.contains(anchorViewPosition.anchor) && !anchorViewPosition.anchor.contains(dom)) {\n                fixPosition = anchorViewPosition\n              }\n            } else if (getBoundingClientRect(dom).top <= 0) {\n              // adjust scrolling if modified element is out of view,\n              // there is no anchor element, and the browser did not adjust scrollTop (this is checked later)\n              fixPosition = anchorViewPosition\n            }\n            dom.remove()\n            fixScrollPosition(yxml._scrollElement, fixPosition)\n          }\n        }\n        */\n      }\n    })\n  })\n}\n","import ID from './ID.js'\nimport RootID from './RootID.js'\n\nexport function getRelativePosition (type, offset) {\n  let t = type._start\n  while (t !== null) {\n    if (t._deleted === false) {\n      if (t._length > offset) {\n        return [t._id.user, t._id.clock + offset]\n      }\n      offset -= t._length\n    }\n    t = t._right\n  }\n  return ['endof', type._id.user, type._id.clock || null, type._id.name || null, type._id.type || null]\n}\n\nexport function fromRelativePosition (y, rpos) {\n  if (rpos[0] === 'endof') {\n    let id\n    if (rpos[3] === null) {\n      id = new ID(rpos[1], rpos[2])\n    } else {\n      id = new RootID(rpos[3], rpos[4])\n    }\n    const type = y.os.get(id)\n    return {\n      type,\n      offset: type.length\n    }\n  } else {\n    let offset = 0\n    let struct = y.os.findNodeWithUpperBound(new ID(rpos[0], rpos[1])).val\n    const parent = struct._parent\n    if (parent._deleted) {\n      return null\n    }\n    if (!struct._deleted) {\n      offset = rpos[1] - struct._id.clock\n    }\n    struct = struct._left\n    while (struct !== null) {\n      if (!struct._deleted) {\n        offset += struct._length\n      }\n      struct = struct._left\n    }\n    return {\n      type: parent,\n      offset: offset\n    }\n  }\n}\n","/* globals getSelection */\n\nimport { getRelativePosition, fromRelativePosition } from '../../Util/relativePosition.js'\n\nlet browserSelection = null\nlet relativeSelection = null\n\nexport let beforeTransactionSelectionFixer\nif (typeof getSelection !== 'undefined') {\n  beforeTransactionSelectionFixer = function _beforeTransactionSelectionFixer (y, transaction, remote) {\n    if (!remote) {\n      return\n    }\n    relativeSelection = { from: null, to: null, fromY: null, toY: null }\n    browserSelection = getSelection()\n    const anchorNode = browserSelection.anchorNode\n    if (anchorNode !== null && anchorNode._yxml != null) {\n      const yxml = anchorNode._yxml\n      relativeSelection.from = getRelativePosition(yxml, browserSelection.anchorOffset)\n      relativeSelection.fromY = yxml._y\n    }\n    const focusNode = browserSelection.focusNode\n    if (focusNode !== null && focusNode._yxml != null) {\n      const yxml = focusNode._yxml\n      relativeSelection.to = getRelativePosition(yxml, browserSelection.focusOffset)\n      relativeSelection.toY = yxml._y\n    }\n  }\n} else {\n  beforeTransactionSelectionFixer = function _fakeBeforeTransactionSelectionFixer () {}\n}\n\nexport function afterTransactionSelectionFixer (y, transaction, remote) {\n  if (relativeSelection === null || !remote) {\n    return\n  }\n  const to = relativeSelection.to\n  const from = relativeSelection.from\n  const fromY = relativeSelection.fromY\n  const toY = relativeSelection.toY\n  let shouldUpdate = false\n  let anchorNode = browserSelection.anchorNode\n  let anchorOffset = browserSelection.anchorOffset\n  let focusNode = browserSelection.focusNode\n  let focusOffset = browserSelection.focusOffset\n  if (from !== null) {\n    let sel = fromRelativePosition(fromY, from)\n    if (sel !== null) {\n      let node = sel.type.getDom()\n      let offset = sel.offset\n      if (node !== anchorNode || offset !== anchorOffset) {\n        anchorNode = node\n        anchorOffset = offset\n        shouldUpdate = true\n      }\n    }\n  }\n  if (to !== null) {\n    let sel = fromRelativePosition(toY, to)\n    if (sel !== null) {\n      let node = sel.type.getDom()\n      let offset = sel.offset\n      if (node !== focusNode || offset !== focusOffset) {\n        focusNode = node\n        focusOffset = offset\n        shouldUpdate = true\n      }\n    }\n  }\n  if (shouldUpdate) {\n    browserSelection.setBaseAndExtent(\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    )\n  }\n}\n","\nexport default function simpleDiff (a, b) {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && a[left] === b[left]) {\n    left++\n  }\n  if (left !== a.length || left !== b.length) {\n    // Only check right if a !== b\n    while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {\n      right++\n    }\n  }\n  return {\n    pos: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n","/* global MutationObserver */\n\nimport { defaultDomFilter, applyChangesFromDom, reflectChangesOnDom } from './utils.js'\nimport { beforeTransactionSelectionFixer, afterTransactionSelectionFixer } from './selection.js'\n\nimport YArray from '../YArray.js'\nimport YXmlEvent from './YXmlEvent.js'\nimport { YXmlText, YXmlHook } from './y-xml'\nimport { logID } from '../../MessageHandler/messageToString.js'\nimport diff from '../../Util/simpleDiff.js'\n\nfunction domToYXml (parent, doms, _document) {\n  const types = []\n  doms.forEach(d => {\n    if (d._yxml != null && d._yxml !== false) {\n      d._yxml._unbindFromDom()\n    }\n    if (parent._domFilter(d.nodeName, new Map()) !== null) {\n      let type\n      const hookName = d._yjsHook || (d.dataset != null ? d.dataset.yjsHook : undefined)\n      if (hookName !== undefined) {\n        type = new YXmlHook(hookName, d)\n      } else if (d.nodeType === d.TEXT_NODE) {\n        type = new YXmlText(d)\n      } else if (d.nodeType === d.ELEMENT_NODE) {\n        type = new YXmlFragment._YXmlElement(d, parent._domFilter, _document)\n      } else {\n        throw new Error('Unsupported node!')\n      }\n      // type.enableSmartScrolling(parent._scrollElement)\n      types.push(type)\n    } else {\n      d._yxml = false\n    }\n  })\n  return types\n}\n\nclass YXmlTreeWalker {\n  constructor (root, f) {\n    this._filter = f || (() => true)\n    this._root = root\n    this._currentNode = root\n    this._firstCall = true\n  }\n  [Symbol.iterator] () {\n    return this\n  }\n  next () {\n    let n = this._currentNode\n    if (this._firstCall) {\n      this._firstCall = false\n      if (!n._deleted && this._filter(n)) {\n        return { value: n, done: false }\n      }\n    }\n    do {\n      if (!n._deleted && (n.constructor === YXmlFragment._YXmlElement || n.constructor === YXmlFragment) && n._start !== null) {\n        // walk down in the tree\n        n = n._start\n      } else {\n        // walk right or up in the tree\n        while (n !== this._root) {\n          if (n._right !== null) {\n            n = n._right\n            break\n          }\n          n = n._parent\n        }\n        if (n === this._root) {\n          n = null\n        }\n      }\n      if (n === this._root) {\n        break\n      }\n    } while (n !== null && (n._deleted || !this._filter(n)))\n    this._currentNode = n\n    if (n === null) {\n      return { done: true }\n    } else {\n      return { value: n, done: false }\n    }\n  }\n}\n\nexport default class YXmlFragment extends YArray {\n  constructor () {\n    super()\n    this._dom = null\n    this._domFilter = defaultDomFilter\n    this._domObserver = null\n    // this function makes sure that either the\n    // dom event is executed, or the yjs observer is executed\n    var token = true\n    this._mutualExclude = f => {\n      if (token) {\n        token = false\n        try {\n          f()\n        } catch (e) {\n          console.error(e)\n        }\n        /*\n        if (this._domObserver !== null) {\n          this._domObserver.takeRecords()\n        }\n        */\n        token = true\n      }\n    }\n  }\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n  /**\n   * Retrieve first element that matches *query*\n   * Similar to DOM's querySelector, but only accepts a subset of its queries\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   */\n  querySelector (query) {\n    query = query.toUpperCase()\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName === query)\n    const next = iterator.next()\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n  querySelectorAll (query) {\n    query = query.toUpperCase()\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName === query))\n  }\n  enableSmartScrolling (scrollElement) {\n    this._scrollElement = scrollElement\n    this.forEach(xml => {\n      xml.enableSmartScrolling(scrollElement)\n    })\n  }\n  setDomFilter (f) {\n    this._domFilter = f\n    let attributes = new Map()\n    if (this.getAttributes !== undefined) {\n      let attrs = this.getAttributes()\n      for (let key in attrs) {\n        attributes.set(key, attrs[key])\n      }\n    }\n    this._y.transact(() => {\n      let result = this._domFilter(this.nodeName, new Map(attributes))\n      if (result === null) {\n        this._delete(this._y)\n      } else {\n        attributes.forEach((value, key) => {\n          if (!result.has(key)) {\n            this.removeAttribute(key)\n          }\n        })\n      }\n      this.forEach(xml => {\n        xml.setDomFilter(f)\n      })\n    })\n  }\n  _callObserver (transaction, parentSubs, remote) {\n    this._callEventHandler(transaction, new YXmlEvent(this, parentSubs, remote))\n  }\n  toString () {\n    return this.map(xml => xml.toString()).join('')\n  }\n  _delete (y, createDelete) {\n    this._unbindFromDom()\n    super._delete(y, createDelete)\n  }\n  _unbindFromDom () {\n    if (this._domObserver != null) {\n      this._domObserver.disconnect()\n      this._domObserver = null\n    }\n    if (this._dom != null) {\n      this._dom._yxml = null\n      this._dom = null\n    }\n    if (this._beforeTransactionHandler !== undefined) {\n      this._y.off('beforeTransaction', this._beforeTransactionHandler)\n    }\n  }\n  insertDomElementsAfter (prev, doms, _document) {\n    const types = domToYXml(this, doms, _document)\n    this.insertAfter(prev, types)\n    return types\n  }\n  insertDomElements (pos, doms, _document) {\n    const types = domToYXml(this, doms, _document)\n    this.insert(pos, types)\n    return types\n  }\n  getDom () {\n    return this._dom\n  }\n  bindToDom (dom, _document) {\n    if (this._dom != null) {\n      this._unbindFromDom()\n    }\n    if (dom._yxml != null) {\n      dom._yxml._unbindFromDom()\n    }\n    dom.innerHTML = ''\n    this.forEach(t => {\n      dom.insertBefore(t.getDom(_document), null)\n    })\n    this._bindToDom(dom, _document)\n  }\n  // binds to a dom element\n  // Only call if dom and YXml are isomorph\n  _bindToDom (dom, _document) {\n    _document = _document || document\n    this._dom = dom\n    dom._yxml = this\n    if (this._parent === null) {\n      return\n    }\n    this._y.on('beforeTransaction', beforeTransactionSelectionFixer)\n    this._y.on('afterTransaction', afterTransactionSelectionFixer)\n    const applyFilter = (type) => {\n      if (type._deleted) {\n        return\n      }\n      // check if type is a child of this\n      let isChild = false\n      let p = type\n      while (p !== this._y) {\n        if (p === this) {\n          isChild = true\n          break\n        }\n        p = p._parent\n      }\n      if (!isChild) {\n        return\n      }\n      // filter attributes\n      let attributes = new Map()\n      if (type.getAttributes !== undefined) {\n        let attrs = type.getAttributes()\n        for (let key in attrs) {\n          attributes.set(key, attrs[key])\n        }\n      }\n      let result = this._domFilter(type.nodeName, new Map(attributes))\n      if (result === null) {\n        type._delete(this._y)\n      } else {\n        attributes.forEach((value, key) => {\n          if (!result.has(key)) {\n            type.removeAttribute(key)\n          }\n        })\n      }\n    }\n    this._y.on('beforeObserverCalls', function (y, transaction) {\n      // apply dom filter to new and changed types\n      transaction.changedTypes.forEach(function (subs, type) {\n        if (subs.size > 1 || !subs.has(null)) {\n          // only apply changes on attributes\n          applyFilter(type)\n        }\n      })\n      transaction.newTypes.forEach(applyFilter)\n    })\n    // Apply Y.Xml events to dom\n    this.observeDeep(events => {\n      reflectChangesOnDom.call(this, events, _document)\n    })\n    // Apply Dom changes on Y.Xml\n    if (typeof MutationObserver !== 'undefined') {\n      this._beforeTransactionHandler = () => {\n        this._domObserverListener(this._domObserver.takeRecords())\n      }\n      this._y.on('beforeTransaction', this._beforeTransactionHandler)\n      this._domObserverListener = mutations => {\n        this._mutualExclude(() => {\n          this._y.transact(() => {\n            let diffChildren = new Set()\n            mutations.forEach(mutation => {\n              const dom = mutation.target\n              const yxml = dom._yxml\n              if (yxml == null || yxml.constructor === YXmlHook) {\n                // dom element is filtered\n                return\n              }\n              switch (mutation.type) {\n                case 'characterData':\n                  var change = diff(yxml.toString(), dom.nodeValue)\n                  yxml.delete(change.pos, change.remove)\n                  yxml.insert(change.pos, change.insert)\n                  break\n                case 'attributes':\n                  if (yxml.constructor === YXmlFragment) {\n                    break\n                  }\n                  let name = mutation.attributeName\n                  let val = dom.getAttribute(name)\n                  // check if filter accepts attribute\n                  let attributes = new Map()\n                  attributes.set(name, val)\n                  if (this._domFilter(dom.nodeName, attributes).size > 0 && yxml.constructor !== YXmlFragment) {\n                    if (yxml.getAttribute(name) !== val) {\n                      if (val == null) {\n                        yxml.removeAttribute(name)\n                      } else {\n                        yxml.setAttribute(name, val)\n                      }\n                    }\n                  }\n                  break\n                case 'childList':\n                  diffChildren.add(mutation.target)\n                  break\n              }\n            })\n            for (let dom of diffChildren) {\n              if (dom.yOnChildrenChanged !== undefined) {\n                dom.yOnChildrenChanged()\n              }\n              if (dom._yxml != null && dom._yxml !== false) {\n                applyChangesFromDom(dom)\n              }\n            }\n          })\n        })\n      }\n      this._domObserver = new MutationObserver(this._domObserverListener)\n      this._domObserver.observe(dom, {\n        childList: true,\n        attributes: true,\n        characterData: true,\n        subtree: true\n      })\n    }\n    return dom\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YXml(id:${logID(this._id)},left:${logID(left)},origin:${logID(origin)},right:${this._right},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","\nconst xmlHooks = {}\n\nexport function addHook (name, hook) {\n  xmlHooks[name] = hook\n}\n\nexport function getHook (name) {\n  const hook = xmlHooks[name]\n  if (hook === undefined) {\n    throw new Error(`The hook \"${name}\" is not specified! You must not access this hook!`)\n  }\n  return hook\n}\n","import YArray from '../Type/YArray.js'\nimport YMap from '../Type/YMap.js'\nimport YText from '../Type/YText.js'\nimport { YXmlFragment, YXmlElement, YXmlText, YXmlHook } from '../Type/y-xml/y-xml.js'\n\nimport Delete from '../Struct/Delete.js'\nimport ItemJSON from '../Struct/ItemJSON.js'\nimport ItemString from '../Struct/ItemString.js'\n\nconst structs = new Map()\nconst references = new Map()\n\nexport function addStruct (reference, structConstructor) {\n  structs.set(reference, structConstructor)\n  references.set(structConstructor, reference)\n}\n\nexport function getStruct (reference) {\n  return structs.get(reference)\n}\n\nexport function getReference (typeConstructor) {\n  return references.get(typeConstructor)\n}\n\naddStruct(0, ItemJSON)\naddStruct(1, ItemString)\naddStruct(2, Delete)\n\naddStruct(3, YArray)\naddStruct(4, YMap)\naddStruct(5, YText)\naddStruct(6, YXmlFragment)\naddStruct(7, YXmlElement)\naddStruct(8, YXmlText)\naddStruct(9, YXmlHook)\n","/* global crypto */\n\nexport function generateUserID () {\n  if (typeof crypto !== 'undefined' && crypto.getRandomValue != null) {\n    // browser\n    let arr = new Uint32Array(1)\n    crypto.getRandomValues(arr)\n    return arr[0]\n  } else if (typeof crypto !== 'undefined' && crypto.randomBytes != null) {\n    // node\n    let buf = crypto.randomBytes(4)\n    return new Uint32Array(buf.buffer)[0]\n  } else {\n    return Math.ceil(Math.random() * 0xFFFFFFFF)\n  }\n}\n","import ID from './ID.js'\n\nclass ReverseOperation {\n  constructor (y, transaction) {\n    this.created = new Date()\n    const beforeState = transaction.beforeState\n    if (beforeState.has(y.userID)) {\n      this.toState = new ID(y.userID, y.ss.getState(y.userID) - 1)\n      this.fromState = new ID(y.userID, beforeState.get(y.userID))\n    } else {\n      this.toState = null\n      this.fromState = null\n    }\n    this.deletedStructs = transaction.deletedStructs\n  }\n}\n\nfunction isStructInScope (y, struct, scope) {\n  while (struct !== y) {\n    if (struct === scope) {\n      return true\n    }\n    struct = struct._parent\n  }\n  return false\n}\n\nfunction applyReverseOperation (y, scope, reverseBuffer) {\n  let performedUndo = false\n  y.transact(() => {\n    while (!performedUndo && reverseBuffer.length > 0) {\n      let undoOp = reverseBuffer.pop()\n      // make sure that it is possible to iterate {from}-{to}\n      if (undoOp.fromState !== null) {\n        y.os.getItemCleanStart(undoOp.fromState)\n        y.os.getItemCleanEnd(undoOp.toState)\n        y.os.iterate(undoOp.fromState, undoOp.toState, op => {\n          while (op._deleted && op._redone !== null) {\n            op = op._redone\n          }\n          if (op._deleted === false && isStructInScope(y, op, scope)) {\n            performedUndo = true\n            op._delete(y)\n          }\n        })\n      }\n      for (let op of undoOp.deletedStructs) {\n        if (\n          isStructInScope(y, op, scope) &&\n          op._parent !== y &&\n          (\n            op._id.user !== y.userID ||\n            undoOp.fromState === null ||\n            op._id.clock < undoOp.fromState.clock ||\n            op._id.clock > undoOp.toState.clock\n          )\n        ) {\n          performedUndo = true\n          op._redo(y)\n        }\n      }\n    }\n  })\n  return performedUndo\n}\n\nexport default class UndoManager {\n  constructor (scope, options = {}) {\n    this.options = options\n    options.captureTimeout = options.captureTimeout == null ? 500 : options.captureTimeout\n    this._undoBuffer = []\n    this._redoBuffer = []\n    this._scope = scope\n    this._undoing = false\n    this._redoing = false\n    const y = scope._y\n    this.y = y\n    y.on('afterTransaction', (y, transaction, remote) => {\n      if (!remote && transaction.changedParentTypes.has(scope)) {\n        let reverseOperation = new ReverseOperation(y, transaction)\n        if (!this._undoing) {\n          let lastUndoOp = this._undoBuffer.length > 0 ? this._undoBuffer[this._undoBuffer.length - 1] : null\n          if (lastUndoOp !== null && reverseOperation.created - lastUndoOp.created <= options.captureTimeout) {\n            lastUndoOp.created = reverseOperation.created\n            if (reverseOperation.toState !== null) {\n              lastUndoOp.toState = reverseOperation.toState\n              if (lastUndoOp.fromState === null) {\n                lastUndoOp.fromState = reverseOperation.fromState\n              }\n            }\n            reverseOperation.deletedStructs.forEach(lastUndoOp.deletedStructs.add, lastUndoOp.deletedStructs)\n          } else {\n            this._undoBuffer.push(reverseOperation)\n          }\n          if (!this._redoing) {\n            this._redoBuffer = []\n          }\n        } else {\n          this._redoBuffer.push(reverseOperation)\n        }\n      }\n    })\n  }\n  undo () {\n    this._undoing = true\n    const performedUndo = applyReverseOperation(this.y, this._scope, this._undoBuffer)\n    this._undoing = false\n    return performedUndo\n  }\n  redo () {\n    this._redoing = true\n    const performedRedo = applyReverseOperation(this.y, this._scope, this._redoBuffer)\n    this._redoing = false\n    return performedRedo\n  }\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","import { writeStructs } from './syncStep1.js'\nimport { integrateRemoteStructs } from './integrateRemoteStructs.js'\nimport { readDeleteSet, writeDeleteSet } from './deleteSet.js'\nimport BinaryEncoder from '../Binary/Encoder.js'\n\nexport function fromBinary (y, decoder) {\n  y.transact(function () {\n    integrateRemoteStructs(y, decoder)\n    readDeleteSet(y, decoder)\n  })\n}\n\nexport function toBinary (y) {\n  let encoder = new BinaryEncoder()\n  writeStructs(y, encoder, new Map())\n  writeDeleteSet(y, encoder)\n  return encoder\n}\n","\nexport function createMutualExclude () {\n  var token = true\n  return function mutualExclude (f) {\n    if (token) {\n      token = false\n      try {\n        f()\n      } catch (e) {\n        console.error(e)\n      }\n      token = true\n    }\n  }\n}\n","import BinaryEncoder from './Binary/Encoder.js'\nimport BinaryDecoder from './Binary/Decoder.js'\nimport { toBinary, fromBinary } from './MessageHandler/binaryEncode.js'\nimport { integrateRemoteStructs } from './MessageHandler/integrateRemoteStructs.js'\nimport { createMutualExclude } from './Util/mutualExclude.js'\n\nfunction getFreshCnf () {\n  let buffer = new BinaryEncoder()\n  buffer.writeUint32(0)\n  return {\n    len: 0,\n    buffer\n  }\n}\n\nexport default class AbstractPersistence {\n  constructor (opts) {\n    this.opts = opts\n    this.ys = new Map()\n  }\n\n  _init (y) {\n    let cnf = this.ys.get(y)\n    if (cnf === undefined) {\n      cnf = getFreshCnf()\n      cnf.mutualExclude = createMutualExclude()\n      this.ys.set(y, cnf)\n      return this.init(y).then(() => {\n        y.on('afterTransaction', (y, transaction) => {\n          let cnf = this.ys.get(y)\n          if (cnf.len > 0) {\n            cnf.buffer.setUint32(0, cnf.len)\n            this.saveUpdate(y, cnf.buffer.createBuffer(), transaction)\n            let _cnf = getFreshCnf()\n            for (let key in _cnf) {\n              cnf[key] = _cnf[key]\n            }\n          }\n        })\n        return this.retrieve(y)\n      }).then(function () {\n        return Promise.resolve(cnf)\n      })\n    } else {\n      return Promise.resolve(cnf)\n    }\n  }\n  deinit (y) {\n    this.ys.delete(y)\n    y.persistence = null\n  }\n\n  destroy () {\n    this.ys = null\n  }\n\n  /**\n   * Remove all persisted data that belongs to a room.\n   * Automatically destroys all Yjs all Yjs instances that persist to\n   * the room. If `destroyYjsInstances = false` the persistence functionality\n   * will be removed from the Yjs instances.\n   *\n   * ** Must be overwritten! **\n   */\n  removePersistedData (room, destroyYjsInstances = true) {\n    this.ys.forEach((cnf, y) => {\n      if (y.room === room) {\n        if (destroyYjsInstances) {\n          y.destroy()\n        } else {\n          this.deinit(y)\n        }\n      }\n    })\n  }\n\n  /* overwrite */\n  saveUpdate (buffer) {\n  }\n\n  /**\n   * Save struct to update buffer.\n   * saveUpdate is called when transaction ends\n   */\n  saveStruct (y, struct) {\n    let cnf = this.ys.get(y)\n    if (cnf !== undefined) {\n      cnf.mutualExclude(function () {\n        struct._toBinary(cnf.buffer)\n        cnf.len++\n      })\n    }\n  }\n\n  /* overwrite */\n  retrieve (y, model, updates) {\n    let cnf = this.ys.get(y)\n    if (cnf !== undefined) {\n      cnf.mutualExclude(function () {\n        y.transact(function () {\n          if (model != null) {\n            fromBinary(y, new BinaryDecoder(new Uint8Array(model)))\n          }\n          if (updates != null) {\n            for (let i = 0; i < updates.length; i++) {\n              integrateRemoteStructs(y, new BinaryDecoder(new Uint8Array(updates[i])))\n            }\n          }\n        })\n        y.emit('persistenceReady')\n      })\n    }\n  }\n\n  /* overwrite */\n  persist (y) {\n    return toBinary(y).createBuffer()\n  }\n}\n","\nimport Binding from './Binding.js'\nimport simpleDiff from '../Util/simpleDiff.js'\nimport { getRelativePosition, fromRelativePosition } from '../Util/relativePosition.js'\n\nfunction typeObserver () {\n  this._mutualExclude(() => {\n    const textarea = this.target\n    const textType = this.type\n    const relativeStart = getRelativePosition(textType, textarea.selectionStart)\n    const relativeEnd = getRelativePosition(textType, textarea.selectionEnd)\n    textarea.value = textType.toString()\n    const start = fromRelativePosition(textType._y, relativeStart)\n    const end = fromRelativePosition(textType._y, relativeEnd)\n    textarea.setSelectionRange(start, end)\n  })\n}\n\nfunction domObserver () {\n  this._mutualExclude(() => {\n    let diff = simpleDiff(this.type.toString(), this.target.value)\n    this.type.delete(diff.pos, diff.remove)\n    this.type.insert(diff.pos, diff.insert)\n  })\n}\n\nexport default class TextareaBinding extends Binding {\n  constructor (textType, domTextarea) {\n    // Binding handles textType as this.type and domTextarea as this.target\n    super(textType, domTextarea)\n    // set initial value\n    domTextarea.value = textType.toString()\n    // Observers are handled by this class\n    this._typeObserver = typeObserver.bind(this)\n    this._domObserver = domObserver.bind(this)\n    textType.observe(this._typeObserver)\n    domTextarea.addEventListener('input', this._domObserver)\n  }\n  destroy () {\n    // Remove everything that is handled by this class\n    this.type.unobserve(this._typeObserver)\n    this.target.unobserve(this._domObserver)\n    super.destroy()\n  }\n}\n","\nclass N {\n  // A created node is always red!\n  constructor (val) {\n    this.val = val\n    this.color = true\n    this._left = null\n    this._right = null\n    this._parent = null\n  }\n  isRed () { return this.color }\n  isBlack () { return !this.color }\n  redden () { this.color = true; return this }\n  blacken () { this.color = false; return this }\n  get grandparent () {\n    return this.parent.parent\n  }\n  get parent () {\n    return this._parent\n  }\n  get sibling () {\n    return (this === this.parent.left)\n      ? this.parent.right : this.parent.left\n  }\n  get left () {\n    return this._left\n  }\n  get right () {\n    return this._right\n  }\n  set left (n) {\n    if (n !== null) {\n      n._parent = this\n    }\n    this._left = n\n  }\n  set right (n) {\n    if (n !== null) {\n      n._parent = this\n    }\n    this._right = n\n  }\n  rotateLeft (tree) {\n    var parent = this.parent\n    var newParent = this.right\n    var newRight = this.right.left\n    newParent.left = this\n    this.right = newRight\n    if (parent === null) {\n      tree.root = newParent\n      newParent._parent = null\n    } else if (parent.left === this) {\n      parent.left = newParent\n    } else if (parent.right === this) {\n      parent.right = newParent\n    } else {\n      throw new Error('The elements are wrongly connected!')\n    }\n  }\n  next () {\n    if (this.right !== null) {\n      // search the most left node in the right tree\n      var o = this.right\n      while (o.left !== null) {\n        o = o.left\n      }\n      return o\n    } else {\n      var p = this\n      while (p.parent !== null && p !== p.parent.left) {\n        p = p.parent\n      }\n      return p.parent\n    }\n  }\n  prev () {\n    if (this.left !== null) {\n      // search the most right node in the left tree\n      var o = this.left\n      while (o.right !== null) {\n        o = o.right\n      }\n      return o\n    } else {\n      var p = this\n      while (p.parent !== null && p !== p.parent.right) {\n        p = p.parent\n      }\n      return p.parent\n    }\n  }\n  rotateRight (tree) {\n    var parent = this.parent\n    var newParent = this.left\n    var newLeft = this.left.right\n    newParent.right = this\n    this.left = newLeft\n    if (parent === null) {\n      tree.root = newParent\n      newParent._parent = null\n    } else if (parent.left === this) {\n      parent.left = newParent\n    } else if (parent.right === this) {\n      parent.right = newParent\n    } else {\n      throw new Error('The elements are wrongly connected!')\n    }\n  }\n  getUncle () {\n    // we can assume that grandparent exists when this is called!\n    if (this.parent === this.parent.parent.left) {\n      return this.parent.parent.right\n    } else {\n      return this.parent.parent.left\n    }\n  }\n}\n\n/*\n * This is a Red Black Tree implementation\n */\nexport default class Tree {\n  constructor () {\n    this.root = null\n    this.length = 0\n  }\n  findNext (id) {\n    var nextID = id.clone()\n    nextID.clock += 1\n    return this.findWithLowerBound(nextID)\n  }\n  findPrev (id) {\n    let prevID = id.clone()\n    prevID.clock -= 1\n    return this.findWithUpperBound(prevID)\n  }\n  findNodeWithLowerBound (from) {\n    var o = this.root\n    if (o === null) {\n      return null\n    } else {\n      while (true) {\n        if (from === null || (from.lessThan(o.val._id) && o.left !== null)) {\n          // o is included in the bound\n          // try to find an element that is closer to the bound\n          o = o.left\n        } else if (from !== null && o.val._id.lessThan(from)) {\n          // o is not within the bound, maybe one of the right elements is..\n          if (o.right !== null) {\n            o = o.right\n          } else {\n            // there is no right element. Search for the next bigger element,\n            // this should be within the bounds\n            return o.next()\n          }\n        } else {\n          return o\n        }\n      }\n    }\n  }\n  findNodeWithUpperBound (to) {\n    if (to === void 0) {\n      throw new Error('You must define from!')\n    }\n    var o = this.root\n    if (o === null) {\n      return null\n    } else {\n      while (true) {\n        if ((to === null || o.val._id.lessThan(to)) && o.right !== null) {\n          // o is included in the bound\n          // try to find an element that is closer to the bound\n          o = o.right\n        } else if (to !== null && to.lessThan(o.val._id)) {\n          // o is not within the bound, maybe one of the left elements is..\n          if (o.left !== null) {\n            o = o.left\n          } else {\n            // there is no left element. Search for the prev smaller element,\n            // this should be within the bounds\n            return o.prev()\n          }\n        } else {\n          return o\n        }\n      }\n    }\n  }\n  findSmallestNode () {\n    var o = this.root\n    while (o != null && o.left != null) {\n      o = o.left\n    }\n    return o\n  }\n  findWithLowerBound (from) {\n    var n = this.findNodeWithLowerBound(from)\n    return n == null ? null : n.val\n  }\n  findWithUpperBound (to) {\n    var n = this.findNodeWithUpperBound(to)\n    return n == null ? null : n.val\n  }\n  iterate (from, to, f) {\n    var o\n    if (from === null) {\n      o = this.findSmallestNode()\n    } else {\n      o = this.findNodeWithLowerBound(from)\n    }\n    while (\n      o !== null &&\n      (\n        to === null || // eslint-disable-line no-unmodified-loop-condition\n        o.val._id.lessThan(to) ||\n        o.val._id.equals(to)\n      )\n    ) {\n      f(o.val)\n      o = o.next()\n    }\n  }\n  find (id) {\n    let n = this.findNode(id)\n    if (n !== null) {\n      return n.val\n    } else {\n      return null\n    }\n  }\n  findNode (id) {\n    var o = this.root\n    if (o === null) {\n      return null\n    } else {\n      while (true) {\n        if (o === null) {\n          return null\n        }\n        if (id.lessThan(o.val._id)) {\n          o = o.left\n        } else if (o.val._id.lessThan(id)) {\n          o = o.right\n        } else {\n          return o\n        }\n      }\n    }\n  }\n  delete (id) {\n    var d = this.findNode(id)\n    if (d == null) {\n      // throw new Error('Element does not exist!')\n      return\n    }\n    this.length--\n    if (d.left !== null && d.right !== null) {\n      // switch d with the greates element in the left subtree.\n      // o should have at most one child.\n      var o = d.left\n      // find\n      while (o.right !== null) {\n        o = o.right\n      }\n      // switch\n      d.val = o.val\n      d = o\n    }\n    // d has at most one child\n    // let n be the node that replaces d\n    var isFakeChild\n    var child = d.left || d.right\n    if (child === null) {\n      isFakeChild = true\n      child = new N(null)\n      child.blacken()\n      d.right = child\n    } else {\n      isFakeChild = false\n    }\n\n    if (d.parent === null) {\n      if (!isFakeChild) {\n        this.root = child\n        child.blacken()\n        child._parent = null\n      } else {\n        this.root = null\n      }\n      return\n    } else if (d.parent.left === d) {\n      d.parent.left = child\n    } else if (d.parent.right === d) {\n      d.parent.right = child\n    } else {\n      throw new Error('Impossible!')\n    }\n    if (d.isBlack()) {\n      if (child.isRed()) {\n        child.blacken()\n      } else {\n        this._fixDelete(child)\n      }\n    }\n    this.root.blacken()\n    if (isFakeChild) {\n      if (child.parent.left === child) {\n        child.parent.left = null\n      } else if (child.parent.right === child) {\n        child.parent.right = null\n      } else {\n        throw new Error('Impossible #3')\n      }\n    }\n  }\n  _fixDelete (n) {\n    function isBlack (node) {\n      return node !== null ? node.isBlack() : true\n    }\n    function isRed (node) {\n      return node !== null ? node.isRed() : false\n    }\n    if (n.parent === null) {\n      // this can only be called after the first iteration of fixDelete.\n      return\n    }\n    // d was already replaced by the child\n    // d is not the root\n    // d and child are black\n    var sibling = n.sibling\n    if (isRed(sibling)) {\n      // make sibling the grandfather\n      n.parent.redden()\n      sibling.blacken()\n      if (n === n.parent.left) {\n        n.parent.rotateLeft(this)\n      } else if (n === n.parent.right) {\n        n.parent.rotateRight(this)\n      } else {\n        throw new Error('Impossible #2')\n      }\n      sibling = n.sibling\n    }\n    // parent, sibling, and children of n are black\n    if (n.parent.isBlack() &&\n      sibling.isBlack() &&\n      isBlack(sibling.left) &&\n      isBlack(sibling.right)\n    ) {\n      sibling.redden()\n      this._fixDelete(n.parent)\n    } else if (n.parent.isRed() &&\n      sibling.isBlack() &&\n      isBlack(sibling.left) &&\n      isBlack(sibling.right)\n    ) {\n      sibling.redden()\n      n.parent.blacken()\n    } else {\n      if (n === n.parent.left &&\n        sibling.isBlack() &&\n        isRed(sibling.left) &&\n        isBlack(sibling.right)\n      ) {\n        sibling.redden()\n        sibling.left.blacken()\n        sibling.rotateRight(this)\n        sibling = n.sibling\n      } else if (n === n.parent.right &&\n        sibling.isBlack() &&\n        isRed(sibling.right) &&\n        isBlack(sibling.left)\n      ) {\n        sibling.redden()\n        sibling.right.blacken()\n        sibling.rotateLeft(this)\n        sibling = n.sibling\n      }\n      sibling.color = n.parent.color\n      n.parent.blacken()\n      if (n === n.parent.left) {\n        sibling.right.blacken()\n        n.parent.rotateLeft(this)\n      } else {\n        sibling.left.blacken()\n        n.parent.rotateRight(this)\n      }\n    }\n  }\n  put (v) {\n    var node = new N(v)\n    if (this.root !== null) {\n      var p = this.root // p abbrev. parent\n      while (true) {\n        if (node.val._id.lessThan(p.val._id)) {\n          if (p.left === null) {\n            p.left = node\n            break\n          } else {\n            p = p.left\n          }\n        } else if (p.val._id.lessThan(node.val._id)) {\n          if (p.right === null) {\n            p.right = node\n            break\n          } else {\n            p = p.right\n          }\n        } else {\n          p.val = node.val\n          return p\n        }\n      }\n      this._fixInsert(node)\n    } else {\n      this.root = node\n    }\n    this.length++\n    this.root.blacken()\n    return node\n  }\n  _fixInsert (n) {\n    if (n.parent === null) {\n      n.blacken()\n      return\n    } else if (n.parent.isBlack()) {\n      return\n    }\n    var uncle = n.getUncle()\n    if (uncle !== null && uncle.isRed()) {\n      // Note: parent: red, uncle: red\n      n.parent.blacken()\n      uncle.blacken()\n      n.grandparent.redden()\n      this._fixInsert(n.grandparent)\n    } else {\n      // Note: parent: red, uncle: black or null\n      // Now we transform the tree in such a way that\n      // either of these holds:\n      //   1) grandparent.left.isRed\n      //     and grandparent.left.left.isRed\n      //   2) grandparent.right.isRed\n      //     and grandparent.right.right.isRed\n      if (n === n.parent.right && n.parent === n.grandparent.left) {\n        n.parent.rotateLeft(this)\n        // Since we rotated and want to use the previous\n        // cases, we need to set n in such a way that\n        // n.parent.isRed again\n        n = n.left\n      } else if (n === n.parent.left && n.parent === n.grandparent.right) {\n        n.parent.rotateRight(this)\n        // see above\n        n = n.right\n      }\n      // Case 1) or 2) hold from here on.\n      // Now traverse grandparent, make parent a black node\n      // on the highest level which holds two red nodes.\n      n.parent.blacken()\n      n.grandparent.redden()\n      if (n === n.parent.left) {\n        // Case 1\n        n.grandparent.rotateRight(this)\n      } else {\n        // Case 2\n        n.grandparent.rotateLeft(this)\n      }\n    }\n  }\n  flush () {}\n}\n","\nexport default class ID {\n  constructor (user, clock) {\n    this.user = user\n    this.clock = clock\n  }\n  clone () {\n    return new ID(this.user, this.clock)\n  }\n  equals (id) {\n    return id !== null && id.user === this.user && id.clock === this.clock\n  }\n  lessThan (id) {\n    if (id.constructor === ID) {\n      return this.user < id.user || (this.user === id.user && this.clock < id.clock)\n    } else {\n      return false\n    }\n  }\n}\n","import Tree from '../Util/Tree.js'\nimport ID from '../Util/ID.js'\n\nclass DSNode {\n  constructor (id, len, gc) {\n    this._id = id\n    this.len = len\n    this.gc = gc\n  }\n  clone () {\n    return new DSNode(this._id, this.len, this.gc)\n  }\n}\n\nexport default class DeleteStore extends Tree {\n  logTable () {\n    const deletes = []\n    this.iterate(null, null, function (n) {\n      deletes.push({\n        user: n._id.user,\n        clock: n._id.clock,\n        len: n.len,\n        gc: n.gc\n      })\n    })\n    console.table(deletes)\n  }\n  isDeleted (id) {\n    var n = this.findWithUpperBound(id)\n    return n !== null && n._id.user === id.user && id.clock < n._id.clock + n.len\n  }\n  /*\n   * Mark an operation as deleted. returns the deleted node\n   */\n  markDeleted (id, length) {\n    if (length == null) {\n      throw new Error('length must be defined')\n    }\n    var n = this.findWithUpperBound(id)\n    if (n != null && n._id.user === id.user) {\n      if (n._id.clock <= id.clock && id.clock <= n._id.clock + n.len) {\n        // id is in n's range\n        var diff = id.clock + length - (n._id.clock + n.len) // overlapping right\n        if (diff > 0) {\n          // id+length overlaps n\n          if (!n.gc) {\n            n.len += diff\n          } else {\n            diff = n._id.clock + n.len - id.clock // overlapping left (id till n.end)\n            if (diff < length) {\n              // a partial deletion\n              let nId = id.clone()\n              nId.clock += diff\n              n = new DSNode(nId, length - diff, false)\n              this.put(n)\n            } else {\n              // already gc'd\n              throw new Error(\n                'DS reached an inconsistent state. Please report this issue!'\n              )\n            }\n          }\n        } else {\n          // no overlapping, already deleted\n          return n\n        }\n      } else {\n        // cannot extend left (there is no left!)\n        n = new DSNode(id, length, false)\n        this.put(n) // TODO: you double-put !!\n      }\n    } else {\n      // cannot extend left\n      n = new DSNode(id, length, false)\n      this.put(n)\n    }\n    // can extend right?\n    var next = this.findNext(n._id)\n    if (\n      next != null &&\n      n._id.user === next._id.user &&\n      n._id.clock + n.len >= next._id.clock\n    ) {\n      diff = n._id.clock + n.len - next._id.clock // from next.start to n.end\n      while (diff >= 0) {\n        // n overlaps with next\n        if (next.gc) {\n          // gc is stronger, so reduce length of n\n          n.len -= diff\n          if (diff >= next.len) {\n            // delete the missing range after next\n            diff = diff - next.len // missing range after next\n            if (diff > 0) {\n              this.put(n) // unneccessary? TODO!\n              this.markDeleted(new ID(next._id.user, next._id.clock + next.len), diff)\n            }\n          }\n          break\n        } else {\n          // we can extend n with next\n          if (diff > next.len) {\n            // n is even longer than next\n            // get next.next, and try to extend it\n            var _next = this.findNext(next._id)\n            this.delete(next._id)\n            if (_next == null || n._id.user !== _next._id.user) {\n              break\n            } else {\n              next = _next\n              diff = n._id.clock + n.len - next._id.clock // from next.start to n.end\n              // continue!\n            }\n          } else {\n            // n just partially overlaps with next. extend n, delete next, and break this loop\n            n.len += next.len - diff\n            this.delete(next._id)\n            break\n          }\n        }\n      }\n    }\n    this.put(n)\n    return n\n  }\n}\n","import ID from '../Util/ID.js'\nimport { default as RootID, RootFakeUserID } from '../Util/RootID.js'\n\nexport default class BinaryDecoder {\n  constructor (buffer) {\n    if (buffer instanceof ArrayBuffer) {\n      this.uint8arr = new Uint8Array(buffer)\n    } else if (buffer instanceof Uint8Array || (typeof Buffer !== 'undefined' && buffer instanceof Buffer)) {\n      this.uint8arr = buffer\n    } else {\n      throw new Error('Expected an ArrayBuffer or Uint8Array!')\n    }\n    this.pos = 0\n  }\n  /**\n   * Clone this decoder instance\n   * Optionally set a new position parameter\n   */\n  clone (newPos = this.pos) {\n    let decoder = new BinaryDecoder(this.uint8arr)\n    decoder.pos = newPos\n    return decoder\n  }\n  /**\n   * Number of bytes\n   */\n  get length () {\n    return this.uint8arr.length\n  }\n  /**\n   * Skip one byte, jump to the next position\n   */\n  skip8 () {\n    this.pos++\n  }\n  /**\n   * Read one byte as unsigned integer\n   */\n  readUint8 () {\n    return this.uint8arr[this.pos++]\n  }\n  /**\n   * Read 4 bytes as unsigned integer\n   */\n  readUint32 () {\n    let uint =\n      this.uint8arr[this.pos] +\n      (this.uint8arr[this.pos + 1] << 8) +\n      (this.uint8arr[this.pos + 2] << 16) +\n      (this.uint8arr[this.pos + 3] << 24)\n    this.pos += 4\n    return uint\n  }\n  /**\n   * Look ahead without incrementing position\n   * to the next byte and read it as unsigned integer\n   */\n  peekUint8 () {\n    return this.uint8arr[this.pos]\n  }\n  /**\n   * Read unsigned integer (32bit) with variable length\n   * 1/8th of the storage is used as encoding overhead\n   *  - numbers < 2^7 is stored in one byte\n   *  - numbers < 2^14 is stored in two bytes\n   *  ..\n   */\n  readVarUint () {\n    let num = 0\n    let len = 0\n    while (true) {\n      let r = this.uint8arr[this.pos++]\n      num = num | ((r & 0b1111111) << len)\n      len += 7\n      if (r < 1 << 7) {\n        return num >>> 0 // return unsigned number!\n      }\n      if (len > 35) {\n        throw new Error('Integer out of range!')\n      }\n    }\n  }\n  /**\n   * Read string of variable length\n   * - varUint is used to store the length of the string\n   */\n  readVarString () {\n    let len = this.readVarUint()\n    let bytes = new Array(len)\n    for (let i = 0; i < len; i++) {\n      bytes[i] = this.uint8arr[this.pos++]\n    }\n    let encodedString = String.fromCodePoint(...bytes)\n    return decodeURIComponent(escape(encodedString))\n  }\n  /**\n   *  Look ahead and read varString without incrementing position\n   */\n  peekVarString () {\n    let pos = this.pos\n    let s = this.readVarString()\n    this.pos = pos\n    return s\n  }\n  /**\n   * Read ID\n   * - If first varUint read is 0xFFFFFF a RootID is returned\n   * - Otherwise an ID is returned\n   */\n  readID () {\n    let user = this.readVarUint()\n    if (user === RootFakeUserID) {\n      // read property name and type id\n      const rid = new RootID(this.readVarString(), null)\n      rid.type = this.readVarUint()\n      return rid\n    }\n    return new ID(user, this.readVarUint())\n  }\n}\n","import { RootFakeUserID } from '../Util/RootID.js'\n\nconst bits7 = 0b1111111\nconst bits8 = 0b11111111\n\nexport default class BinaryEncoder {\n  constructor () {\n    // TODO: implement chained Uint8Array buffers instead of Array buffer\n    this.data = []\n  }\n\n  get length () {\n    return this.data.length\n  }\n\n  get pos () {\n    return this.data.length\n  }\n\n  createBuffer () {\n    return Uint8Array.from(this.data).buffer\n  }\n\n  writeUint8 (num) {\n    this.data.push(num & bits8)\n  }\n\n  setUint8 (pos, num) {\n    this.data[pos] = num & bits8\n  }\n\n  writeUint16 (num) {\n    this.data.push(num & bits8, (num >>> 8) & bits8)\n  }\n\n  setUint16 (pos, num) {\n    this.data[pos] = num & bits8\n    this.data[pos + 1] = (num >>> 8) & bits8\n  }\n\n  writeUint32 (num) {\n    for (let i = 0; i < 4; i++) {\n      this.data.push(num & bits8)\n      num >>>= 8\n    }\n  }\n\n  setUint32 (pos, num) {\n    for (let i = 0; i < 4; i++) {\n      this.data[pos + i] = num & bits8\n      num >>>= 8\n    }\n  }\n\n  writeVarUint (num) {\n    while (num >= 0b10000000) {\n      this.data.push(0b10000000 | (bits7 & num))\n      num >>>= 7\n    }\n    this.data.push(bits7 & num)\n  }\n\n  writeVarString (str) {\n    let encodedString = unescape(encodeURIComponent(str))\n    let bytes = encodedString.split('').map(c => c.codePointAt())\n    let len = bytes.length\n    this.writeVarUint(len)\n    for (let i = 0; i < len; i++) {\n      this.data.push(bytes[i])\n    }\n  }\n\n  writeID (id) {\n    const user = id.user\n    this.writeVarUint(user)\n    if (user !== RootFakeUserID) {\n      this.writeVarUint(id.clock)\n    } else {\n      this.writeVarString(id.name)\n      this.writeVarUint(id.type)\n    }\n  }\n}\n","\nexport default class EventHandler {\n  constructor () {\n    this.eventListeners = []\n  }\n  destroy () {\n    this.eventListeners = null\n  }\n  addEventListener (f) {\n    this.eventListeners.push(f)\n  }\n  removeEventListener (f) {\n    this.eventListeners = this.eventListeners.filter(function (g) {\n      return f !== g\n    })\n  }\n  removeAllEventListeners () {\n    this.eventListeners = []\n  }\n  callEventListeners (transaction, event) {\n    for (var i = 0; i < this.eventListeners.length; i++) {\n      try {\n        const f = this.eventListeners[i]\n        f(event)\n      } catch (e) {\n        /*\n          Your observer threw an error. This error was caught so that Yjs\n          can ensure data consistency! In order to debug this error you\n          have to check \"Pause On Caught Exceptions\" in developer tools.\n        */\n        console.error(e)\n      }\n    }\n  }\n}\n","import { splitHelper, default as Item } from './Item.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class ItemJSON extends Item {\n  constructor () {\n    super()\n    this._content = null\n  }\n  _copy () {\n    let struct = super._copy()\n    struct._content = this._content\n    return struct\n  }\n  get _length () {\n    return this._content.length\n  }\n  _fromBinary (y, decoder) {\n    let missing = super._fromBinary(y, decoder)\n    let len = decoder.readVarUint()\n    this._content = new Array(len)\n    for (let i = 0; i < len; i++) {\n      const ctnt = decoder.readVarString()\n      let parsed\n      if (ctnt === 'undefined') {\n        parsed = undefined\n      } else {\n        parsed = JSON.parse(ctnt)\n      }\n      this._content[i] = parsed\n    }\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    let len = this._content.length\n    encoder.writeVarUint(len)\n    for (let i = 0; i < len; i++) {\n      let encoded\n      let content = this._content[i]\n      if (content === undefined) {\n        encoded = 'undefined'\n      } else {\n        encoded = JSON.stringify(content)\n      }\n      encoder.writeVarString(encoded)\n    }\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `ItemJSON(id:${logID(this._id)},content:${JSON.stringify(this._content)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n  _splitAt (y, diff) {\n    if (diff === 0) {\n      return this\n    } else if (diff >= this._length) {\n      return this._right\n    }\n    let item = new ItemJSON()\n    item._content = this._content.splice(diff)\n    splitHelper(y, this, item, diff)\n    return item\n  }\n}\n","import { splitHelper, default as Item } from './Item.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class ItemString extends Item {\n  constructor () {\n    super()\n    this._content = null\n  }\n  _copy () {\n    let struct = super._copy()\n    struct._content = this._content\n    return struct\n  }\n  get _length () {\n    return this._content.length\n  }\n  _fromBinary (y, decoder) {\n    let missing = super._fromBinary(y, decoder)\n    this._content = decoder.readVarString()\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    encoder.writeVarString(this._content)\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `ItemJSON(id:${logID(this._id)},content:${JSON.stringify(this._content)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n  _splitAt (y, diff) {\n    if (diff === 0) {\n      return this\n    } else if (diff >= this._length) {\n      return this._right\n    }\n    let item = new ItemString()\n    item._content = this._content.slice(diff)\n    this._content = this._content.slice(0, diff)\n    splitHelper(y, this, item, diff)\n    return item\n  }\n}\n","\nexport default class YEvent {\n  constructor (target) {\n    this.target = target\n    this.currentTarget = target\n  }\n  get path () {\n    const path = []\n    let type = this.target\n    const y = type._y\n    while (type !== this.currentTarget && type !== y) {\n      let parent = type._parent\n      if (type._parentSub !== null) {\n        path.unshift(type._parentSub)\n      } else {\n        // parent is array-ish\n        for (let [i, child] of parent) {\n          if (child === type) {\n            path.unshift(i)\n            break\n          }\n        }\n      }\n      type = parent\n    }\n    return path\n  }\n}\n","import Type from '../Struct/Type.js'\nimport ItemJSON from '../Struct/ItemJSON.js'\nimport ItemString from '../Struct/ItemString.js'\nimport { logID } from '../MessageHandler/messageToString.js'\nimport YEvent from '../Util/YEvent.js'\n\nclass YArrayEvent extends YEvent {\n  constructor (yarray, remote, transaction) {\n    super(yarray)\n    this.remote = remote\n    this._transaction = transaction\n    this._addedElements = null\n  }\n  get addedElements () {\n    if (this._addedElements === null) {\n      const target = this.target\n      const transaction = this._transaction\n      const addedElements = new Set()\n      transaction.newTypes.forEach(function (type) {\n        if (type._parent === target && !transaction.deletedStructs.has(type)) {\n          addedElements.add(type)\n        }\n      })\n      this._addedElements = addedElements\n    }\n    return this._addedElements\n  }\n  get removedElements () {\n    const target = this.target\n    const transaction = this._transaction\n    const removedElements = new Set()\n    transaction.deletedStructs.forEach(function (struct) {\n      if (struct._parent === target && !transaction.newTypes.has(struct)) {\n        removedElements.add(struct)\n      }\n    })\n    return removedElements\n  }\n}\n\nexport default class YArray extends Type {\n  _callObserver (transaction, parentSubs, remote) {\n    this._callEventHandler(transaction, new YArrayEvent(this, remote, transaction))\n  }\n  get (pos) {\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        if (pos < n._length) {\n          if (n.constructor === ItemJSON || n.constructor === ItemString) {\n            return n._content[pos]\n          } else {\n            return n\n          }\n        }\n        pos -= n._length\n      }\n      n = n._right\n    }\n  }\n  toArray () {\n    return this.map(c => c)\n  }\n  toJSON () {\n    return this.map(c => {\n      if (c instanceof Type) {\n        if (c.toJSON !== null) {\n          return c.toJSON()\n        } else {\n          return c.toString()\n        }\n      }\n      return c\n    })\n  }\n  map (f) {\n    const res = []\n    this.forEach((c, i) => {\n      res.push(f(c, i, this))\n    })\n    return res\n  }\n  forEach (f) {\n    let pos = 0\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        if (n instanceof Type) {\n          f(n, pos++, this)\n        } else {\n          const content = n._content\n          const contentLen = content.length\n          for (let i = 0; i < contentLen; i++) {\n            pos++\n            f(content[i], pos, this)\n          }\n        }\n      }\n      n = n._right\n    }\n  }\n  get length () {\n    let length = 0\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        length += n._length\n      }\n      n = n._right\n    }\n    return length\n  }\n  [Symbol.iterator] () {\n    return {\n      next: function () {\n        while (this._item !== null && (this._item._deleted || this._item._length <= this._itemElement)) {\n          // item is deleted or itemElement does not exist (is deleted)\n          this._item = this._item._right\n          this._itemElement = 0\n        }\n        if (this._item === null) {\n          return {\n            done: true\n          }\n        }\n        let content\n        if (this._item instanceof Type) {\n          content = this._item\n        } else {\n          content = this._item._content[this._itemElement++]\n        }\n        return {\n          value: [this._count, content],\n          done: false\n        }\n      },\n      _item: this._start,\n      _itemElement: 0,\n      _count: 0\n    }\n  }\n  delete (pos, length = 1) {\n    this._y.transact(() => {\n      let item = this._start\n      let count = 0\n      while (item !== null && length > 0) {\n        if (!item._deleted) {\n          if (count <= pos && pos < count + item._length) {\n            const diffDel = pos - count\n            item = item._splitAt(this._y, diffDel)\n            item._splitAt(this._y, length)\n            length -= item._length\n            item._delete(this._y)\n            count += diffDel\n          } else {\n            count += item._length\n          }\n        }\n        item = item._right\n      }\n    })\n    if (length > 0) {\n      throw new Error('Delete exceeds the range of the YArray')\n    }\n  }\n  insertAfter (left, content) {\n    this._transact(y => {\n      let right\n      if (left === null) {\n        right = this._start\n      } else {\n        right = left._right\n      }\n      let prevJsonIns = null\n      for (let i = 0; i < content.length; i++) {\n        let c = content[i]\n        if (typeof c === 'function') {\n          c = new c() // eslint-disable-line new-cap\n        }\n        if (c instanceof Type) {\n          if (prevJsonIns !== null) {\n            if (y !== null) {\n              prevJsonIns._integrate(y)\n            }\n            left = prevJsonIns\n            prevJsonIns = null\n          }\n          c._origin = left\n          c._left = left\n          c._right = right\n          c._right_origin = right\n          c._parent = this\n          if (y !== null) {\n            c._integrate(y)\n          } else if (left === null) {\n            this._start = c\n          } else {\n            left._right = c\n          }\n          left = c\n        } else {\n          if (prevJsonIns === null) {\n            prevJsonIns = new ItemJSON()\n            prevJsonIns._origin = left\n            prevJsonIns._left = left\n            prevJsonIns._right = right\n            prevJsonIns._right_origin = right\n            prevJsonIns._parent = this\n            prevJsonIns._content = []\n          }\n          prevJsonIns._content.push(c)\n        }\n      }\n      if (prevJsonIns !== null) {\n        if (y !== null) {\n          prevJsonIns._integrate(y)\n        } else if (prevJsonIns._left === null) {\n          this._start = prevJsonIns\n        }\n      }\n    })\n  }\n  insert (pos, content) {\n    let left = null\n    let right = this._start\n    let count = 0\n    const y = this._y\n    while (right !== null) {\n      const rightLen = right._deleted ? 0 : (right._length - 1)\n      if (count <= pos && pos <= count + rightLen) {\n        const splitDiff = pos - count\n        right = right._splitAt(y, splitDiff)\n        left = right._left\n        count += splitDiff\n        break\n      }\n      if (!right._deleted) {\n        count += right._length\n      }\n      left = right\n      right = right._right\n    }\n    if (pos > count) {\n      throw new Error('Position exceeds array range!')\n    }\n    this.insertAfter(left, content)\n  }\n  push (content) {\n    let n = this._start\n    let lastUndeleted = null\n    while (n !== null) {\n      if (!n._deleted) {\n        lastUndeleted = n\n      }\n      n = n._right\n    }\n    this.insertAfter(lastUndeleted, content)\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YArray(id:${logID(this._id)},start:${logID(this._start)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import Type from '../Struct/Type.js'\nimport Item from '../Struct/Item.js'\nimport ItemJSON from '../Struct/ItemJSON.js'\nimport { logID } from '../MessageHandler/messageToString.js'\nimport YEvent from '../Util/YEvent.js'\n\nclass YMapEvent extends YEvent {\n  constructor (ymap, subs, remote) {\n    super(ymap)\n    this.keysChanged = subs\n    this.remote = remote\n  }\n}\n\nexport default class YMap extends Type {\n  _callObserver (transaction, parentSubs, remote) {\n    this._callEventHandler(transaction, new YMapEvent(this, parentSubs, remote))\n  }\n  toJSON () {\n    const map = {}\n    for (let [key, item] of this._map) {\n      if (!item._deleted) {\n        let res\n        if (item instanceof Type) {\n          if (item.toJSON !== undefined) {\n            res = item.toJSON()\n          } else {\n            res = item.toString()\n          }\n        } else {\n          res = item._content[0]\n        }\n        map[key] = res\n      }\n    }\n    return map\n  }\n  keys () {\n    let keys = []\n    for (let [key, value] of this._map) {\n      if (!value._deleted) {\n        keys.push(key)\n      }\n    }\n    return keys\n  }\n  delete (key) {\n    this._transact((y) => {\n      let c = this._map.get(key)\n      if (y !== null && c !== undefined) {\n        c._delete(y)\n      }\n    })\n  }\n  set (key, value) {\n    this._transact(y => {\n      const old = this._map.get(key) || null\n      if (old !== null) {\n        if (old.constructor === ItemJSON && !old._deleted && old._content[0] === value) {\n          // Trying to overwrite with same value\n          // break here\n          return value\n        }\n        if (y !== null) {\n          old._delete(y)\n        }\n      }\n      let v\n      if (typeof value === 'function') {\n        v = new value() // eslint-disable-line new-cap\n        value = v\n      } else if (value instanceof Item) {\n        v = value\n      } else {\n        v = new ItemJSON()\n        v._content = [value]\n      }\n      v._right = old\n      v._right_origin = old\n      v._parent = this\n      v._parentSub = key\n      if (y !== null) {\n        v._integrate(y)\n      } else {\n        this._map.set(key, v)\n      }\n    })\n    return value\n  }\n  get (key) {\n    let v = this._map.get(key)\n    if (v === undefined || v._deleted) {\n      return undefined\n    }\n    if (v instanceof Type) {\n      return v\n    } else {\n      return v._content[v._content.length - 1]\n    }\n  }\n  has (key) {\n    let v = this._map.get(key)\n    if (v === undefined || v._deleted) {\n      return false\n    } else {\n      return true\n    }\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YMap(id:${logID(this._id)},mapSize:${this._map.size},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import ItemString from '../Struct/ItemString.js'\nimport YArray from './YArray.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class YText extends YArray {\n  constructor (string) {\n    super()\n    if (typeof string === 'string') {\n      const start = new ItemString()\n      start._parent = this\n      start._content = string\n      this._start = start\n    }\n  }\n  toString () {\n    const strBuilder = []\n    let n = this._start\n    while (n !== null) {\n      if (!n._deleted) {\n        strBuilder.push(n._content)\n      }\n      n = n._right\n    }\n    return strBuilder.join('')\n  }\n  insert (pos, text) {\n    if (text.length <= 0) {\n      return\n    }\n    this._transact(y => {\n      let left = null\n      let right = this._start\n      let count = 0\n      while (right !== null) {\n        const rightLen = right._deleted ? 0 : (right._length - 1)\n        if (count <= pos && pos <= count + rightLen) {\n          const splitDiff = pos - count\n          right = right._splitAt(this._y, splitDiff)\n          left = right._left\n          count += splitDiff\n          break\n        }\n        if (!right._deleted) {\n          count += right._length\n        }\n        left = right\n        right = right._right\n      }\n      if (pos > count) {\n        throw new Error('Position exceeds array range!')\n      }\n      let item = new ItemString()\n      item._origin = left\n      item._left = left\n      item._right = right\n      item._right_origin = right\n      item._parent = this\n      item._content = text\n      if (y !== null) {\n        item._integrate(this._y)\n      } else if (left === null) {\n        this._start = item\n      } else {\n        left._right = item\n      }\n    })\n  }\n  _logString () {\n    const left = this._left !== null ? this._left._lastId : null\n    const origin = this._origin !== null ? this._origin._lastId : null\n    return `YText(id:${logID(this._id)},start:${logID(this._start)},left:${logID(left)},origin:${logID(origin)},right:${logID(this._right)},parent:${logID(this._parent)},parentSub:${this._parentSub})`\n  }\n}\n","import YEvent from '../../Util/YEvent.js'\n\nexport default class YXmlEvent extends YEvent {\n  constructor (target, subs, remote) {\n    super(target)\n    this.childListChanged = false\n    this.attributesChanged = new Set()\n    this.remote = remote\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.attributesChanged.add(sub)\n      }\n    })\n  }\n}\n","import { defaultDomFilter } from './utils.js'\n\nimport YMap from '../YMap.js'\nimport { YXmlFragment } from './y-xml.js'\n\nexport default class YXmlElement extends YXmlFragment {\n  constructor (arg1, arg2, _document) {\n    super()\n    this.nodeName = null\n    this._scrollElement = null\n    if (typeof arg1 === 'string') {\n      this.nodeName = arg1.toUpperCase()\n    } else if (arg1 != null && arg1.nodeType != null && arg1.nodeType === arg1.ELEMENT_NODE) {\n      this.nodeName = arg1.nodeName\n      this._setDom(arg1, _document)\n    } else {\n      this.nodeName = 'UNDEFINED'\n    }\n    if (typeof arg2 === 'function') {\n      this._domFilter = arg2\n    }\n  }\n  _copy () {\n    let struct = super._copy()\n    struct.nodeName = this.nodeName\n    return struct\n  }\n  _setDom (dom, _document) {\n    if (this._dom != null) {\n      throw new Error('Only call this method if you know what you are doing ;)')\n    } else if (dom._yxml != null) { // TODO do i need to check this? - no.. but for dev purps..\n      throw new Error('Already bound to an YXml type')\n    } else {\n      // tag is already set in constructor\n      // set attributes\n      let attributes = new Map()\n      for (let i = 0; i < dom.attributes.length; i++) {\n        let attr = dom.attributes[i]\n        // get attribute via getAttribute for custom element support (some write something different in attr.value)\n        attributes.set(attr.name, dom.getAttribute(attr.name))\n      }\n      attributes = this._domFilter(dom, attributes)\n      attributes.forEach((value, name) => {\n        this.setAttribute(name, value)\n      })\n      this.insertDomElements(0, Array.prototype.slice.call(dom.childNodes), _document)\n      this._bindToDom(dom, _document)\n      return dom\n    }\n  }\n  _bindToDom (dom, _document) {\n    _document = _document || document\n    this._dom = dom\n    dom._yxml = this\n  }\n  _fromBinary (y, decoder) {\n    const missing = super._fromBinary(y, decoder)\n    this.nodeName = decoder.readVarString()\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    encoder.writeVarString(this.nodeName)\n  }\n  _integrate (y) {\n    if (this.nodeName === null) {\n      throw new Error('nodeName must be defined!')\n    }\n    if (this._domFilter === defaultDomFilter && this._parent._domFilter !== undefined) {\n      this._domFilter = this._parent._domFilter\n    }\n    super._integrate(y)\n  }\n  /**\n   * Returns the string representation of the XML document.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   */\n  toString () {\n    const attrs = this.getAttributes()\n    const stringBuilder = []\n    const keys = []\n    for (let key in attrs) {\n      keys.push(key)\n    }\n    keys.sort()\n    const keysLen = keys.length\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i]\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"')\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase()\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : ''\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n  removeAttribute () {\n    return YMap.prototype.delete.apply(this, arguments)\n  }\n\n  setAttribute () {\n    return YMap.prototype.set.apply(this, arguments)\n  }\n\n  getAttribute () {\n    return YMap.prototype.get.apply(this, arguments)\n  }\n\n  getAttributes () {\n    const obj = {}\n    for (let [key, value] of this._map) {\n      if (!value._deleted) {\n        obj[key] = value._content[0]\n      }\n    }\n    return obj\n  }\n  getDom (_document) {\n    _document = _document || document\n    let dom = this._dom\n    if (dom == null) {\n      dom = _document.createElement(this.nodeName)\n      dom._yxml = this\n      let attrs = this.getAttributes()\n      for (let key in attrs) {\n        dom.setAttribute(key, attrs[key])\n      }\n      this.forEach(yxml => {\n        dom.appendChild(yxml.getDom(_document))\n      })\n      this._bindToDom(dom, _document)\n    }\n    return dom\n  }\n}\n","import YMap from '../YMap.js'\nimport { getHook, addHook } from './hooks.js'\n\nexport default class YXmlHook extends YMap {\n  constructor (hookName, dom) {\n    super()\n    this._dom = null\n    this.hookName = null\n    if (hookName !== undefined) {\n      this.hookName = hookName\n      this._dom = dom\n      dom._yjsHook = hookName\n      dom._yxml = this\n      getHook(hookName).fillType(dom, this)\n    }\n  }\n  _copy () {\n    const struct = super._copy()\n    struct.hookName = this.hookName\n    return struct\n  }\n  getDom (_document) {\n    _document = _document || document\n    if (this._dom === null) {\n      const dom = getHook(this.hookName).createDom(this)\n      this._dom = dom\n      dom._yxml = this\n      dom._yjsHook = this.hookName\n    }\n    return this._dom\n  }\n  _unbindFromDom () {\n    this._dom._yxml = null\n    this._yxml = null\n    // TODO: cleanup hook?\n  }\n  _fromBinary (y, decoder) {\n    const missing = super._fromBinary(y, decoder)\n    this.hookName = decoder.readVarString()\n    return missing\n  }\n  _toBinary (encoder) {\n    super._toBinary(encoder)\n    encoder.writeVarString(this.hookName)\n  }\n  _integrate (y) {\n    if (this.hookName === null) {\n      throw new Error('hookName must be defined!')\n    }\n    super._integrate(y)\n  }\n  setDomFilter () {\n    // TODO: implement new modfilter method!\n  }\n  enableSmartScrolling () {\n    // TODO: implement new smartscrolling method!\n  }\n}\nYXmlHook.addHook = addHook\n","import YText from '../YText.js'\n\nexport default class YXmlText extends YText {\n  constructor (arg1) {\n    let dom = null\n    let initialText = null\n    if (arg1 != null) {\n      if (arg1.nodeType != null && arg1.nodeType === arg1.TEXT_NODE) {\n        dom = arg1\n        initialText = dom.nodeValue\n      } else if (typeof arg1 === 'string') {\n        initialText = arg1\n      }\n    }\n    super(initialText)\n    this._dom = null\n    this._domObserver = null\n    this._domObserverListener = null\n    this._scrollElement = null\n    if (dom !== null) {\n      this._setDom(arg1)\n    }\n    /*\n    var token = true\n    this._mutualExclude = f => {\n      if (token) {\n        token = false\n        try {\n          f()\n        } catch (e) {\n          console.error(e)\n        }\n        this._domObserver.takeRecords()\n        token = true\n      }\n    }\n    this.observe(event => {\n      if (this._dom != null) {\n        const dom = this._dom\n        this._mutualExclude(() => {\n          let anchorViewPosition = getAnchorViewPosition(this._scrollElement)\n          let anchorViewFix\n          if (anchorViewPosition !== null && (anchorViewPosition.anchor !== null || getBoundingClientRect(this._dom).top <= 0)) {\n            anchorViewFix = anchorViewPosition\n          } else {\n            anchorViewFix = null\n          }\n          dom.nodeValue = this.toString()\n          fixScrollPosition(this._scrollElement, anchorViewFix)\n        })\n      }\n    })\n    */\n  }\n  setDomFilter () {}\n  enableSmartScrolling (scrollElement) {\n    this._scrollElement = scrollElement\n  }\n  _setDom (dom) {\n    if (this._dom != null) {\n      this._unbindFromDom()\n    }\n    if (dom._yxml != null) {\n      dom._yxml._unbindFromDom()\n    }\n    // set marker\n    this._dom = dom\n    dom._yxml = this\n  }\n  getDom (_document) {\n    _document = _document || document\n    if (this._dom === null) {\n      const dom = _document.createTextNode(this.toString())\n      this._setDom(dom)\n      return dom\n    }\n    return this._dom\n  }\n  _delete (y, createDelete) {\n    this._unbindFromDom()\n    super._delete(y, createDelete)\n  }\n  _unbindFromDom () {\n    if (this._domObserver != null) {\n      this._domObserver.disconnect()\n      this._domObserver = null\n    }\n    if (this._dom != null) {\n      this._dom._yxml = null\n      this._dom = null\n    }\n  }\n}\n","\nimport YXmlFragment from './YXmlFragment.js'\nimport YXmlElement from './YXmlElement.js'\nimport YXmlHook from './YXmlHook.js'\n\nexport { default as YXmlFragment } from './YXmlFragment.js'\nexport { default as YXmlElement } from './YXmlElement.js'\nexport { default as YXmlText } from './YXmlText.js'\nexport { default as YXmlHook } from './YXmlHook.js'\n\nYXmlFragment._YXmlElement = YXmlElement\nYXmlFragment._YXmlHook = YXmlHook\n","import { getReference } from './structReferences.js'\n\nexport const RootFakeUserID = 0xFFFFFF\n\nexport default class RootID {\n  constructor (name, typeConstructor) {\n    this.user = RootFakeUserID\n    this.name = name\n    this.type = getReference(typeConstructor)\n  }\n  equals (id) {\n    return id !== null && id.user === this.user && id.name === this.name && id.type === this.type\n  }\n  lessThan (id) {\n    if (id.constructor === RootID) {\n      return this.user < id.user || (this.user === id.user && (this.name < id.name || (this.name === id.name && this.type < id.type)))\n    } else {\n      return true\n    }\n  }\n}\n","import Tree from '../Util/Tree.js'\nimport RootID from '../Util/RootID.js'\nimport { getStruct } from '../Util/structReferences.js'\nimport { logID } from '../MessageHandler/messageToString.js'\n\nexport default class OperationStore extends Tree {\n  constructor (y) {\n    super()\n    this.y = y\n  }\n  logTable () {\n    const items = []\n    this.iterate(null, null, function (item) {\n      items.push({\n        id: logID(item),\n        origin: logID(item._origin === null ? null : item._origin._lastId),\n        left: logID(item._left === null ? null : item._left._lastId),\n        right: logID(item._right),\n        right_origin: logID(item._right_origin),\n        parent: logID(item._parent),\n        parentSub: item._parentSub,\n        deleted: item._deleted,\n        content: JSON.stringify(item._content)\n      })\n    })\n    console.table(items)\n  }\n  get (id) {\n    let struct = this.find(id)\n    if (struct === null && id instanceof RootID) {\n      const Constr = getStruct(id.type)\n      const y = this.y\n      struct = new Constr()\n      struct._id = id\n      struct._parent = y\n      y.transact(() => {\n        struct._integrate(y)\n      })\n      this.put(struct)\n    }\n    return struct\n  }\n  // Use getItem for structs with _length > 1\n  getItem (id) {\n    var item = this.findWithUpperBound(id)\n    if (item === null) {\n      return null\n    }\n    const itemID = item._id\n    if (id.user === itemID.user && id.clock < itemID.clock + item._length) {\n      return item\n    } else {\n      return null\n    }\n  }\n  // Return an insertion such that id is the first element of content\n  // This function manipulates an item, if necessary\n  getItemCleanStart (id) {\n    var ins = this.getItem(id)\n    if (ins === null || ins._length === 1) {\n      return ins\n    }\n    const insID = ins._id\n    if (insID.clock === id.clock) {\n      return ins\n    } else {\n      return ins._splitAt(this.y, id.clock - insID.clock)\n    }\n  }\n  // Return an insertion such that id is the last element of content\n  // This function manipulates an operation, if necessary\n  getItemCleanEnd (id) {\n    var ins = this.getItem(id)\n    if (ins === null || ins._length === 1) {\n      return ins\n    }\n    const insID = ins._id\n    if (insID.clock + ins._length - 1 === id.clock) {\n      return ins\n    } else {\n      ins._splitAt(this.y, id.clock - insID.clock + 1)\n      return ins\n    }\n  }\n}\n","import ID from '../Util/ID.js'\n\nexport default class StateStore {\n  constructor (y) {\n    this.y = y\n    this.state = new Map()\n  }\n  logTable () {\n    const entries = []\n    for (let [user, state] of this.state) {\n      entries.push({\n        user, state\n      })\n    }\n    console.table(entries)\n  }\n  getNextID (len) {\n    const user = this.y.userID\n    const state = this.getState(user)\n    this.setState(user, state + len)\n    return new ID(user, state)\n  }\n  updateRemoteState (struct) {\n    let user = struct._id.user\n    let userState = this.state.get(user)\n    while (struct !== null && struct._id.clock === userState) {\n      userState += struct._length\n      struct = this.y.os.get(new ID(user, userState))\n    }\n    this.state.set(user, userState)\n  }\n  getState (user) {\n    let state = this.state.get(user)\n    if (state == null) {\n      return 0\n    }\n    return state\n  }\n  setState (user, state) {\n    // TODO: modify missingi structs here\n    const beforeState = this.y._transaction.beforeState\n    if (!beforeState.has(user)) {\n      beforeState.set(user, this.getState(user))\n    }\n    this.state.set(user, state)\n  }\n}\n","export default class NamedEventHandler {\n  constructor () {\n    this._eventListener = new Map()\n    this._stateListener = new Map()\n  }\n  _getListener (name) {\n    let listeners = this._eventListener.get(name)\n    if (listeners === undefined) {\n      listeners = {\n        once: new Set(),\n        on: new Set()\n      }\n      this._eventListener.set(name, listeners)\n    }\n    return listeners\n  }\n  once (name, f) {\n    let listeners = this._getListener(name)\n    listeners.once.add(f)\n  }\n  on (name, f) {\n    let listeners = this._getListener(name)\n    listeners.on.add(f)\n  }\n  _initStateListener (name) {\n    let state = this._stateListener.get(name)\n    if (state === undefined) {\n      state = {}\n      state.promise = new Promise(function (resolve) {\n        state.resolve = resolve\n      })\n      this._stateListener.set(name, state)\n    }\n    return state\n  }\n  when (name) {\n    return this._initStateListener(name).promise\n  }\n  off (name, f) {\n    if (name == null || f == null) {\n      throw new Error('You must specify event name and function!')\n    }\n    const listener = this._eventListener.get(name)\n    if (listener !== undefined) {\n      listener.on.delete(f)\n      listener.once.delete(f)\n    }\n  }\n  emit (name, ...args) {\n    this._initStateListener(name).resolve()\n    const listener = this._eventListener.get(name)\n    if (listener !== undefined) {\n      listener.on.forEach(f => f.apply(null, args))\n      listener.once.forEach(f => f.apply(null, args))\n      listener.once = new Set()\n    } else if (name === 'error') {\n      console.error(args[0])\n    }\n  }\n  destroy () {\n    this._eventListener = null\n  }\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","import BinaryEncoder from './Binary/Encoder.js'\nimport BinaryDecoder from './Binary/Decoder.js'\n\nimport { sendSyncStep1, readSyncStep1 } from './MessageHandler/syncStep1.js'\nimport { readSyncStep2 } from './MessageHandler/syncStep2.js'\nimport { integrateRemoteStructs } from './MessageHandler/integrateRemoteStructs.js'\n\nimport debug from 'debug'\n\nexport default class AbstractConnector {\n  constructor (y, opts) {\n    this.y = y\n    this.opts = opts\n    if (opts.role == null || opts.role === 'master') {\n      this.role = 'master'\n    } else if (opts.role === 'slave') {\n      this.role = 'slave'\n    } else {\n      throw new Error(\"Role must be either 'master' or 'slave'!\")\n    }\n    this.log = debug('y:connector')\n    this.logMessage = debug('y:connector-message')\n    this._forwardAppliedStructs = opts.forwardAppliedOperations || false // TODO: rename\n    this.role = opts.role\n    this.connections = new Map()\n    this.isSynced = false\n    this.userEventListeners = []\n    this.whenSyncedListeners = []\n    this.currentSyncTarget = null\n    this.debug = opts.debug === true\n    this.broadcastBuffer = new BinaryEncoder()\n    this.broadcastBufferSize = 0\n    this.protocolVersion = 11\n    this.authInfo = opts.auth || null\n    this.checkAuth = opts.checkAuth || function () { return Promise.resolve('write') } // default is everyone has write access\n    if (opts.maxBufferLength == null) {\n      this.maxBufferLength = -1\n    } else {\n      this.maxBufferLength = opts.maxBufferLength\n    }\n  }\n\n  reconnect () {\n    this.log('reconnecting..')\n  }\n\n  disconnect () {\n    this.log('discronnecting..')\n    this.connections = new Map()\n    this.isSynced = false\n    this.currentSyncTarget = null\n    this.whenSyncedListeners = []\n    return Promise.resolve()\n  }\n\n  onUserEvent (f) {\n    this.userEventListeners.push(f)\n  }\n\n  removeUserEventListener (f) {\n    this.userEventListeners = this.userEventListeners.filter(g => f !== g)\n  }\n\n  userLeft (user) {\n    if (this.connections.has(user)) {\n      this.log('%s: User left %s', this.y.userID, user)\n      this.connections.delete(user)\n      // check if isSynced event can be sent now\n      this._setSyncedWith(null)\n      for (var f of this.userEventListeners) {\n        f({\n          action: 'userLeft',\n          user: user\n        })\n      }\n    }\n  }\n\n  userJoined (user, role, auth) {\n    if (role == null) {\n      throw new Error('You must specify the role of the joined user!')\n    }\n    if (this.connections.has(user)) {\n      throw new Error('This user already joined!')\n    }\n    this.log('%s: User joined %s', this.y.userID, user)\n    this.connections.set(user, {\n      uid: user,\n      isSynced: false,\n      role: role,\n      processAfterAuth: [],\n      processAfterSync: [],\n      auth: auth || null,\n      receivedSyncStep2: false\n    })\n    let defer = {}\n    defer.promise = new Promise(function (resolve) { defer.resolve = resolve })\n    this.connections.get(user).syncStep2 = defer\n    for (var f of this.userEventListeners) {\n      f({\n        action: 'userJoined',\n        user: user,\n        role: role\n      })\n    }\n    this._syncWithUser(user)\n  }\n\n  // Execute a function _when_ we are connected.\n  // If not connected, wait until connected\n  whenSynced (f) {\n    if (this.isSynced) {\n      f()\n    } else {\n      this.whenSyncedListeners.push(f)\n    }\n  }\n\n  _syncWithUser (userID) {\n    if (this.role === 'slave') {\n      return // \"The current sync has not finished or this is controlled by a master!\"\n    }\n    sendSyncStep1(this, userID)\n  }\n\n  _fireIsSyncedListeners () {\n    if (!this.isSynced) {\n      this.isSynced = true\n      // It is safer to remove this!\n      // call whensynced listeners\n      for (var f of this.whenSyncedListeners) {\n        f()\n      }\n      this.whenSyncedListeners = []\n      this.y._setContentReady()\n      this.y.emit('synced')\n    }\n  }\n\n  send (uid, buffer) {\n    const y = this.y\n    if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n      throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\\'t use this method to send custom messages')\n    }\n    this.log('User%s to User%s: Send \\'%y\\'', y.userID, uid, buffer)\n    this.logMessage('User%s to User%s: Send %Y', y.userID, uid, [y, buffer])\n  }\n\n  broadcast (buffer) {\n    const y = this.y\n    if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n      throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - don\\'t use this method to send custom messages')\n    }\n    this.log('User%s: Broadcast \\'%y\\'', y.userID, buffer)\n    this.logMessage('User%s: Broadcast: %Y', y.userID, [y, buffer])\n  }\n\n  /*\n    Buffer operations, and broadcast them when ready.\n  */\n  broadcastStruct (struct) {\n    const firstContent = this.broadcastBuffer.length === 0\n    if (firstContent) {\n      this.broadcastBuffer.writeVarString(this.y.room)\n      this.broadcastBuffer.writeVarString('update')\n      this.broadcastBufferSize = 0\n      this.broadcastBufferSizePos = this.broadcastBuffer.pos\n      this.broadcastBuffer.writeUint32(0)\n    }\n    this.broadcastBufferSize++\n    struct._toBinary(this.broadcastBuffer)\n    if (this.maxBufferLength > 0 && this.broadcastBuffer.length > this.maxBufferLength) {\n      // it is necessary to send the buffer now\n      // cache the buffer and check if server is responsive\n      const buffer = this.broadcastBuffer\n      buffer.setUint32(this.broadcastBufferSizePos, this.broadcastBufferSize)\n      this.broadcastBuffer = new BinaryEncoder()\n      this.whenRemoteResponsive().then(() => {\n        this.broadcast(buffer.createBuffer())\n      })\n    } else if (firstContent) {\n      // send the buffer when all transactions are finished\n      // (or buffer exceeds maxBufferLength)\n      setTimeout(() => {\n        if (this.broadcastBuffer.length > 0) {\n          const buffer = this.broadcastBuffer\n          buffer.setUint32(this.broadcastBufferSizePos, this.broadcastBufferSize)\n          this.broadcast(buffer.createBuffer())\n          this.broadcastBuffer = new BinaryEncoder()\n        }\n      }, 0)\n    }\n  }\n\n  /*\n   * Somehow check the responsiveness of the remote clients/server\n   * Default behavior:\n   *   Wait 100ms before broadcasting the next batch of operations\n   *\n   * Only used when maxBufferLength is set\n   *\n   */\n  whenRemoteResponsive () {\n    return new Promise(function (resolve) {\n      setTimeout(resolve, 100)\n    })\n  }\n\n  /*\n    You received a raw message, and you know that it is intended for Yjs. Then call this function.\n  */\n  receiveMessage (sender, buffer, skipAuth) {\n    const y = this.y\n    const userID = y.userID\n    skipAuth = skipAuth || false\n    if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n      return Promise.reject(new Error('Expected Message to be an ArrayBuffer or Uint8Array!'))\n    }\n    if (sender === userID) {\n      return Promise.resolve()\n    }\n    let decoder = new BinaryDecoder(buffer)\n    let encoder = new BinaryEncoder()\n    let roomname = decoder.readVarString() // read room name\n    encoder.writeVarString(roomname)\n    let messageType = decoder.readVarString()\n    let senderConn = this.connections.get(sender)\n    this.log('User%s from User%s: Receive \\'%s\\'', userID, sender, messageType)\n    this.logMessage('User%s from User%s: Receive %Y', userID, sender, [y, buffer])\n    if (senderConn == null && !skipAuth) {\n      throw new Error('Received message from unknown peer!')\n    }\n    if (messageType === 'sync step 1' || messageType === 'sync step 2') {\n      let auth = decoder.readVarUint()\n      if (senderConn.auth == null) {\n        senderConn.processAfterAuth.push([messageType, senderConn, decoder, encoder, sender])\n        // check auth\n        return this.checkAuth(auth, y, sender).then(authPermissions => {\n          if (senderConn.auth == null) {\n            senderConn.auth = authPermissions\n            y.emit('userAuthenticated', {\n              user: senderConn.uid,\n              auth: authPermissions\n            })\n          }\n          let messages = senderConn.processAfterAuth\n          senderConn.processAfterAuth = []\n\n          messages.forEach(m =>\n            this.computeMessage(m[0], m[1], m[2], m[3], m[4])\n          )\n        })\n      }\n    }\n    if ((skipAuth || senderConn.auth != null) && (messageType !== 'update' || senderConn.isSynced)) {\n      this.computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth)\n    } else {\n      senderConn.processAfterSync.push([messageType, senderConn, decoder, encoder, sender, false])\n    }\n  }\n\n  computeMessage (messageType, senderConn, decoder, encoder, sender, skipAuth) {\n    if (messageType === 'sync step 1' && (senderConn.auth === 'write' || senderConn.auth === 'read')) {\n      // cannot wait for sync step 1 to finish, because we may wait for sync step 2 in sync step 1 (->lock)\n      readSyncStep1(decoder, encoder, this.y, senderConn, sender)\n    } else {\n      const y = this.y\n      y.transact(function () {\n        if (messageType === 'sync step 2' && senderConn.auth === 'write') {\n          readSyncStep2(decoder, encoder, y, senderConn, sender)\n        } else if (messageType === 'update' && (skipAuth || senderConn.auth === 'write')) {\n          integrateRemoteStructs(y, decoder)\n        } else {\n          throw new Error('Unable to receive message')\n        }\n      }, true)\n    }\n  }\n\n  _setSyncedWith (user) {\n    if (user != null) {\n      const userConn = this.connections.get(user)\n      userConn.isSynced = true\n      const messages = userConn.processAfterSync\n      userConn.processAfterSync = []\n      messages.forEach(m => {\n        this.computeMessage(m[0], m[1], m[2], m[3], m[4])\n      })\n    }\n    const conns = Array.from(this.connections.values())\n    if (conns.length > 0 && conns.every(u => u.isSynced)) {\n      this._fireIsSyncedListeners()\n    }\n  }\n}\n","\nimport { createMutualExclude } from '../Util/mutualExclude.js'\n\nexport default class Binding {\n  constructor (type, target) {\n    this.type = type\n    this.target = target\n    this._mutualExclude = createMutualExclude()\n  }\n  destroy () {\n    this.type = null\n    this.target = null\n  }\n}\n","import DeleteStore from './Store/DeleteStore.js'\nimport OperationStore from './Store/OperationStore.js'\nimport StateStore from './Store/StateStore.js'\nimport { generateUserID } from './Util/generateUserID.js'\nimport RootID from './Util/RootID.js'\nimport NamedEventHandler from './Util/NamedEventHandler.js'\nimport UndoManager from './Util/UndoManager.js'\nimport { integrateRemoteStructs } from './MessageHandler/integrateRemoteStructs.js'\n\nimport { messageToString, messageToRoomname } from './MessageHandler/messageToString.js'\n\nimport Connector from './Connector.js'\nimport Persistence from './Persistence.js'\nimport YArray from './Type/YArray.js'\nimport YMap from './Type/YMap.js'\nimport YText from './Type/YText.js'\nimport { YXmlFragment, YXmlElement, YXmlText, YXmlHook } from './Type/y-xml/y-xml.js'\nimport BinaryDecoder from './Binary/Decoder.js'\nimport { getRelativePosition, fromRelativePosition } from './Util/relativePosition.js'\nimport { addStruct as addType } from './Util/structReferences.js'\n\nimport debug from 'debug'\nimport Transaction from './Transaction.js'\n\nimport TextareaBinding from './Binding/TextareaBinding.js'\n\nimport { toBinary, fromBinary } from './MessageHandler/binaryEncode.js'\n\nexport default class Y extends NamedEventHandler {\n  constructor (room, opts, persistence) {\n    super()\n    this.room = room\n    if (opts != null) {\n      opts.connector.room = room\n    }\n    this._contentReady = false\n    this._opts = opts\n    this.userID = generateUserID()\n    this.share = {}\n    this.ds = new DeleteStore(this)\n    this.os = new OperationStore(this)\n    this.ss = new StateStore(this)\n    this._missingStructs = new Map()\n    this._readyToIntegrate = []\n    this._transaction = null\n    this.connector = null\n    this.connected = false\n    let initConnection = () => {\n      if (opts != null) {\n        this.connector = new Y[opts.connector.name](this, opts.connector)\n        this.connected = true\n        this.emit('connectorReady')\n      }\n    }\n    if (persistence != null) {\n      this.persistence = persistence\n      persistence._init(this).then(initConnection)\n    } else {\n      this.persistence = null\n      initConnection()\n    }\n  }\n  _setContentReady () {\n    if (!this._contentReady) {\n      this._contentReady = true\n      this.emit('content')\n    }\n  }\n  whenContentReady () {\n    if (this._contentReady) {\n      return Promise.resolve()\n    } else {\n      return new Promise(resolve => {\n        this.once('content', resolve)\n      })\n    }\n  }\n  _beforeChange () {}\n  transact (f, remote = false) {\n    let initialCall = this._transaction === null\n    if (initialCall) {\n      this._transaction = new Transaction(this)\n      this.emit('beforeTransaction', this, this._transaction, remote)\n    }\n    try {\n      f(this)\n    } catch (e) {\n      console.error(e)\n    }\n    if (initialCall) {\n      this.emit('beforeObserverCalls', this, this._transaction, remote)\n      const transaction = this._transaction\n      this._transaction = null\n      // emit change events on changed types\n      transaction.changedTypes.forEach(function (subs, type) {\n        if (!type._deleted) {\n          type._callObserver(transaction, subs, remote)\n        }\n      })\n      transaction.changedParentTypes.forEach(function (events, type) {\n        if (!type._deleted) {\n          events = events\n            .filter(event =>\n              !event.target._deleted\n            )\n          events\n            .forEach(event => {\n              event.currentTarget = type\n            })\n          // we don't have to check for events.length\n          // because there is no way events is empty..\n          type._deepEventHandler.callEventListeners(transaction, events)\n        }\n      })\n      // when all changes & events are processed, emit afterTransaction event\n      this.emit('afterTransaction', this, transaction, remote)\n    }\n  }\n  // fake _start for root properties (y.set('name', type))\n  get _start () {\n    return null\n  }\n  set _start (start) {\n    return null\n  }\n  define (name, TypeConstructor) {\n    let id = new RootID(name, TypeConstructor)\n    let type = this.os.get(id)\n    if (this.share[name] === undefined) {\n      this.share[name] = type\n    } else if (this.share[name] !== type) {\n      throw new Error('Type is already defined with a different constructor')\n    }\n    return type\n  }\n  get (name) {\n    return this.share[name]\n  }\n  disconnect () {\n    if (this.connected) {\n      this.connected = false\n      return this.connector.disconnect()\n    } else {\n      return Promise.resolve()\n    }\n  }\n  reconnect () {\n    if (!this.connected) {\n      this.connected = true\n      return this.connector.reconnect()\n    } else {\n      return Promise.resolve()\n    }\n  }\n  destroy () {\n    super.destroy()\n    this.share = null\n    if (this.connector != null) {\n      if (this.connector.destroy != null) {\n        this.connector.destroy()\n      } else {\n        this.connector.disconnect()\n      }\n    }\n    if (this.persistence !== null) {\n      this.persistence.deinit(this)\n      this.persistence = null\n    }\n    this.os = null\n    this.ds = null\n    this.ss = null\n  }\n  whenSynced () {\n    return new Promise(resolve => {\n      this.once('synced', () => {\n        resolve()\n      })\n    })\n  }\n}\n\nY.extend = function extendYjs () {\n  for (var i = 0; i < arguments.length; i++) {\n    var f = arguments[i]\n    if (typeof f === 'function') {\n      f(Y)\n    } else {\n      throw new Error('Expected a function!')\n    }\n  }\n}\n\n// TODO: The following assignments should be moved to yjs-dist\nY.AbstractConnector = Connector\nY.AbstractPersistence = Persistence\nY.Array = YArray\nY.Map = YMap\nY.Text = YText\nY.XmlElement = YXmlElement\nY.XmlFragment = YXmlFragment\nY.XmlText = YXmlText\nY.XmlHook = YXmlHook\n\nY.TextareaBinding = TextareaBinding\n\nY.utils = {\n  BinaryDecoder,\n  UndoManager,\n  getRelativePosition,\n  fromRelativePosition,\n  addType,\n  integrateRemoteStructs,\n  toBinary,\n  fromBinary\n}\n\nY.debug = debug\ndebug.formatters.Y = messageToString\ndebug.formatters.y = messageToRoomname\n"],"names":["_integrateRemoteStructHelper","y","struct","id","_id","undefined","_integrate","ss","getState","user","clock","msu","_missingStructs","get","finalClock","_length","missingStructs","forEach","missing","decoder","missingDef","oldPos","pos","_fromBinary","length","_readyToIntegrate","push","delete","stringifyStructs","strBuilder","len","readUint32","i","reference","readVarUint","Constr","getStruct","logMessage","_logString","map","logID","join","integrateRemoteStructs","decoderPos","shift","_decoder","BinaryDecoder","uint8arr","missingEntry","MissingEntry","m","has","set","Map","readStateSet","ssLength","writeStateSet","encoder","lenPosition","writeUint32","state","writeVarUint","setUint32","writeDeleteSet","currentUser","currentLength","lastLenPos","numberOfUsers","laterDSLenPus","ds","iterate","n","gc","writeUint8","readDeleteSet","dsLength","dv","dvLength","j","from","readUint8","d","deletions","ID","Number","MAX_VALUE","diff","Math","min","del","stringifySyncStep1","auth","readVarString","protocolVersion","ssBuilder","sendSyncStep1","connector","syncUser","BinaryEncoder","writeVarString","room","authInfo","send","createBuffer","writeStructs","lenPos","keys","RootFakeUserID","os","_toBinary","readSyncStep1","senderConn","sender","warn","destroy","uid","receivedSyncStep2","role","stringifySyncStep2","len2","to","readSyncStep2","_setSyncedWith","messageToString","buffer","type","messageToRoomname","RootID","name","constructor","Y","Error","deleteItemRange","range","createDelete","_forwardAppliedStructs","item","getItemCleanStart","_deleted","_splitAt","_delete","itemLen","node","findNode","val","equals","nodeVal","nodeLen","next","transactionTypeChanged","sub","_transaction","newTypes","changedTypes","subs","Set","add","splitHelper","a","b","aID","_origin","_left","_right","_right_origin","_parent","_parentSub","foundOrigins","o","put","integrateChildren","start","right","defaultDomFilter","attributes","iterateUntilUndeleted","_insertNodeHelper","yxml","prevExpectedNode","child","insertedNodes","insertDomElementsAfter","applyChangesFromDom","dom","_yxml","YXmlHook","_y","knownChildren","Array","prototype","call","childNodes","filter","childType","expectedNode","_start","domCnt","childYXml","this","reflectChangesOnDom","events","_document","_mutualExclude","event","target","_dom","YXmlText","nodeValue","toString","attributesChanged","value","getAttribute","attributeName","removeAttribute","setAttribute","childListChanged","currentChild","firstChild","t","expectedChild","getDom","parentNode","nextSibling","removeChild","insertBefore","tmp","getRelativePosition","offset","fromRelativePosition","rpos","findNodeWithUpperBound","parent","afterTransactionSelectionFixer","transaction","remote","relativeSelection","fromY","toY","shouldUpdate","anchorNode","browserSelection","anchorOffset","focusNode","focusOffset","sel","setBaseAndExtent","simpleDiff","left","slice","domToYXml","doms","types","_unbindFromDom","_domFilter","nodeName","hookName","_yjsHook","dataset","yjsHook","nodeType","TEXT_NODE","ELEMENT_NODE","YXmlFragment","_YXmlElement","addHook","hook","getHook","xmlHooks","addStruct","structConstructor","structs","getReference","typeConstructor","references","generateUserID","crypto","getRandomValue","arr","Uint32Array","getRandomValues","randomBytes","buf","ceil","random","isStructInScope","scope","applyReverseOperation","reverseBuffer","performedUndo","transact","undoOp","pop","fromState","getItemCleanEnd","toState","op","_redone","deletedStructs","userID","_redo","parse","str","String","match","exec","parseFloat","toLowerCase","h","s","fmtShort","ms","round","fmtLong","plural","floor","fromBinary","toBinary","createMutualExclude","token","f","e","error","getFreshCnf","typeObserver","textarea","_this","textType","relativeStart","selectionStart","relativeEnd","selectionEnd","end","setSelectionRange","domObserver","_this2","remove","insert","N","color","tree","newParent","newRight","root","p","newLeft","Tree","nextID","clone","findWithLowerBound","prevID","findWithUpperBound","lessThan","prev","findNodeWithLowerBound","findSmallestNode","isFakeChild","blacken","isBlack","isRed","_fixDelete","sibling","redden","rotateLeft","rotateRight","v","_fixInsert","uncle","getUncle","grandparent","DSNode","DeleteStore","deletes","table","nId","findNext","markDeleted","_next","ArrayBuffer","Uint8Array","Buffer","newPos","uint","num","r","bytes","encodedString","fromCodePoint","decodeURIComponent","escape","rid","data","unescape","encodeURIComponent","split","c","codePointAt","Delete","_target","targetID","readID","_targetID","getItem","writeID","broadcastStruct","persistence","saveStruct","Transaction","beforeState","changedParentTypes","Item","_copy","selfID","userState","getNextID","setState","_beforeChange","_map","conflictingItems","itemsBeforeOrigin","clear","parentSub","pmap","info","_lastId","JSON","stringify","originID","origin","rightID","parentID","EventHandler","eventListeners","g","Type","_eventHandler","_deepEventHandler","path","callEventListeners","addEventListener","removeEventListener","values","ItemJSON","_content","ctnt","parsed","encoded","content","splice","ItemString","YEvent","currentTarget","unshift","YArrayEvent","yarray","_addedElements","addedElements","removedElements","YArray","parentSubs","_callEventHandler","toJSON","res","contentLen","Symbol","iterator","_item","_itemElement","_count","_this4","count","diffDel","_transact","_this5","prevJsonIns","rightLen","splitDiff","insertAfter","lastUndeleted","YMapEvent","ymap","keysChanged","YMap","key","_this3","old","size","YText","string","text","beforeTransactionSelectionFixer","getSelection","YXmlEvent","YXmlTreeWalker","_filter","_root","_currentNode","_firstCall","done","_domObserver","query","toUpperCase","element","scrollElement","_scrollElement","enableSmartScrolling","getAttributes","attrs","result","setDomFilter","xml","disconnect","_beforeTransactionHandler","off","innerHTML","_bindToDom","document","on","applyFilter","isChild","observeDeep","MutationObserver","_domObserverListener","takeRecords","diffChildren","mutation","change","yOnChildrenChanged","observe","YXmlElement","arg1","arg2","_setDom","attr","insertDomElements","stringBuilder","sort","keysLen","toLocaleLowerCase","apply","arguments","obj","createElement","appendChild","fillType","createDom","initialText","createTextNode","_YXmlHook","OperationStore","items","find","itemID","ins","insID","StateStore","entries","NamedEventHandler","_eventListener","_stateListener","listeners","_getListener","once","promise","Promise","resolve","_initStateListener","listener","args","ReverseOperation","created","Date","UndoManager","options","captureTimeout","_undoBuffer","_redoBuffer","_scope","_undoing","_redoing","reverseOperation","lastUndoOp","performedRedo","isNaN","long","selectColor","namespace","hash","charCodeAt","exports","colors","abs","createDebug","debug","enabled","self","curr","prevTime","coerce","index","replace","format","formatter","formatters","formatArgs","log","console","bind","useColors","init","enable","namespaces","save","skips","RegExp","substr","names","disable","test","stack","message","module","require$$0","window","process","documentElement","style","WebkitAppearance","firebug","exception","navigator","userAgent","parseInt","$1","humanize","lastC","Function","storage","removeItem","load","env","DEBUG","chrome","local","localStorage","err","AbstractConnector","opts","forwardAppliedOperations","connections","isSynced","userEventListeners","whenSyncedListeners","currentSyncTarget","broadcastBuffer","broadcastBufferSize","checkAuth","maxBufferLength","defer","syncStep2","_syncWithUser","_setContentReady","emit","firstContent","broadcastBufferSizePos","whenRemoteResponsive","then","broadcast","skipAuth","reject","roomname","messageType","processAfterAuth","authPermissions","messages","computeMessage","processAfterSync","userConn","conns","every","u","_fireIsSyncedListeners","AbstractPersistence","ys","cnf","mutualExclude","saveUpdate","_cnf","retrieve","destroyYjsInstances","deinit","model","updates","Binding","TextareaBinding","domTextarea","_typeObserver","unobserve","_contentReady","_opts","share","connected","initConnection","_init","initialCall","_callObserver","TypeConstructor","reconnect","extend","Connector","Persistence","Text","XmlElement","XmlFragment","XmlText","XmlHook","utils"],"mappings":"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"}